% !TEX encoding = UTF-8
% !TEX program = pdflatex
% !TEX root = AALP.tex
% !TEX spellcheck = it-IT

% 4 Ottobre 2016

\chapter{Introduzione}

Lo scopo del corso è quello di presentare alcune tecnologie avanzate dei linguaggi di programmazione, sia sotto forma pratica/tecnologica che teorica.

L'idea è quella di apprendere un modo per valutare un linguaggio di programmazione, perché non c'è un linguaggio migliore in assoluto, ma c'è sempre il linguaggio più adatto ad un determinato ambito. Non sempre però è possibile scegliere il linguaggio più adatto, ad esempio per questioni di retro-compatibilità.

\section{Come valutare un linguaggio di programmazione}

La valutazione del linguaggio dipende anzitutto dalla taglia del programma, che può variare da piccoli script a sistemi enormi e possono essere eseguiti sia su dei micro-controllori che su supercomputer.

C'è poi da tenere in considerazione l'aspettativa di vita del programma, se l'obiettivo è quello di codificare un prototipo può essere utili avere un linguaggio di scripting, mentre se il programma deve essere manutenuto nel tempo può essere più conveniente utilizzare un linguaggio robusto.

Anche i programmatori influiscono sulla tipologia del linguaggio, se deve essere usato da un programmatore alle prime armi è bene che il linguaggio sia semplice, mentre ad un programmatore esperto può tornare più utile un linguaggio flessibile.

La scelta invece viene guidata da vari criteri come:

\begin{itemize}
	\item efficienza del linguaggio
	\item retro-compatibilità
	\item portabilità
	\item correttezza
	\item produttività
	\item espressività
\end{itemize}

\noindent Non sempre tutte queste caratteristiche coesistono, anzi il più delle volte si scontrano tra loro, portando così ad un trade-off.

\subsection{Classificazione dei linguaggi di programmazione}

Un'altra idea è quella di classificare i linguaggi per livello di astrazione o per paradigmi, ma anche così facendo non sempre le differenze sono marcate.

Si possono però suddividere i linguaggi in compilati e interpretati, ma ultimamente anche i linguaggi interpretati si basano su un piccolo compilatore.
Ci sono poi i linguaggi di scripting ed embeddable che funzionano meglio in fase di prototipazione o su micro-controllori.

Un'altra discriminazione può essere fatto sul paradigma:

\begin{itemize}
	\item \textbf{Imperativo}: descrive la computazione in termini di comandi che cambiano lo stato di un programma. \textit{Espressioni che vengono eseguite}.
	\item \textbf{Funzionale}: puro o impuro, che descrive la computazione come aggregazione di funzioni, evitando il concetto di stato e di dati modificabili. \textit{Espressioni che vengono valutate}.
	\item \textbf{OOP}: struttura il programma in termini di oggetti e di azioni da svolgere con essi. \textit{Insieme di oggetti che vengono manipolati}.
	\item \textbf{Event driven}: il flusso del programma è determinato da una sequenza di eventi. \textit{Insieme di eventi da gestire}.
	\item \textbf{Dichiarativo}: anziché definire la sequenza di passi per risolvere il problema, viene formulato il problema che deve essere risolto. Es: SQL, Prolog. \textit{Insieme di regole che devono essere applicate}.
	\item \textbf{Concorrente}: descrive flussi di computazione concorrente. \textit{Insieme di messaggi che devono essere inviati e ricevuti}.
\end{itemize}

\noindent Tutto bello, però i linguaggi moderni appartengono a più paradigmi.

\section{L'evoluzione dei linguaggi di programmazione}

\begin{enumerate}
	\item \textbf{Linguaggi strutturati}: sono linguaggi che permettono di strutturare il codice a blocchi. \`E il periodo boom dei PC e viene data a tutti la possibilità di programmare il proprio computer.
	\item \textbf{Programmazione ad oggetti}: la programmazione OO viene ``scoperta'' prima, ma il boom avviene quando iniziano a comparire i primi programmi corposi, quando è diventato importante il riuso del codice, l'incapsulazione, ecc.
	\item \textbf{Linguaggi portabili e sicuri}: dalla nascita di Internet si è reso necessario produrre programmi portabili e più sicuri, favorendo i linguaggi come Java/PHP/JavaScript.
	\item \textbf{Linguaggi volti alla produttività}: nel tempo ci si è accorti che utilizzare i linguaggi non tipati porta a dei problemi di manutenzione. Si sta quindi tornando ad un paradigma tipato.
	\item \textbf{Programmi concorrenti}: in concetto di concorrenza è nato molto prima di internet, tuttavia non è stato adottato subito a causa della complessità elevata. Ultimamente però, per aumentare l'efficienza dell'hardware ci si sta spostando su architetture concorrenti, rendendo così necessario adottare un paradigma di programmazione concorrente.
	\item \textbf{Programmi distribuiti}: spinti dal marketing legato al cloud e dalla programmazione reattiva, un paradigma di programmazione secondo il quale il programma deve essere in grado di reagire ad \textbf{eventi}, \textbf{carico} e \textbf{fallimenti}. Si parte quindi da un modello event driven asincrono, tenendo conto che l'evento viene scatenato da un fonte distribuita (\textit{futures, streams, sistemi push}). Vengono poi aggiunti sistemi di reazione al carico: l'applicazione deve adattarsi automaticamente al carico di lavoro che c'è da eseguire, liberando o richiedendo ulteriori CPU. Infine è necessario avere un'applicazione resistente ai fallimenti che possono essere causati da un bug software, da un problema all'hardware o da un problema di comunicazione.
	\item \textbf{Big data}: c'è la necessità di elaborare grandi quantità di dati in modo efficiente.
\end{enumerate}

\noindent Si può quindi osservare che ogni volta che sorge una nuova esigenza a livello industriale, c'è anche una corrispondente evoluzione nei linguaggi di programmazione mainstream.

\subsection{Parallelismo e concorrenza}

\begin{itemize}
\item \textbf{Parallelismo}: programmi che avviano più flussi di controllo paralleli che fanno le stesse operazioni e che non interagiscono tra loro.
\item\textbf{Concorrenza}: programma che avvia più flussi di controllo che devono comunicare e sincronizzarsi tra loro.
\end{itemize}

\noindent Non è detto che un linguaggio parallelo supporti bene anche il paradigma concorrente e viceversa.

Si tratta comunque di paradigmi di programmazione più difficili, sia per via del non determinismo, sia perché non c'è ancora un modello standard per i linguaggi concorrenti, perché ci si trova ancora in una fase di sperimentazione su vari modelli:
\begin{itemize}
	\item A memoria condivisa, come fa Java;
	\item A messaggi, come fa Scala;
	\item GP-GPU per il parallelismo utilizzando hardware dedicato.
\end{itemize}

\section{Programma del corso}

\begin{enumerate}
	\item Studio di un mini linguaggio funzionale: semantica e sistema di tipi per ragionare sul linguaggio. Facendo anche un confronto con la pratica.
	\item Arricchimento del linguaggio: riferimenti, eccezioni, polimorfismo e inferenza.
	\item Mini linguaggio ad oggetti: Featherweight Java, in versione funzionale e imperativo.
	\item Scala: un mix di paradigma funzionale e OO, confrontandolo con Java 8.
\end{enumerate}

\noindent Ogni tanto ci saranno dei seminari tenuti a sorpresa da persone esterne.

\subsection{Materiale didattico}

\begin{itemize}
	\item Per la prima parte ci sono gli appunti forniti dalla docente.
	\item Per la parte su Scala ci saranno le slide.
\end{itemize}

\noindent Si trova tutto sul sito: \url{http://www.math.unipd.it/~crafa/la/}.

\subsection{Esame}

Composto da una parte di esercizi e da un progetto/approfondimento. Il giorno dell'esame viene richiesto uno degli esercizi e la presentazione del progetto.

Come progetto c'è un'applicazione in un qualche linguaggio di programmazione, abbastanza libero, l'importante è che l'applicazione sfrutti i punti di forza del linguaggio scelto. Un'altra idea può essere quella di confrontare le prestazioni di due linguaggi di programmazione diversi per la stessa applicazione.

Come approfondimento c'è lo studio di alcune caratteristiche di uno o più linguaggi di programmazione. Anche su tematiche attuali dell'informatica.


