<html><head><meta charset="utf-8"><link rel="stylesheet" href="../_builder/pdf.css"><link rel="stylesheet" href="../_builder/highlight/styles/default.css"><script src="../_builder/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><h1 id="linguaggi-di-programmazione-lezione-1">Linguaggi di programmazione - Lezione 1</h1>
<p>I primi linguaggi importanti per la storia sono il C/C++, Java e Haskell.</p>
<p>Il controllo dei tipi è iniziato dal Fortran (anni 50) con la gestione statica dei valori delle variabili. La prima versione del Fortran tuttavia non ammetteva ricorsinoe.</p>
<p><em>I linguaggi imperativi hanno un approccio più ingegneristico mentre quelli funzionali sono più matematici e astratti.</em></p>
<p>Al giorno d&#39;oggi i linguaggi hanno caratteristiche miste, sia imperative che funzionali. Questo perché si cerca di andare verso un mondo parallelo e distribuito.</p>
<blockquote>
<p>Il JavaScript è più ad oggetti che funzionale.</p>
</blockquote>
<h2 id="processo-di-esecuzione">Processo di esecuzione</h2>
<p>Codice Sorgente --&gt; Compilatore --&gt; Programma Oggetto --&gt; Interprete</p>
<p>Ci sono sempre due fasi: quella di compilazione e quella di interpretazione.</p>
<p>Se è più importante la fase di compilazione si ottiene una maggiore efficienza e in alcuni casi il programma può essere eseguito direttamente (come nel C++).</p>
<p>Se è più importante la parte di interpetazione il programma è più sicuro e dinamico (meno crash), come Java.</p>
<h2 id="computabilit-">Computabilità</h2>
<p>Il calcolo di una funzione può non andare a buon fine, per un errore, come la divisione per 0 oppure perché semplicemente il calcolo non termina.</p>
<p>La non terminazione è un modo per creare un funzione parziale, cioè una funzione che non è calcolabile per alcuni valori.</p>
<p>Tutte le funzioni sono calcolabili? No. Kurt Göedel (anni &#39;30).</p>
<p>Questa domanta è nata prima ancora dei computer attuali, questo perché erano presenti dei modelli di calcolo formale:</p>
<ul>
<li>Macchine di Turing, macchine a registri, macchine di Post;</li>
<li>Linguaggi funzionali, come il Lambda calcolo;</li>
<li>Regole di composizione di funzioni a partire da funzioni elementari.</li>
</ul>
<p>Tutti i modelli precedenti definiscono la stessa classe di funzioni --&gt; formazilizzano il calcolo dello stesso modello di funzioni, le <strong>funzioni parziali ricorsive</strong>.</p>
<p><strong>Tesi di Church</strong>: Tutte le funzioni parziali ricorsive sono calcolabili. Non è un teorema, ma una tesi in quanto è un concetto intuitivo che non è ancora stato dimostrato.</p>
<p>Tutto quello che può fare un computer moderno lo può fare anche una macchina di turing, il che vuol dire che tutti i linguaggi moderni sono turing completi, cioè sono in grado di calolcare tutte le funzioni calcolabili (funzioni parziali ricorsive).</p>
<p>La Turing completezza non aiuta quindi a confrontare tra loro i linguaggi di programmazione, perciò si preferisce utilizzare l&#39;esperessività di un linguaggio come criterio di confronto ed è per questo che utilizziamo Java e non una macchina di turing.</p>
<p>L&#39;espressività ha però un prezzo in efficienza e di conseguenza non è possibile creare il linguaggio di programmazione perfetto.</p>
<h2 id="incalcolabilit-con-la-macchina-di-turing">Incalcolabilità con la Macchina di Turing</h2>
<p>Göedel ha dimostrato che non tutte le funzioni sono calcolabili e questo è possibile dimostrarlo con una macchina di turing.</p>
<p>Consideriamo tutte le funzioni che possono essere calcolate con un &quot;Si&quot; o con un &quot;No&quot; (problemi decisionali).</p>
<blockquote>
<p>f : I --&gt; SI/NO</p>
</blockquote>
<p>Göedel ha dimostrato che la decisione della terminazione di una macchina di turing non è decidibile (calcolabile).</p>
<blockquote>
<p>I = &lt;P, x&gt;</p>
<p>P -&gt; stringa che descrive una macchina di turing</p>
<p>x -&gt; stringa scritta nel nastro di P</p>
<p>P(x) -&gt; è il calcolo della macchina P su x</p>
</blockquote>
<p>Se la terminazione di P su x è decidibile allora esiste un programma (o macchina di turing) Q che dato:</p>
<blockquote>
<p>&lt;P, x&gt; --&gt; Q(P,x) = SI se P(x) termina, NO altrimenti</p>
</blockquote>
<p>Supponiamo che questo per assurdo sia vero.</p>
<p>Usando Q è quindi possibile definire D in modo che prenda in input una macchina di turing ed esegua Q(P,P) e che:</p>
<ul>
<li>Se Q(P,P) = SI, allora D non termina</li>
<li>Se Q(P,P) = NO, allora D termina</li>
</ul>
<p>Cioè, se D(P) termina, allora vuol dire che la macchina P non riesce a calcolare se stessa, P(P) non è calcolabile.
E viceversa.</p>
<p>Considerando l&#39;esecuzione </p>
<blockquote>
<p>D(D)</p>
</blockquote>
<p>In questo caso viene eseguito Q(D,D) inquanto la macchina D è composta in parte da Q.</p>
<p>Così facendo, Q(D,D) calcola SI se D(D) termina e NO se D(D) non termina.</p>
<p>Ma se D(D) termina, allora per come è definito D(D) non dovrebbe terminare e viceversa.</p>
<p>Si arriva così ad una situazione assurda che dimostra che la terminazione di un programma non è calcolabile.</p>
<p>Tuttavia la terminazione di una macchina di turing è semi-decidibile, in quanto si può sempre dire se una macchina di turing termina (simulandola) ma non si può dire il contrario.</p>
<p>Anche perché se fosse possible, allora il problema totale sarebbe decidibile (<em>basta una macchina di turing che simuli contemporaneamente due macchine di turing, ognuna che risolva uno dei due semi-problemi</em>).</p>
<p>Un problema si dice <strong>indecidibile</strong> quando esiste un sotto-insieme infinito di istanze per il quale non è decidibile, tuttavia possono essere presenti alcune istanze per le quali il problema è decidbilie.</p>
<h2 id="lezione-2-riduzione-dei-problemi">Lezione 2 - Riduzione dei problemi</h2>
<h2 id="riduzione-dei-problemi">Riduzione dei problemi</h2>
<p>Siano R e R&#39; due problemi (<em>funzioni che vengono calcolate con un SI/NO</em>) con R che è NON decidibile e R&#39; di cui non si sa nulla.</p>
<p>Per ottenere delle informazioni su R&#39; si <strong>riduce R a R&#39;</strong>.</p>
<p>Cioè per ogni istanza I di R si cerca di costruire un istanza I&#39; di R&#39; tale che</p>
<blockquote>
<p>R(I) = SI se e solo se R&#39;(I&#39;) = SI</p>
<p>R(I) = NO se e solo se R&#39;(I&#39;) = NO</p>
</blockquote>
<h3 id="halt-_perogni-halt-_v-">HALT_PEROGNI (HALT_V)</h3>
<p>Data una macchina di turing P:</p>
<blockquote>
<p>HALT_V(P) = SI --&gt; Se per ogni stringa x, P(x) termina</p>
<p>HALT_V(P) = NO --&gt; se per qualche stringa x, P(x) non termina</p>
</blockquote>
<p>Questo problema è indecidibile e si dimostra per riduzione, riducendo HALT ad HALT_V (<em>HALT è la decidibilità della terminazione di una macchina di turing</em>).</p>
<blockquote>
<p>HALT        HALT_V</p>
<p>\&lt;P, x&gt; --> P<sub>x</sub></p>
</blockquote>
<p>Bisogna quindi riuiscre a trasformare &lt;P, x&gt; in P<sub>x</sub> in modo che i risultati dei due problemi coincidano.</p>
<p>L&#39;idea è quella di trovare una macchina di turing che si comporta, con qualsiasi input, come si comporta P(x).</p>
<p>Questa macchina è quindi definita come:</p>
<blockquote>
<p>P<sub>x</sub> = P&#39; : P</p>
</blockquote>
<p>Dove P&#39; è un programma che pulisce cancella l&#39;input del nastro di P e lo sostiuisce con la stringa <em>x</em>.</p>
<p>In questo modo è facile vedere che</p>
<blockquote>
<p>HALT(&lt;P,x&gt;) = SI se e solo se HALT_V(P<sub>x</sub>) = SI</p>
</blockquote>
<h3 id="riduzione-della-complessit-">Riduzione della complessità</h3>
<p>Lo stesso meccanismo di riduzione di un problema per calcolarne la calcolabilità vale anche per la complessità (non di un algoritmo, ma del problema in se).</p>
<p>Se sappiamo che P ha complessità <em>G(n)</em> e sospettiamo che P&#39; abbia complessità <strong>almeno</strong> <em>G(n)</em>, si può trovare un algoritmo che riduce P in P&#39; con una complessità <em>c(n)</em>, tale che <em>c(n)</em> sia irrisoria rispetto a <em>G(n)</em> altrimenti tutta la baracca non avrebbe senso.</p>
<p>Se si riesce a trovare questo algoritmo, allora decidere P&#39; costa F(n) con F(n) ≥ G(n).</p>
<p>Questo perché, altrimenti, potremmo decidere P in c(n) + F(n) &lt; G(n).</p>
<h2 id="perch-la-decidibilit-importante-">Perché la decidibilità è importante?</h2>
<p>Perché farebbe comodo riuscire a sapere se un programma scritto nei linguaggi di programmazione moderni termina o meno, senza andarlo ad eseguire.</p>
<p>A livello pratico tutte le proprietà interessanti dei linguaggi di programmazione non sono decidibili.</p>
<blockquote>
<p>Cosideriamo una proprità k:</p>
<p>P = P&#39; : P&#39;&#39; con P&#39; che rispetta k e P&#39;&#39; che viola k.</p>
<p>P viola k se e solo se P&#39; termina e quindi decidere se P viola k significa decidere se P&#39; termina, con P&#39; qualsiasi.</p>
</blockquote>
<p>Il tutto questo per dire che durante la compilazione di un programma non possiamo sapere come questo si comporterà durante l&#39;esecuzione.</p>
<p>Possiamo però approsimarne alcune proprietà.</p>
<p>Con l&#39;analisi statica riusciamo a dire e ad avere la sicurezza che in una determinata parte del programma non ci siano errori.</p>
<h3 id="test-a-run-time-vs-compile-time">Test a run-time vs compile-time</h3>
<p>L&#39;analisi di un programma può essere fatta anche a runtime ma questo risulta meno efficiente.</p>
<blockquote>
<p>if TEST then OK else ERRORE</p>
</blockquote>
<p>Il compilatore dovrebbe rifiutarsi di compilare il programma perché non può decidere se c&#39;è l&#39;errore o meno (approccio pessimistico).</p>
<p>A runtime il test potrebbe essere sempre true e l&#39;errore potrebbe non essere mai rilevato (situazione pericolosa).</p>
<p>Ha quindi più senso fare dei controlli a compile time.</p>
<p>Nel caso dei tipi questo controllo viene fatto sia a runtime che a compile time.</p>
<p>Si cerca comunque di fare il massimo possibile a compile time dal momento che è più efficiente, però alcune cose, come il bound-check di un array, possono essere fatte solo a runtime.</p>
<h1 id="lezione-3-haskell">Lezione 3- Haskell</h1>
<h2 id="parte-generica">Parte generica</h2>
<ul>
<li><code>:t f</code> per sapere il tipo della funzione <code>f</code>.</li>
<li><code>let</code> per definire delle costanti, viene usato solo nell&#39;ambiente <code>ghci</code>, dentro un file non è necessario</li>
<li><code>it</code> contiene l&#39;ultimo valore calcolato</li>
</ul>
<h2 id="funzioni">Funzioni</h2>
<p>Vengono invocate con il nome, seprato da un spazio, seguito dai parametri, ognuno seprato da uno spazio</p>
<pre><code class="lang-haskell">foo para<span class="hljs-title">m1</span> para<span class="hljs-title">m2</span>
</code></pre>
<p>Non ci sono le parentesi nell&#39;invocazione, quelle vengono utilizzate solamente per esprimere la priorità d&#39;esecuzione</p>
<pre><code class="lang-haskell">foo <span class="hljs-list">(<span class="hljs-keyword">foo</span> <span class="hljs-number">3</span>)</span>
-- in modo imperativo sarebbe
foo<span class="hljs-list">(<span class="hljs-keyword">foo</span><span class="hljs-list">(<span class="hljs-number">3</span>)</span>)</span>
-- e non questo
foo<span class="hljs-list">(<span class="hljs-keyword">foo</span>,<span class="hljs-number">3</span>)</span>
</code></pre>
<p>Una funzione si definisce nel seguente modo:</p>
<pre><code class="lang-haskell">doubleUs x y = x*<span class="hljs-number">2</span> + y*<span class="hljs-number">2</span>
</code></pre>
<p>L&#39;apostrofo può comparire nel nome della funzione.</p>
<p>Le funzioni <strong>non</strong> possono iniziare con una lettera maiuscola.</p>
<p>Se una funzione non riceve dei parametri diventa una <em>definition</em> o <em>name</em>.</p>
<h3 id="funzioni-currificate">Funzioni currificate</h3>
<pre><code class="lang-haskell">Prelude&gt; let g <span class="hljs-tag">a</span> <span class="hljs-tag">b</span> = a+<span class="hljs-tag">b</span>
Prelude&gt; :t g
g :: Num <span class="hljs-tag">a</span> =&gt; <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">a</span> -&gt; a
</code></pre>
<p>La funzione <code>g</code> dell&#39;esempio è detta <em>currificata</em>. Una funzione che può prendere vari parametri ma li elabora uno alla volta.
<code>a -&gt; a -&gt; a</code> è il tipo della funzione <code>g</code></p>
<pre><code class="lang-haskell">Prelude&gt; <span class="hljs-keyword">let</span> h x = g x
Prelude&gt; :t h
h <span class="hljs-comment">:: Num a =&gt; a -&gt; a -&gt; a</span>
</code></pre>
<p><code>g</code> aspetta due parametri per far la somma, se a <code>g</code> passo un solo parametro ottengo una funzione che aspetta i restanti parametri, necessari per eseguire <code>g</code>.</p>
<p>Una funzione <em>currificata</em> è quindi una funzione a cui non è necessario passare tutti i parametri, ma li aspettano uno alla volta.</p>
<p><em>questo dovrebbe essere il significato della -&gt;</em></p>
<pre><code class="lang-haskell">Prelude&gt; let <span class="hljs-tag">q</span> = h <span class="hljs-number">3</span>
</code></pre>
<p><code>q</code> invoca <code>h</code> con <code>3</code> e ritorna <code>g</code> con già un parametro passato.</p>
<pre><code class="lang-haskell">Prelude&gt; q <span class="hljs-number">4</span>
<span class="hljs-number">7</span>
</code></pre>
<p>Quando esegue <code>q 4</code> viene passato il secondo parametro che permette l&#39;esecuzione di <code>g</code>, la quale ritorna <code>7</code>.</p>
<p>Nella descrizione del tipo di una funzione la prima parte (<code>Num a</code>) specifica che c&#39;è un solo tipo, in questo caso numerico.</p>
<p>Mentre la seconda parte, dopo la <code>=&gt;</code> specifica il tipo dei parametri e del valore di ritorno.
Quindi <code>a -&gt; a -&gt; a</code> specifica che il primo parametro, il secondo parametro e il valore di ritorno hanno tutti lo stesso tipo.</p>
<pre><code class="lang-haskell">Prelude&gt; :t (==)
(==) :: Eq <span class="hljs-tag">a</span> =&gt; <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">a</span> -&gt; Bool
</code></pre>
<p><code>Eq</code> racchiude tutti i tipi che sono tra loro confrontabili.
<code>a -&gt; a -&gt; Bool</code> specifica che vengo presi due parametri dello stesso tipo e viene ritornato un valore booleano.</p>
<p>Quando definisco dei miei tipi, posso specificare che appartengono alla categoria di <code>Eq</code>.</p>
<p>Nel caso il tipo di una funzione includa un maggior numero di tipi, questo viene descritto come <code>Num a, Num b, Num c =&gt; a -&gt; b -&gt; c</code></p>
<pre><code class="lang-haskell">Prelude&gt; <span class="hljs-keyword">let</span> asd = (==) 2
Prelude&gt; :t asd
asd <span class="hljs-comment">:: (Eq a, Num a) =&gt; a -&gt; Bool</span>
</code></pre>
<p>In questo caso il tipo <code>a</code> deve essere sia numerico, sia confrontabile. La funzione ritorna come valore una funzione currificata, che in questo caso è la funzione <code>==</code> che si aspetta un secondo parametro.</p>
<pre><code class="lang-haskell">Prelude&gt; asd <span class="hljs-number">2</span>
<span class="hljs-literal">True</span>
Prelude&gt; asd <span class="hljs-number">32</span>
<span class="hljs-literal">False</span>
</code></pre>
<h3 id="funzioni-polimorfe">Funzioni polimorfe</h3>
<p>Le funzioni polimorfe sono quelle che accettano variabili di qualsiasi tipo.</p>
<pre><code class="lang-haskell">:t head
<span class="hljs-label">head ::</span> [<span class="hljs-literal">a</span>] -&gt; <span class="hljs-literal">a</span>
</code></pre>
<h2 id="if">If</h2>
<ul>
<li>l&#39;<code>else</code> è obbligatorio</li>
<li>c&#39;è anche il <code>then</code> da mettere</li>
</ul>
<pre><code class="lang-haskell">doubleSmallNumber x = <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span>  
                        then x  
                        <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span>
</code></pre>
<h2 id="list">List</h2>
<p>Nelle liste è possibile tenere solo elementi di uno stesso tipo.</p>
<p>Per concantenare due liste c&#39;è l&#39;operatore <code>++</code>.</p>
<p>Le stringhe vengono considerate come liste di caratteri.</p>
<p>L&#39;operatore <code>:</code> permette di inserire in testa ad una lista.</p>
<pre><code class="lang-haskell">ghci&gt; <span class="hljs-number">5</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]  
[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
</code></pre>
<p>Si possono definire liste di liste di liste. Hell yeah!</p>
<p>Gli operatori di disuguaglianza <code>&lt;,&gt;,&lt;=,&gt;=</code> permettono di confrontare delle liste in odrine lessicografico.</p>
<h3 id="list-comprehension">List comprehension</h3>
<p>Modo compatto di esprimere liste che deriva dalla notazione matematica.</p>
<pre><code class="lang-haskell">Prelude&gt; [x*<span class="hljs-number">2</span> | x &lt;- [<span class="hljs-number">1.</span><span class="hljs-number">.10</span>], x*<span class="hljs-number">2</span> &gt;= <span class="hljs-number">12</span>]
[<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]
</code></pre>
<pre><code class="lang-haskell"><span class="hljs-name">Prelude</span>&gt; <span class="hljs-atom">let</span> <span class="hljs-atom">removeNonUppercase</span> <span class="hljs-atom">st</span> = [<span class="hljs-atom">c</span> | <span class="hljs-atom">c</span> &lt;- <span class="hljs-atom">st</span>, <span class="hljs-atom">c</span> <span class="hljs-string">`elem`</span> [<span class="hljs-string">'A'</span>..<span class="hljs-string">'Z'</span>]]
<span class="hljs-name">Prelude</span>&gt; <span class="hljs-atom">removeNonUppercase</span> <span class="hljs-string">"pIPPo"</span>
<span class="hljs-string">"IPP"</span>
</code></pre>
<h2 id="tipi-predefiniti">Tipi predefiniti</h2>
<p>Sono presenti delle classi di tipo che raggruppano tipi tra loro simili sui quali è possibile eseguire funzioni simili.
Ad esempio <code>Num</code> raggruppa tutti i tipi che si comportano come numeri.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<pre><code class="lang-haskell"><span class="hljs-type">Prelude</span>&gt; <span class="hljs-keyword">let</span> head' <span class="hljs-literal">[]</span> = error <span class="hljs-string">"No head for empty list"</span>
<span class="hljs-type">Prelude</span>&gt; <span class="hljs-keyword">let</span> head' (x:_) = x
<span class="hljs-type">Prelude</span>&gt; :t head'
head' :: [t] -&gt; t
</code></pre>
<p>Posso definire delle funzioni con lo stesso nome per &quot;matchare&quot; i vari parametri possibili.</p>
<p><code>(x:_)</code> mactha tutti i parametri che sono una lista, <code>x</code> è il primo elemento, <code>_</code> matcha un valore qualsiasi, <code>:</code> concatena <code>x</code> con il valore qualsiasi, ottenendo così una lista.</p>
<p><code>(x:xs)</code> in questo caso avviene lo stesso match, solo che con <code>xs</code> ho il valore del resto della lista.</p>
<p>Posso anche usare una versione alternativa del pattern matching tra parametri che è equivalente.</p>
<pre><code class="lang-haskell">head<span class="hljs-string">''</span> xs = <span class="hljs-keyword">case</span> xs <span class="hljs-keyword">of</span> []<span class="hljs-function"> -&gt;</span> error <span class="hljs-string">"no head"</span>
                    <span class="hljs-function"><span class="hljs-params">(x:_)</span> -&gt;</span> x
</code></pre>
<h2 id="guardie">Guardie</h2>
<pre><code class="lang-haskell"><span class="hljs-label">max' ::</span> (Ord <span class="hljs-literal">a</span>) =&gt; <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span> -&gt; <span class="hljs-literal">a</span>
max' <span class="hljs-literal">a</span> b
    | <span class="hljs-literal">a</span> &gt; b     = <span class="hljs-literal">a</span>
    | otherwise = b
</code></pre>
<p>Rappresentano una specie di <code>if-elseif</code>.</p>
<p>Da notare che nella definzione della funzione non serve usare l&#39;uguale.</p>
<h2 id="where">Where</h2>
<pre><code>initials :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
initials firstname lastname = [f] ++ <span class="hljs-string">". "</span> ++ [l] ++<span class="hljs-string">". "</span>
    <span class="hljs-keyword">where</span> (f:_) = firstname
          (l:_) = lastname  
*Main&gt; initials <span class="hljs-string">"giacomo"</span> <span class="hljs-string">"manzoli"</span>
<span class="hljs-string">"g. m. "</span>
</code></pre><h2 id="let-it-be-in-">Let it be (in)</h2>
<pre><code class="lang-haskell">initials' :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span>
initials' firstname lastname = <span class="hljs-keyword">let</span>
                                    (f:_) = firstname
                                    (l:_) = lastname
                                <span class="hljs-keyword">in</span>
                                    [f] ++ <span class="hljs-string">". "</span> ++ [l] ++<span class="hljs-string">". "</span>
</code></pre>
<p><code>Let-in</code> ritorna un&#39;esperessione, mentre <code>where</code> permette di definire delle costanti all&#39;interno di un&#39;espressione.</p>
<pre><code class="lang-haskell">f3 :: <span class="hljs-string">[a]</span> -&gt; (<span class="hljs-string">[a]</span>,<span class="hljs-string">[a]</span>,<span class="hljs-string">[a]</span>,<span class="hljs-string">[a]</span>)
f3 l =  let
            aux <span class="hljs-string">[]</span> = (<span class="hljs-string">[]</span>,<span class="hljs-string">[]</span>)
            aux (x:<span class="hljs-string">[]</span>) = (<span class="hljs-string">[x]</span>,<span class="hljs-string">[]</span>)
            aux (x:y:xs) = (<span class="hljs-string">[x,y]</span>,xs)
        in
            let
                (x1,y1) = aux l
                (x2,y2) = aux y1
                (x3,y3) = aux y2
            in
                (x1,x2,x3,y3)
</code></pre>
<h1 id="lezione-4-even-more-haskell">Lezione 4 - Even more Haskell</h1>
<h2 id="algebric-data-types">Algebric data types</h2>
<p>Tipi definiti dall&#39;utente.</p>
<pre><code class="lang-haskell"><span class="hljs-type">data</span> <span class="hljs-built_in">Shape</span> = Circle <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> | Rectangle <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span>
</code></pre>
<p>Definisco il tipo <code>Shape</code> che può essere costituito da valori conformi alla parte <code>Circle</code> o <code>Rectangle</code>.</p>
<p>Da notare l&#39;utilizzo delle maiuscole per il nome del tipo o dei costruttori</p>
<pre><code class="lang-haskell"><span class="hljs-constant">Prelude&gt;</span> <span class="hljs-symbol">:t</span> <span class="hljs-constant">Circle</span>
<span class="hljs-constant">Circle </span><span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Shape</span>
<span class="hljs-constant">Prelude&gt;</span> <span class="hljs-symbol">:t</span> <span class="hljs-constant">Rectangle</span>
<span class="hljs-constant">Rectangle </span><span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Float </span>-&gt; <span class="hljs-constant">Shape</span>
</code></pre>
<p>I due costruttori sono delle normali funzioni che si aspettano dei parametri.</p>
<p>Tuttavia con questa definzione il sistema non sa stampare il tipo <code>Shape</code>, è quindi necessario specificare che <code>Shape</code> è stampabile:</p>
<pre><code class="lang-haskell"><span class="hljs-type">data</span> <span class="hljs-built_in">Shape</span> = Circle <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> | Rectangle <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> <span class="hljs-built_in">Float</span> deriving Show
</code></pre>
<p>In questo modo si specifica che <code>Shape</code> fa parte della classe dei tipi stampabili.</p>
<pre><code class="lang-haskell">Prelude&gt; Circle <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>
Circle <span class="hljs-number">2.0</span> <span class="hljs-number">3.0</span> <span class="hljs-number">4.0</span>
-- viene stampata la stringa utilizzata per invocare il costruttore
</code></pre>
<p>Questa cosa funziona out-of-the-box solo nel caso i valori che costituiscono il tipo derivano anche essi da <code>Show</code>.</p>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Point</span> = <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> <span class="hljs-type">Float</span> <span class="hljs-keyword">deriving</span> <span class="hljs-container">(<span class="hljs-type">Show</span>)</span></span>
<span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Shape</span> = <span class="hljs-type">Circle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Float</span> | <span class="hljs-type">Rectangle</span> <span class="hljs-type">Point</span> <span class="hljs-type">Point</span> <span class="hljs-keyword">deriving</span> <span class="hljs-container">(<span class="hljs-type">Show</span>)</span></span>
</code></pre>
<p><code>Point</code> deve derivare da <code>Show</code> altrimenti si verifica un errore.</p>
<p>Da notare che il nome del costruttore può o meno matchare il nome del tipo.</p>
<pre><code class="lang-haskell">Prelude&gt; :t Circle
Circle :: Point -&gt; Float -&gt; Shape
Prelude&gt; let p = Point <span class="hljs-number">10</span> <span class="hljs-number">20</span>
Prelude&gt; Circle p <span class="hljs-number">20</span>
Circle (Point <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>) <span class="hljs-number">20.0</span>
-- da notare che Circle <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> non funziona più
Prelude&gt; Circle (Point <span class="hljs-number">10</span> <span class="hljs-number">20</span>) <span class="hljs-number">5</span>
Circle (Point <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>) <span class="hljs-number">5.0</span>
</code></pre>
<pre><code class="lang-haskell"><span class="hljs-shader"><span class="hljs-keyword">surface</span> :: Shape -&gt; Float
<span class="hljs-keyword">surface</span> (</span>Circle _ _ r) = pi * r ^ <span class="hljs-number">2</span>
<span class="hljs-shader"><span class="hljs-keyword">surface</span> (</span>Rectangle x1 y1 x2 y2) = (<span class="hljs-built_in">abs</span> $ x2 - x1) - (<span class="hljs-built_in">abs</span> $ y2 - y1)
</code></pre>
<p>Da notare che quando definisco la funzione per un determinato tipo posso fare il pattern matching sulla tipologia del costruttore.</p>
<p><em>La funzione <code>surface</code> dell&#39;esempio funziona con la versione del costruttore senza il tipo <code>Point</code>.</em></p>
<h2 id="incapsulamento">Incapsulamento</h2>
<pre><code class="lang-haskell"><span class="hljs-module"><span class="hljs-keyword">module</span> Shape
<span class="hljs-container">(
    <span class="hljs-type">Point(..)</span>
    ,<span class="hljs-type">Shape(..)</span>
    ,surface
)</span> <span class="hljs-keyword">where</span></span>

<span class="hljs-comment">-- definzione delle funzioni</span>
</code></pre>
<p>In questo modo, quando viene fatto l&#39;include si vedono solo le funzioni in lista.</p>
<p>Il <code>(..)</code> permette di esportare anche la definzione dei costruttori.</p>
<h2 id="alberi">Alberi</h2>
<pre><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">EmptyTree</span> | <span class="hljs-type">Node</span> a <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-container">(<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span> <span class="hljs-keyword">deriving</span> <span class="hljs-container">(<span class="hljs-type">Eq</span>, <span class="hljs-type">Show</span>, <span class="hljs-type">Read</span>)</span></span>

<span class="hljs-type">Prelude</span>&gt; :t <span class="hljs-type">Node</span>
<span class="hljs-type">Node</span> :: a -&gt; <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">Tree</span> a -&gt; <span class="hljs-type">Tree</span> a
</code></pre>
<p>In questo caso il tipo <code>a</code> speficia il tipo del contenuto di un nodo, gli altri <code>Tree</code> rappresentano i due sotto alberi. Il tipo <code>Tree</code> è quindi parametrico.</p>
<p>Da notare che <code>a</code> può non essere derivato da <code>Show</code>, in questo caso l&#39;errore può essere rilevato solo a runtime.</p>
<pre><code class="lang-haskell">Prelude&gt; let x = <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">2</span> (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">4</span> EmptyTree EmptyTree) (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">5</span> EmptyTree EmptyTree)
Prelude&gt; x
<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">2</span> (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">4</span> EmptyTree EmptyTree) (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">5</span> EmptyTree EmptyTree)
Prelude&gt; :t x
x :: Num a =&gt; Tree a
</code></pre>
<p>La stampa di defualt viene quindi fatta in modo <em>prefisso</em>.</p>
<p>Da notare che in questo caso l&#39;applicazione di una di queste funzioni non è altro che la rappresentazione di se stessa, diventa quindi un&#39;interpretazione libera.</p>
<p>In questo modo si ottiene un simbolismo che permette di calcolare le funzioni per ogni possibile interpretazione.</p>
<p>Ad esempio se ho la funzione <code>3 + 4</code> grazie all&#39;interpretazione libera il calcolo della funzione ha come valore <code>3 + 4</code>, in questo modo posso usare al posto di <code>+</code> una funzione qualsiasi, ottenendo sia <code>7</code> se applico il significato classico, oppure potrei ottenere <code>12</code> se decido che nel mio programma l&#39;applicazione del <code>+</code> coincide con la moltiplicazione classica.</p>
<p><em>Nella definzione di <code>Tree</code> c&#39;è anche la derivazione da <code>Read</code> il quale permette di invocare il costruttore a partire da una stringa.</em></p>
<h2 id="record">Record</h2>
<pre><code class="lang-haskell">data Person = Person { firstName <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span>
    , lastName <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span>
    , age <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">Int</span>
    , height <span class="hljs-type-annotation">::</span> Float
    , phoneNumber <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span>
    , flavor <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span>
    } deriving (Show)

Prelude&gt; :t Person
Person
  <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">Int</span> -&gt; Float -&gt; <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">String</span> -&gt; Person

<span class="hljs-keyword">let</span> x = Person {firstName=“Gigi“, lastName=<span class="hljs-string">"Asd"</span>, age=<span class="hljs-number">12</span>, height=<span class="hljs-number">184</span>, phoneNumber=<span class="hljs-string">"123123"</span>, flavor=<span class="hljs-string">"123123"</span>}
Prelude&gt; :t x
x <span class="hljs-type-annotation">::</span> Person
Prelude&gt; firstName x
<span class="hljs-string">"Gigi"</span>
</code></pre>
<p>In questo modo posso usare delle esperssioni come <code>firstName x</code> per accedere al primo nome.</p>
<p>Altrimenti avrei dovuto utilizzare la sintassi pattern matching per accedere ai vari campi <code>(firstName _ _ ...) = x</code>.</p>
<h2 id="qualcosa-di-strano">Qualcosa di strano</h2>
<pre><code class="lang-haskell">data Maybe <span class="hljs-literal">a</span> = Nothing | Just <span class="hljs-literal">a</span>
</code></pre>
<p>Questa cosa è importante per riuscire a gestire le eccezioni in modo dichiarativo.</p>
<p>Viene usato <code>Nothing</code> per far terminare il calcolo.</p>
<p>Sarà importante per il progetto.</p>
<pre><code class="lang-haskell">Prelude&gt; :t Just <span class="hljs-string">"HAHAH"</span>
Just <span class="hljs-string">"HAHAH"</span> <span class="hljs-type-annotation">::</span> Maybe [<span class="hljs-built_in">Char</span>]
Prelude&gt; :t Just <span class="hljs-number">23</span>
Just <span class="hljs-number">23</span> <span class="hljs-type-annotation">::</span> Num a =&gt; Maybe a
Prelude&gt; :t <span class="hljs-built_in">Nothing</span>
<span class="hljs-built_in">Nothing</span> <span class="hljs-type-annotation">::</span> Maybe a
</code></pre>
<pre><code class="lang-haskell">data Either <span class="hljs-literal">a</span> b = Left <span class="hljs-literal">a</span> | Right b
Prelude&gt; let z = Left <span class="hljs-number">2</span>
<span class="hljs-label">Prelude&gt; :</span>t z
<span class="hljs-label">z ::</span> Num <span class="hljs-literal">a</span> =&gt; Either <span class="hljs-literal">a</span> b
</code></pre>
<p><code>Either</code> può contenere al suo interno due valori. In questo modo posso fare una funzione che ritorna un valore che può essere di un tipo o di un altro.</p>
<p>Il tutto in un modo sicuro rispetto ai tipi.</p>
<h2 id="typeclasses">Typeclasses</h2>
<pre><code class="lang-haskell">class Eq <span class="hljs-tag">a</span> where
    (==) :: <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">a</span> -&gt; Bool
    (/=) :: <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">a</span> -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
</code></pre>
<p>Replica della definzione della classe <code>Eq</code>, vengono fornite le definzioni delle funzioni che il tipo deve implementare per appartenere alla famiglia di <code>Eq</code>.</p>
<p>La seconda parte permette di definire una sola funzione come contrario dell&#39;altra rendendo necessaria l&#39;implementazione di solo una delle due funzioni.</p>
<pre><code class="lang-haskell">data TrafficLight = <span class="hljs-keyword">Red</span> | <span class="hljs-keyword">Yellow</span> | <span class="hljs-keyword">Green</span>

instance Eq TrafficLight where
    <span class="hljs-keyword">Red</span> == <span class="hljs-keyword">Red</span> = Ture
    <span class="hljs-keyword">Yellow</span> == <span class="hljs-keyword">Yellow</span> = Ture
    <span class="hljs-keyword">Green</span> == <span class="hljs-keyword">Green</span> = <span class="hljs-keyword">True</span>
    _ == _ = Flase
</code></pre>
<p>In questo modo il tipo <code>TrafficLight</code> appartiene ad <code>Eq</code> con la definizione della funzione <code>==</code> secondo pattern matching.</p>
<pre><code class="lang-haskell">istance <span class="hljs-operator"><span class="hljs-keyword">Show</span> TrafficLight <span class="hljs-keyword">where</span>
    <span class="hljs-keyword">show</span> Red = <span class="hljs-string">"Red Light"</span>
    <span class="hljs-keyword">show</span> Yellow = <span class="hljs-string">"Yellow Light"</span>
    <span class="hljs-keyword">show</span> Green = <span class="hljs-string">"Green Light"</span></span>
</code></pre>
<p>In questo modo vado a definire come mostrare i vari tipi dentro una classe di tipi.</p>
<pre><code class="lang-haskell">class YesNo a where
    yesno<span class="hljs-keyword"> :</span>: a -&gt; Bool

-- spefico che anche il tipo lista di qualcuno tipo appartiene alla classe YesNo<span class="hljs-instruction">
instance </span>YesNo <span class="hljs-keyword">[</span>a] where
    yesno <span class="hljs-keyword">[</span>] = false
    yesno _ = true
</code></pre>
<h2 id="-spalmare-funzioni-">&quot;Spalmare funzioni&quot;</h2>
<pre><code class="lang-haskell"><span class="hljs-label">Prelude</span>&gt; :t <span class="hljs-preprocessor">map</span>
<span class="hljs-label">map</span> :: (a -&gt; <span class="hljs-keyword">b) </span>-&gt; [a] -&gt; [<span class="hljs-keyword">b]
</span><span class="hljs-label">Prelude</span>&gt; <span class="hljs-preprocessor">map</span> (++ <span class="hljs-string">"!"</span>)[<span class="hljs-string">"hey"</span>, <span class="hljs-string">"ho"</span>] 
[<span class="hljs-string">"hey!"</span>,<span class="hljs-string">"ho!"</span>]
</code></pre>
<p><code>map</code> permette di applicare una funzione a tutti gli elementi di una lista.</p>
<pre><code class="lang-haskell">Prelude&gt; :t <span class="hljs-built_in">filter</span>
<span class="hljs-built_in">filter</span> :: (<span class="hljs-operator">a</span> -&gt; Bool) -&gt; [<span class="hljs-operator">a</span>] -&gt; [<span class="hljs-operator">a</span>]
</code></pre>
<p><code>filter</code> permette di filtare i dati su una lista</p>
<pre><code class="lang-haskell">Prelude&gt; :t foldl
foldl :: Foldable t =&gt; (<span class="hljs-tag">b</span> -&gt; <span class="hljs-tag">a</span> -&gt; b) -&gt; <span class="hljs-tag">b</span> -&gt; t <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">b</span>
Prelude&gt; let sum xs = foldl (+) <span class="hljs-number">0</span> xs
Prelude&gt; sum [<span class="hljs-number">1</span>..<span class="hljs-number">5</span>]
<span class="hljs-number">15</span>
</code></pre>
<p><code>foldl</code> permette di trasformare una lista in un valore unico.</p>
<p>Esiste anche <code>foldr</code> che esamina la lista a partire da destra.</p>
<h2 id="inserimento-in-un-albero">Inserimento in un albero</h2>
<pre><code class="lang-haskell">data Tree a = EmptyTree | <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">a</span> (Tree a) (Tree a) deriving (<span class="hljs-operator">Eq</span>, Show, <span class="hljs-operator">Read</span>)

singleton :: a -&gt; Tree a
singleton x = <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">x</span> EmptyTree EmptyTree

treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a
treeInsert x EmptyTree = singleton x
treeInsert x (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">a</span> left right)
    | x == a = <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">x</span> left right --non inserisco se uguale
    | x <span class="hljs-tag">&lt; a  = Node a (treeInsert x left) right
    | x &gt;</span> a  = <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">a</span> left (treeInsert x right)
</code></pre>
<p>In questo modo ho definito sia un albero, sia una funzione che mi permette di creare un albero binario di ricerca con valori tutti diversi.</p>
<pre><code class="lang-haskell">*Main&gt; let nums = [<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]
*Main&gt; let numsTree = foldr treeInsert EmptyTree nums
*Main&gt; numsTree
<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">5</span> (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">3</span> (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">1</span> EmptyTree EmptyTree) (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">4</span> EmptyTree EmptyTree)) (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">7</span> (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">6</span> EmptyTree EmptyTree) (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">8</span> EmptyTree EmptyTree))
</code></pre>
<h2 id="funtori">Funtori</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f <span class="hljs-keyword">where</span></span>
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>Per essere un funtore il tipo <code>f</code> (<code>f</code> è un tipo parametrico) deve avere una funzione <code>fmap</code> che data una funzione e un oggetto che contiene un valore sul quale può essere applicata quella funzione, ritorna un&#39;altro oggetto contenente il risultato dell&#39;applicazione della funzione.</p>
<p>L&#39;idea è che un funtore è una generalizzazione della funzione <code>map</code>.</p>
<p>Esempio: <code>f</code> = costruttore <code>[]</code> dove <code>[] :: a -&gt; [a]</code></p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Functor</span> [] <span class="hljs-keyword">where</span></span>
    fmap = map
</code></pre>
<pre><code class="lang-haskell">*<span class="hljs-constant">Main&gt;</span> <span class="hljs-symbol">:t</span> fmap
fmap <span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> <span class="hljs-constant">Functor </span>f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
*<span class="hljs-constant">Main&gt;</span> <span class="hljs-symbol">:t</span> map
map <span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> (a -&gt; b) -&gt; [a] -&gt; [b]
*<span class="hljs-constant">Main&gt;</span> <span class="hljs-symbol">:t</span> []
[] <span class="hljs-symbol">:</span><span class="hljs-symbol">:</span> [t]
</code></pre>
<p>Ovunque ci sia un &quot;involucro&quot; che contiene dei valori deve essere possibile &quot;spalmare&quot; su quei valori una funzione.</p>
<h3 id="funtori-su-maybe">Funtori su Maybe</h3>
<pre><code class="lang-haskell">instance Functor Maybe where
    fmap f <span class="hljs-list">(<span class="hljs-keyword">Just</span> x)</span> = Just <span class="hljs-list">(<span class="hljs-keyword">f</span> x)</span>
    fmap f Nothing = Nothing
</code></pre>
<p>Quando mi trovo un <code>Just x</code> devo solo applicare <code>f</code> ad <code>x</code>.</p>
<p>Se non ho niente (<code>Nothing</code>) non faccio niente. Utile in quanto se <code>Nothing</code> rappresenta un&#39;errore, questo risulta invariato.</p>
<h3 id="funtori-su-un-tree">Funtori su un Tree</h3>
<pre><code class="lang-haskell">instance Functor Tree where
    fmap f EmptyTree = EmptyTree
    fmap f (<span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">x</span> leftsub rightsub) = <span class="hljs-keyword">Node</span><span class="hljs-identifier"> </span><span class="hljs-title">(f</span> x) (fmap f leftsub) (fmap f rightsub)
</code></pre>
<p>In questo modo riusciamo a spalmare l&#39;esecuzione di una funzione su un albero.</p>
<p>Se l&#39;albero è vuoto non faccio nulla.</p>
<p>Se l&#39;albero ha un nodo, prima applico la funzione al nodo e poi la passo ai vari sotto alberi.</p>
<h3 id="funtori-su-either">Funtori su Either</h3>
<pre><code class="lang-haskell">instance Functor <span class="hljs-list">(<span class="hljs-keyword">Either</span> a)</span> where
    fmap f <span class="hljs-list">(<span class="hljs-keyword">Right</span> x)</span> = Right <span class="hljs-list">(<span class="hljs-keyword">f</span> x)</span>
    fmap f <span class="hljs-list">(<span class="hljs-keyword">Left</span> x)</span> = Left x
</code></pre>
<p>In questo caso <code>f</code> viene spalmata solo su uno dei due tipi.</p>
<h2 id="input-output">Input/output</h2>
<p><strong>L&#39;input è impuro, ma tranquilli che non ci sono roghi.</strong></p>
<pre><code class="lang-haskell">main = <span class="hljs-operator"><span class="hljs-keyword">do</span>
    putStrLn <span class="hljs-string">"Hello world"</span>
    <span class="hljs-keyword">name</span> &lt;- getLine <span class="hljs-comment">-- questa è un'assegnazione ad una costante</span>
    putStrLn <span class="hljs-keyword">name</span></span>
</code></pre>
<p>Da notare i tipi</p>
<pre><code class="lang-haskell">*Main&gt; :t putStrLn 
putStrLn <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">IO</span> ()
*Main&gt; :t getLine
getLine <span class="hljs-type-annotation">::</span> <span class="hljs-built_in">IO</span> <span class="hljs-built_in">String</span>
</code></pre>
<h1 id="lezione-5-ancora-haskell">Lezione 5 - Ancora Haskell</h1>
<h2 id="ancora-funtori">Ancora funtori</h2>
<p>La classe funtore prende una funzione di <code>a -&gt; b</code> e un parametro di tipo parametrico <code>f</code> instanstanziato ad un tipo <code>a</code> e ritorna un tipo <code>f</code> instanziato ad un tipo <code>b</code>.</p>
<h2 id="io">IO</h2>
<p>L&#39;input/output si deve essere sempre dentro il <code>main</code>.</p>
<pre><code class="lang-haskell">main = <span class="hljs-operator"><span class="hljs-keyword">do</span>
    putStrln <span class="hljs-string">"Hello world"</span>
    <span class="hljs-keyword">name</span> &lt;- getLine
    putStrLn <span class="hljs-keyword">name</span></span>
</code></pre>
<pre><code class="lang-haskell">main = <span class="hljs-operator"><span class="hljs-keyword">do</span>
    <span class="hljs-keyword">c</span> &lt;- getChar
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">c</span> /= <span class="hljs-string">''</span>
        <span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span>
            putChar <span class="hljs-keyword">c</span>
            <span class="hljs-keyword">main</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ()

Prelude&gt; :<span class="hljs-keyword">t</span> <span class="hljs-keyword">return</span>
<span class="hljs-keyword">return</span> :: (Functor <span class="hljs-keyword">m</span>) =&gt; a -&gt; <span class="hljs-keyword">m</span> a</span>
</code></pre>
<p><code>m</code> non è un vero e proprio funtore ma lo si può considerare tale. La funzione ritorna quindi un funtore istanziato al tipo <code>a</code>.</p>
<p><code>IO</code> è un type constructor e un&#39;instaza di <code>Functor</code>.</p>
<pre><code class="lang-haskell">instance <span class="hljs-type">Functor</span> <span class="hljs-type">IO</span> where
    fmap f action = <span class="hljs-keyword">do</span>
        <span class="hljs-literal">result</span> &lt;- action
        <span class="hljs-keyword">return</span> (f <span class="hljs-literal">result</span>)
</code></pre>
<p>Quindi si può fare qualcosa del genere:</p>
<pre><code class="lang-haskell">main = <span class="hljs-keyword">do</span> 
    <span class="hljs-built_in">line</span> &lt;- fmap <span class="hljs-built_in">reverse</span> getLine
     putStrLn $ <span class="hljs-string">"You said "</span> ++ <span class="hljs-built_in">line</span> ++ <span class="hljs-string">" backwards!"</span>
</code></pre>
<h2 id="compilazione-di-un-programma">Compilazione di un programma</h2>
<pre><code>$ ghc --<span class="hljs-built_in">make</span> prova     <span class="hljs-comment">//Compila</span>
$ ./prova             <span class="hljs-comment">//Esegue</span>
</code></pre><h1 id="progetto">Progetto</h1>
<ol>
<li>Programma sorgente scritto nel nostro linguaggio LispKit</li>
<li>Sequenza di token</li>
<li>Codice intermedio: albero sintattico</li>
<li>Codice per una macchina virtuale</li>
</ol>
<p>La prima parte del progetto si tratta di codificare un programma haskell che sia in grado ti effettuare l&#39;analisi lessicare di un programma scritto il LispKit.</p>
<p>LispKit è il linguaggio di programmazione che verrà utilizzato per tutto il progetto. È funzionale ed ammette funzioni ricorsive.</p>
<p>Bisogna effettuare delle modifiche al linguaggio in modo che la grammatica sia LL-1.</p>
<h2 id="parte-1-analizzatore-lessicale">Parte 1 - Analizzatore lessicale</h2>
<p>L&#39;analisi lessicale viene fatta da un automa a stati finiti.</p>
<p>L&#39;analizzatore deve produrre una lista di <code>Token</code>.</p>
<h1 id="lezione-6-inferenza-dei-tipi">Lezione 6 - Inferenza dei tipi</h1>
<p>In Haskell non è necessario andare a specificare i tipi, si occupa il compilatore di fare <em>inferenza</em> di tipo.</p>
<h2 id="inferenza-di-tipo">Inferenza di tipo</h2>
<pre><code class="lang-haskell"><span class="hljs-keyword">let</span> f x = <span class="hljs-number">2</span> + x
f <span class="hljs-tag">:: Num</span> <span class="hljs-subst">-&gt; </span>Num
</code></pre>
<p>In questo caso il compilatore inferisce che <code>x</code> è di tipo <code>Num</code> in quanto <code>2</code> è una costante di tipo <code>Num</code>.</p>
<p>Il compilatore trasforma <code>fun f x = 2 + x</code> in <code>*lamba*x.((+2)x)</code> e crea una specie di albero.</p>
<p>Vengono poi valutati i tipi delle foglie, che in questo caso sono <code>Num -&gt; Num -&gt; Num</code> per l&#39;operatore <code>+</code> e <code>Num</code> per la costante <code>2</code>.</p>
<p>L&#39;albero è composto da due tipi di nodi: <code>lambda</code> o vincoli per astrazione e <code>@</code> per i vincoli applicazione.</p>
<p><strong>Vincolo per astrazione</strong>: <code>(lambda x.y)</code> se <code>x</code> è di tipo <code>a</code> e <code>y</code> è di tipo <code>b</code>, allora il tipo è <code>a -&gt; b</code>.</p>
<p><strong>Vincolo per applicazione</strong>: se <code>f</code> ha tipo <code>a</code>, il suo argomento <code>e</code> ha tipo <code>b</code> e <code>(f e)</code> ha tipo <code>c</code> allora: <code>a = b -&gt; c</code>.</p>
<p>Il nodo <code>lambda</code> è associato alla funzione anonima e genera un vincolo <code>r = u -&gt; s</code>, con <code>u</code> che è una variabile di tipo per <code>x</code> e <code>s</code> è il tipo del valore di ritorno.</p>
<p>Quando viene valutato il nodo <code>@</code> per <code>+</code> e <code>2</code> il compilatore genera il vincolo <code>Num -&gt; Num -&gt; Num = Num -&gt; t</code>. Perché il vincolo sia soddisfatto <code>t</code> deve essere uguale a <code>Num -&gt; Num</code></p>
<p>Per l&#39;altro nodo <code>@</code> tra <code>+2</code> e <code>x</code> viene generator il vincolo <code>t = u -&gt; s</code>.</p>
<p>Infine, sapendo che <code>t = Num -&gt; Num</code> allora <code>t = u -&gt; s ==&gt; u = Num, s = Num</code>.</p>
<p>Possono verificarsi delle situazioni <em>circolari</em> in cui non si riesce ad inferire in modo automatico i tipo. Questo perché una variabile di tipo può dipendere da un&#39;altra variabile di tipo che a sua volta dipende dalla prima.</p>
<p><img src="./notes/immagini/L09-inferenza.png" alt="alt text" title="Logo Title Text 1"></p>
<p><em>La profondità dell&#39;albero viene influenzata dal fatto che le funzioni sono currificate</em>.</p>
<h3 id="creazione-dell-albero">Creazione dell&#39;albero</h3>
<p>L&#39;albero dell&#39;inferenza è creato da due tipi di nodi, i nodi lambda che hanno come simbolo <code>\</code> e i nodi applicazione che hanno come simbolo <code>@</code>.</p>
<h4 id="nodi-lambda">Nodi lambda</h4>
<p>Quando si sta analizzando la definizione di una funzione viene creato un nodo <code>\</code>.
Questo nodo sempre come figlio sinistro un parametro della funzione preso in sequenza, cioè il primo nodo <code>\</code> ha il primo parametro, il secondo nodo <code>\</code> ha il secondo parametro e così via.</p>
<p>Il figlio destro di un nodo <code>\</code> può essere o un&#39;altro nodo <code>\</code> nel caso la funzione abbia più di un parametro, oppure un nodo <code>@</code>.</p>
<p>Un nodo di questo tipo da origine ad un vincolo del tipo:</p>
<pre><code><span class="hljs-type">TipoNodoRadice</span> = <span class="hljs-type">TipoNodoFiglioSinistro</span> -&gt; <span class="hljs-type">TipoFiglioNodoDestro</span>

ad esempio, facendo riferimento all'esempio di prima

r = t -&gt; w
</code></pre><h4 id="nodi-applicazione">Nodi applicazione</h4>
<p>Questi nodi vengono creati quando si valuta l&#39;applicazione di una funzione.</p>
<p>Al contrario dei nodi lambda, in questo caso se la funzione ha più parametri, si espande l&#39;albero a sinistra, questo deriva dal fatto che in Haskell tutte le funzioni sono currificate.</p>
<p>Il figlio sinistro di un nodo applicazione può essere o un&#39;altro nodo applicazione, nel caso la funzione abbia più parametri, oppure una funzione.</p>
<p>Sempre nell&#39;esempio sopra, il nodo <code>@</code> rappresenta l&#39;applicazione di <code>f x</code>, e da quel nodo si deriva il vincolo <code>t = u -&gt; s</code>.</p>
<p>Che generalizzato diventa:</p>
<pre><code><span class="hljs-constant">TipoNodoFiglioSinistro </span>= <span class="hljs-constant">TipoNodoFiglioDestro </span>-&gt; <span class="hljs-constant">TipoNodoPadre</span>
</code></pre><p>Nel caso la funzione richiede l&#39;invocazione di una funzione utilizzi più parametri, come già detto, si espande a sinistra.</p>
<p>Ad esempio l&#39;albero per l&#39;applicazione della funzione <code>f a b</code> porta al seguente albero.</p>
<pre><code>                  <span class="hljs-comment">(@)</span>
                /     \
            <span class="hljs-comment">(@)</span>       b
          /        \
       f       a
</code></pre><p>Cioè il figlio destro rappresenta l&#39;ultimo dei parametri dell&#39;applicazione, mentre il figlio sinistro è un&#39;altro nodo applicazione.</p>
<p>Complicando ancora le cose, l&#39;applicazione della funzione <code>f a (g b)</code> diventa abbastanza divertente, inquanto entrambi i figli del primo nodo sono entrambi nodi applicazione.</p>
<pre><code>                  <span class="hljs-comment">(@)</span>
                /     \
            <span class="hljs-comment">(@)</span>          <span class="hljs-comment">(@)</span>
          /        \      /   \
        f         a  g         b
</code></pre><p>Questo perché l&#39;ultimo parametro è il risultato dell&#39;applicazione della funzione <code>g</code> sul valore <code>b</code></p>
<h2 id="inferenza-di-tipo-per-funzioni-ricorsive">Inferenza di tipo per funzioni ricorsive</h2>
<p>In questo caso si aggiunge il vincolo che il tipo della funzione deve essere uguale a quello presente come nodo dell&#39;albero.</p>
<p>In modo simile per le funzioni con definizioni multiple deve avere il vincolo il tipo di tutte le funzioni coincida.</p>
<h1 id="lezione-7-unificazione">Lezione 7 - Unificazione</h1>
<p>Il significato della <code>-&gt;</code> in haskell:</p>
<pre><code>tipo di una funzione f: <span class="hljs-tag">a</span> -&gt; <span class="hljs-tag">b</span> -&gt; c

            (-&gt;)
           /    \
         <span class="hljs-tag">a</span>      (-&gt;)
               /    \
              <span class="hljs-tag">b</span>      c

Rappresentato come stringa: 
-&gt;(<span class="hljs-tag">a</span>, -&gt;(<span class="hljs-tag">b</span>,c))
</code></pre><p>Questo perché, essendo currificate, <code>f</code> è una funzione che dato un parametro <code>a</code> ritorna una funzione di tipo <code>b -&gt; c</code>.</p>
<p>Se c&#39;è un tipo funzione in mezzo, la cosa è la stessa:</p>
<pre><code>tipo di una funzione <span class="hljs-attribute">f</span>: a<span class="hljs-function"> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(b -&gt; c)</span> -&gt;</span> d

            (<span class="hljs-function">-&gt;</span>)
           /    <span class="hljs-string">\</span>
         a      (<span class="hljs-function">-&gt;</span>)
               /     <span class="hljs-string">\</span>
             (<span class="hljs-function">-&gt;</span>)     d
            /    <span class="hljs-string">\</span>
           b      c

Rappresentato come <span class="hljs-attribute">stringa</span>:<span class="hljs-function">
-&gt;</span>(a,<span class="hljs-function"> -&gt;</span>((b-&gt;c), d)
</code></pre><p>Gli alberi di questo tipo possono essere confrontati a partire dalla radice e matchando le varie frecce, in questo modo è possibile definire delle equazioni tra i tipi delle foglie.</p>
<pre><code>Alb1
            (<span class="hljs-function">-&gt;</span>)
           /    <span class="hljs-string">\</span>
         a      (<span class="hljs-function">-&gt;</span>)
               /     <span class="hljs-string">\</span>
             (<span class="hljs-function">-&gt;</span>)     a
            /    <span class="hljs-string">\</span>
           c     [a]
Alb2
            (<span class="hljs-function">-&gt;</span>)
           /    <span class="hljs-string">\</span>
         d      (<span class="hljs-function">-&gt;</span>)
               /     <span class="hljs-string">\</span>
              e       f

Alb2 = <span class="hljs-attribute">Alb1</span>:
- d = a
- <span class="hljs-function"><span class="hljs-title">e</span> = -&gt;</span>(c,[a])
- f = a
</code></pre><p>In questo caso è preferibile utilizzare <code>/</code> come notazione al posto dell&#39;<code>=</code>. Questo perché l&#39;operazione che si fa è una sostituzione piuttosto che un&#39;uguaglianza.</p>
<p>Nell&#39;esempio di prima si ha:</p>
<pre><code><span class="hljs-literal">a</span>/d
<span class="hljs-literal">a</span>/f
e/-&gt;(c,[<span class="hljs-literal">a</span>])
</code></pre><p>In questo caso è necessario propagare il valore di <code>a</code>:</p>
<pre><code>a/<span class="hljs-literal">f</span>
<span class="hljs-keyword">d</span>/<span class="hljs-literal">f</span>
<span class="hljs-keyword">e</span>/-&gt;(c,[f])

può essere espresso anche come (insieme <span class="hljs-keyword">di</span> binding):
{a/f, <span class="hljs-keyword">e</span>/-&gt;(c,[f]), <span class="hljs-keyword">d</span>/f}
</code></pre><p>In questo caso non cambia nulla, ma è sempre preferibile tenere sempre lo stesso valore a destra, cioè <code>f</code>.</p>
<p>Una volta trovato un <em>binding</em> si devono fare le sostituzioni nei due alberi, se dopo le sostituzioni i due alberi sono uguali, allora ho trovato una soluzione.</p>
<p>Nelle espressioni di binding, alla sinistra devono comparire solo variabili distinte che non compaiono mai a destra.</p>
<p>Per indicare che si applica una sostituzione ad un albero si usa la notazione <code>T σ</code>.</p>
<p>L&#39;applicazione di una sostituzione è idempotente:</p>
<pre><code>(<span class="hljs-literal">T</span> σ) σ = <span class="hljs-literal">T</span> σ
</code></pre><p>Tipicamente nella notazione non viene utilizzata la <code>-&gt;</code>, di solito si associa un&#39;arietà ad ogni simbolo.</p>
<pre><code>{f/<span class="hljs-number">3</span>, f/<span class="hljs-number">4</span>, g/<span class="hljs-number">2</span>, <span class="hljs-literal">a</span>/<span class="hljs-number">0</span>} + eventuali variabili

                f/<span class="hljs-number">4</span>
           /    /  \   \
        /      /    \     \
       f/<span class="hljs-number">3</span>    g/<span class="hljs-number">2</span>    <span class="hljs-literal">a</span>     <span class="hljs-literal">a</span>
    /   | \    / \ 
    <span class="hljs-literal">a</span>   g  <span class="hljs-literal">a</span>  <span class="hljs-literal">a</span>  <span class="hljs-literal">a</span>
       / \
      <span class="hljs-literal">a</span>   <span class="hljs-literal">a</span>
</code></pre><p>Se un termine non ha variabili si dice <em>ground</em>.</p>
<h2 id="composizione-di-sostituzioni">Composizione di sostituzioni</h2>
<blockquote>
<p>σ<sub>1</sub> = {x<sub>1</sub>/t<sub>1</sub>, ..., x<sub>n</sub>/t<sub>n</sub>}
σ<sub>2</sub> = {y<sub>1</sub>/s<sub>1</sub>, ..., y<sub>n</sub>/s<sub>n</sub>}</p>
</blockquote>
<p>La composizione di queste due soluzioni è data da </p>
<blockquote>
<p>σ<sub>1</sub> 𝜸 σ<sub>2</sub> = {x<sub>1</sub>/(t<sub>1</sub> σ<sub>2</sub>), ..., x<sub>n</sub>/(t<sub>n</sub> σ<sub>2</sub>)} ∪ {y<sub>j</sub>/s<sub>j</sub> | y<sub>j</sub> non è in {x<sub>1</sub> ... x<sub>n</sub>}}.</p>
</blockquote>
<p>Anche se l&#39;applicazione di una sostituzione è idempotente, la composizione non lo è.</p>
<h2 id="preordine-delle-sostituzioni">Preordine delle sostituzioni</h2>
<p>Si dice che σ<sub>1</sub> &gt;= σ<sub>2</sub> se esiste σ<sub>3</sub> tale che σ<sub>1</sub>𝜸σ<sub>3</sub> = σ<sub>2</sub>.</p>
<p>Questo vuol dire che per ottenere lo stesso effetto di σ<sub>2</sub> devo comporre σ<sub>1</sub> con un&#39;altra sostituzione σ<sub>3</sub>.</p>
<p>Questo vuol dire che σ<sub>1</sub> è <strong>più generale</strong> di σ<sub>2</sub>, allo stesso modo, σ<sub>2</sub> è <strong>più istanziata</strong> di σ<sub>1</sub></p>
<p>Ad esempio:</p>
<blockquote>
<p>σ<sub>1</sub> = {x/y}
σ<sub>2</sub> = {x/[Int]}</p>
<p>allora</p>
<p>σ<sub>1</sub> &gt;= σ<sub>2</sub></p>
<p>e</p>
<p>σ<sub>3</sub> = {y/[Int]}</p>
<p>σ<sub>1</sub> 𝜸 σ<sub>3</sub> = σ<sub>2</sub></p>
<p>(anche se Filè dice che non è del tutto vero)</p>
</blockquote>
<p>Se σ<sub>1</sub> 𝜸 σ<sub>2</sub> = σ<sub>2</sub> e σ<sub>2</sub> 𝜸 σ<sub>1</sub> = σ<sub>1</sub> allora si dice che le due sostituzioni sono <strong>equivalenti</strong>.</p>
<p>Una sostituzione è <strong>ground</strong> se non ha variabili nelle parti destre dei binding.</p>
<h2 id="sistema-di-equazioni">Sistema di equazioni</h2>
<p>Dato un sistema di equazioni <code>E</code>, si indica con <code>Gsol(E) o Grosol(E)</code> l&#39;insieme delle sostituzioni che sono soluzioni ground di E.</p>
<p>Se <code>Gsol(E)</code> non è vuoto allora <code>E</code> è <strong>risolvibile</strong>, mentre se <code>Gsol(E) == Gsol(E&#39;)</code> allora si dice che <code>E</code> è <strong>equivalente</strong> ad <code>E&#39;</code>.</p>
<p><strong>Sistema di equazioni in forma risolta</strong>: <code>E = {x = f(y), z = f(g(y))}</code>, questo sistema è idempotente e le parti sinistre delle equazioni sono solo variabili.
σ<sub>E</sub> = {x/f(y), z/f(g(y))} è una soluzione di <code>E</code>, quindi <code>E</code> è una rappresentazione compatta di tutte le sue soluzioni, comprese quelle ground.
Se σ è una soluzione di ground di <code>E</code> allora σ &lt;= σ<sub>E</sub>, cioè esiste una soluzione σ&#39; tale che σ = σ<sub>E</sub> 𝜸 σ.
Questo vuol dire che σ<sub>E</sub> è la soluzione più generale di tutte e di conseguenza espire tutto <code>Grosol(E)</code>.</p>
<h2 id="unificazione">Unificazione</h2>
<p>Si parte da due insiemi di equazioni e si cerca di andare a fare delle sostituzioni, in modo da arrivare ad un unico insieme di equazioni in forma risolta, facendo in modo che il numero di soluzioni ground non cambi.</p>
<ol>
<li>f(t<sub>1</sub>,...,t<sub>n</sub>) = f(s<sub>1</sub>, ... , s<sub>n</sub>) --&gt; {t<sub>1</sub> = s<sub>1</sub>, ... , t<sub>n</sub> = s<sub>n</sub>} : <em>pealing</em>: si passa da due termini con arietà <em>n</em> e si costruiscono <em>n</em> nuove equazioni per i tipi figli.</li>
<li>f(t<sub>1</sub>, ..., t<sub>n</sub>) = g(s<sub>1</sub>, ..., s<sub>k</sub>) --&gt; stop con fallimento, perché ci sono dei termini che devono essere ground (???).</li>
<li><code>x = x</code> --&gt; vengono eliminate tutte le equazioni di questo tipo.</li>
<li><code>t = x</code> con <code>t</code> non variabile viene trasformato in <code>x = t</code>. Trasformo le varie equazioni in modo che siano già in forma risolta.</li>
<li>Per tutte le equazioni del tipo <code>x = t</code>, con <code>t</code> diverso da <code>x</code> e <code>x</code> ha altre occorrenze in <code>E</code>, allora se <code>x</code> compare in <code>t</code> ho un fallimento (ovvero esiste un&#39;equazione <code>x = t(x)</code>, questo tipo di equazione non può essere trattato), altrimenti sostituisco ogni occorrenza di <code>x</code> in <code>t</code> (Faccio la propagazione delle equazioni risolte).</li>
</ol>
<h3 id="esempio">Esempio</h3>
<pre><code>{<span class="hljs-keyword">g</span>(x)=<span class="hljs-keyword">g</span>(<span class="hljs-keyword">g</span>(z)), <span class="hljs-literal">f</span>(a,z)=<span class="hljs-literal">f</span>(a,y)}

    <span class="hljs-keyword">g</span>   =   <span class="hljs-keyword">g</span> 
    |       |
    x       <span class="hljs-keyword">g</span>
            |
            z
        <span class="hljs-literal">e</span>

    f   =   <span class="hljs-literal">f</span>
   / \     / \
  a   z   a   <span class="hljs-literal">y</span>

passo alla notazione lineare

{ 
    x = <span class="hljs-keyword">g</span>(z),
    a = a, <span class="hljs-comment">//Può essere scartata (passo 3 dell'algoritmo)</span>
    z = <span class="hljs-literal">y</span>
}

applico il passo 5 dell'algoritmo

{
    x = <span class="hljs-keyword">g</span>(y) <span class="hljs-comment">//Sostituisco z con y</span>
    z = <span class="hljs-literal">y</span>
}

posso riespandere <span class="hljs-keyword">la</span> notazione per ottenere i due alberi

    <span class="hljs-keyword">g</span>   =   <span class="hljs-keyword">g</span> 
    |       |
    <span class="hljs-keyword">g</span>       <span class="hljs-keyword">g</span>
    |       |
    y       <span class="hljs-literal">y</span>

        <span class="hljs-literal">e</span>

    f   =   <span class="hljs-literal">f</span>
   / \     / \
  a   y   a   <span class="hljs-literal">y</span>
</code></pre><h3 id="correttezza-dell-algoritmo">Correttezza dell&#39;algoritmo</h3>
<ol>
<li>Dato un insieme di equazioni <code>E</code>, l&#39;algoritmo termina sempre, perché ad ogni iterazione diminuisce il numero di equazioni.</li>
<li>Se termina senza fallire viene prodotto un nuovo insieme <code>E&#39;</code>, in forma risolta e risolvibile, con <code>Grosol(E) = Grosol(E&#39;)</code></li>
<li>Se l&#39;algoritmo fallisce allora <code>E</code> non è risolvibile.</li>
</ol>
<p>Dimostrazione:</p>
<ol>
<li>Ogni trasformazione (1), (3) e (4) diminusice strettamente il numero di simboli nelle parti sinistre delle equazioni, quindi dopo un numero finito di applicazione di questi passi, o si termina o si applica il passo (5). Quindi il passo (5) può fallire oppure elimina tutte le occorrenze di una variabile, meno una (ne viene lasciata una sola). Di conseguenza, il passo (5) si può applicare solo una volta per ogni variabile, da cui segue che il passo (5) può essere applicato al massimo tante volte quante sono le variabili distinte in <code>E</code>.</li>
<li>Per ogni passo E<sub>1</sub> --&gt; E<sub>2</sub> che ha successo vale che hanno le stesse soluzioni.<ul>
<li>(1): <code>f(u) = f(v) --&gt; u = v</code>, questo perché una soluzione ground per la prima equazione porrebbe le variabili <code>u</code> e <code>v</code> ad uno stesso tipo, soddisfacendo anche la seconda equazione. Se le due equazioni sono più complesse, si applica lo stesso ragiornamento, ricorsivamente tra i vari sotto-termini.</li>
<li>(3): <code>t = x</code> --&gt; <code>x = t</code>, questo perché è un&#39;equazione.</li>
<li>(5): se viene applicato con successo con <code>x = t</code>, per ogni soluzione σ di E<sub>1</sub> deve essere che <code>(x) σ = (t) σ</code>, quindi dovunque in E<sub>1</sub> si trova <code>x</code>, questa può essere sostituita con <code>t</code>, mantenendo comunque la soluzione σ. (Manca la dimostrazione del fallimento, sarà nella prossima lezione).</li>
</ul>
</li>
</ol>
<h1 id="lezione-8-unificazione-2-e-analisi-sintattica">Lezione 8 - Unificazione 2 e Analisi Sintattica</h1>
<h2 id="unificazione-cont-d-">Unificazione (cont&#39;d)</h2>
<p><em>Dimostrazione della correttezza dell&#39;algoritmo di unione</em></p>
<h3 id="dimostrazione-del-punto-2-">Dimostrazione del punto (2)</h3>
<p>Per ogni passo E<sub>1</sub> -&gt; E<sub>2</sub> che ha successo vale che i due insiemi hanno le stesse soluzioni ground.</p>
<p><strong>Passo (1)</strong>: f(u<sub>1</sub>,..., u<sub>n</sub>) = f(v<sub>1</sub>,..., v<sub>n</sub>) --&gt; u<sub>1</sub> = v<sub>1</sub> ... u<sub>n</sub> = v<sub>n</sub></p>
<p>Prendendo una soluzione σ e applicandola u<sub>1</sub> σ, questo deve essere uguale a v<sub>1</sub> σ, il che applicato a tutte le varie equazioni le rende trivialmente verificiate.</p>
<p><strong>Passo (3)</strong>: <code>t = x</code> --&gt; <code>x = t</code>, questo perché è un&#39;equazione.</p>
<p><strong>Passo (5)</strong>: applicazione delle uguaglianze <code>x = t</code>.</p>
<p>Se l&#39;applicazione ha successo, per ogni soluzione σ di E<sub>1</sub> deve essere che <code>x σ = t σ</code> quindi per ogni equazione in E<sub>1</sub> contentente <code>x</code> possiamo sostiturla con <code>t</code> mantenendo la soluzione σ.
Bisogna comunque dimostrare che le soluzioni ground rimangono, ma se applico σ al risultato, se una soluzione è ground per il risultato, questa deve essere una soluzione valida anche per il sistema di equazioni originario.</p>
<p>Alla fine del processo, se non c&#39;è un fallimento, si raggiunge E<sub>2</sub> che è in forma risolta, questo perché se non fosse vero potrei applicare delle altre regole e quindi non avrei terminato.</p>
<p><strong>Forma risolta</strong>: sistema composto da equazioni che nella parte sinistra hanno solo una variabile. Quando un sistema è espresso in questa forma diventa una rappresentazione compatta di tutte le sue possibili soluzioni.</p>
<p><em>dimostrazione in qualche modo di quello che c&#39;è scritto sopra</em></p>
<p>{x<sub>1</sub>, ..., x<sub>n</sub>} sono tutte distinte e {x<sub>1</sub>,..,x<sub>n</sub>} ∩ l&#39;unione di Var(t<sub>i</sub>) = ∅:</p>
<ol>
<li>parte a destra non variabile --&gt; non può essere, potrei applicare il passo 1 e quindi non ho terminato</li>
<li>le x<sub>i</sub> non sono tutte diverse --&gt; ci sono due x<sub>i</sub> uguali, posso ancora applicare il passo (5) quindi non ho terminato</li>
<li>una x<sub>i</sub> compare in qualche t<sub>j</sub> (compare a destra di una equazione) --&gt; posso ancora applicare (5). </li>
</ol>
<p>Se va tutto bene, l&#39;algoritmo termina e il sistema di equazioni è già in forma risolta e consiste anche in una possibile soluzione generale per il sistema di equazioni di partenza.</p>
<h3 id="dimostrazione-dei-casi-di-fallimento-dell-algoritmo">Dimostrazione dei casi di fallimento dell&#39;algoritmo</h3>
<p><strong>Fallimento dovuto al caso (2)</strong>: è ovvio che non ci sono soluzioni per <code>f(...) = g(...)</code> non ci sono neanche soluzione per il sistema.</p>
<p><strong>Fallimento dovuto al caso (5)</strong>: E<sub>1</sub> contiene <code>x = t</code> con <code>t</code> non vuoto e che contiene <code>x</code>, questa equazione quindi non ha soluzione, pertanto anche E<sub>1</sub> non ha soluzione.</p>
<h3 id="considerazioni-finali">Considerazioni finali</h3>
<p>In caso di successo E&#39; è in forma risolta e quindi lo possiamo vedere come una soluzione σ<sub>E&#39;</sub> e funziona sia come soluzione di E&#39; (banalmente perché è in forma risolta e istanziando ulteriormente σ<sub>E&#39;</sub> otteniamo tutte le soluzioni ground di E&#39;) sia come soluzione di E, perché tutte le soluzioni ground di E&#39; sono anche soluzioni di E (per costruzione di E&#39;).</p>
<p>Inoltre, σ<sub>E&#39;</sub> è una soluzione più generale di E, perché per ogni altra soluzione σ di E, σ<sub>E&#39;</sub> &gt;= σ. (<strong>most general unifier</strong>) </p>
<p>Possono esistere diversi unificatori più generali, ma sono sempre un numero finito e sono tutti &quot;quasi uguali&quot;.</p>
<p>Ad esempio { w/f(v), x/u, y/u, z/v } e { w/f(z), x/y, u/y, v/z} sono equivalenti.</p>
<p>Infatti in entrambe {x=u=y} e {z=v} ma sono sostituzioni che rappresentano questo in modo diferso.</p>
<p>Sono quindi delle variabili di tipo che restano libere e scegliere un nome al posto di un altro per una variabile è indifferente.</p>
<p>{y/u, z/v} e {u/y, v/z} rappresentano la stessa classe di variabili.</p>
<p>Per la cronaca: le cose si complicano se si considerano sostituzioni non idempotenti, in questo caso esisstono un&#39;infinità di unificatori più generali.</p>
<p>Cosa abbiamo dimostrato sulla type inference di Haskell?</p>
<ul>
<li>È sempre decidibile;</li>
<li>Come derivare il tipo principale (che coincide con l&#39;unificatore più generale).</li>
</ul>
<h2 id="analisi-sintattica">Analisi sintattica</h2>
<p>Grammatica libera da contesto per le espressioni:</p>
<blockquote>
<p>e ::= n | e + e | e - e
n ::= d | nd
d ::= 0 | 1 | 2 | ...</p>
</blockquote>
<p>Vengono fatte delle derivazioni che generano forme sentenziali, fino ad arrivare a stringhe terminali che rappresentano il linguaggio generato dalla grammatica.</p>
<p>Ogni derivazione di una grammatica può essere rappresentata come un albero.</p>
<blockquote>
<p>e -&gt; e - e -&gt; n - e -&gt; n - e + e -&gt; ... -&gt; 10 - 15 + 12</p>
</blockquote>
<pre><code>        e
    /   |<span class="hljs-string">   \
   e    -    e
   </span>|<span class="hljs-string">     /   </span>|<span class="hljs-string">   \
   n    e    +   e
   </span>|<span class="hljs-string">    </span>|<span class="hljs-string">        </span>|
   10   n        n
        |<span class="hljs-string">        </span>|
        15       12
</code></pre><p>L&#39;albero oltre che a specificare la stringa visualizzata, specifica anche l&#39;ordine in cui la stringa deve essere valutata, che in questo caso è <code>10 - (15 + 12)</code>.</p>
<p>Questo albero per noi è fondamentale in quanto lo usiamo per generare codice.</p>
<p>La generazione dell&#39;albero però può essere ambigua, in quanto la stessa espressione <code>10 - 15 + 12</code> può essere generata da due alberi dirversi che specificano un ordine di valutazione dell&#39;espressione in modo diverso, che portano a risultati diverse.</p>
<p>Una grammatica alternativa che permette di generare le stesse espressioni in modo non ambiguo è data da:</p>
<blockquote>
<p>e    ::= num | e &lt;op&gt; num</p>
<p>&lt;op&gt; ::= + | -</p>
</blockquote>
<p>In questo modo viene vincolata la precedenza a sinistra tipica delle espressioni algebriche.</p>
<p>Però questa grammatica non permette la parentesizzazione delle espressioni.</p>
<blockquote>
<p>e    ::= o | e &lt;op&gt; o
o    ::= num | (e)</p>
<p>&lt;op&gt; ::= + | -</p>
</blockquote>
<p>La grammatica rimane comunque non ambigua.</p>
<p>Ci sono però dei linguaggi che sono interamente ambigui, però per quello che riguarda i linguaggi di programmazione è facile creare delle grammatiche non ambigue.</p>
<h1 id="lezione-9-agol60">Lezione 9 - Agol60</h1>
<p><em>Lungua presentazione della seconda parte progetto</em></p>
<h2 id="algol60">Algol60</h2>
<p>Linguaggio di programmazione sviluppato da Backus/McCarthy ed è stato lo standard accademico fino all&#39;avvento del Pascal.</p>
<p>Punti salienti del linguaggio:</p>
<ul>
<li>Utilizza una grammatica libera da contesto;</li>
<li>Utilizzo della struttura a blocchi (no go-to) caratterizzati da <code>begin-end</code>;</li>
<li>Ricorsione;</li>
<li>Funzioni di ordine superiore (funzioni considerate come oggetti);</li>
<li>Gestione della memoria a stack.</li>
</ul>
<p>Punti scrausi del linguaggio:</p>
<ul>
<li>Problemi nel passaggio delle funzioni come parametro (chiamate procedure);</li>
<li>Array senza bound;</li>
<li>pass-by-name.</li>
</ul>
<pre><code class="lang-ruby">real <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">average</span><span class="hljs-params">(A,n)</span>;</span>
real <span class="hljs-keyword">array</span> A; integer n;
<span class="hljs-keyword">begin</span>
    real sum; sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> <span class="hljs-keyword">step</span> <span class="hljs-number">1</span> <span class="hljs-keyword">until</span> n <span class="hljs-keyword">do</span>
        sum := sum + A[i];
        average := sum/n
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>La cosa strana è che i nomi delle funzioni possono comparire come nomi delle variabili.</p>
<p>Il passaggio di funzioni come parametro soffriva di alcuni problemi di tipo, veniva infatti perso il controllo sui parametri di invocazione della funzione.</p>
<h2 id="pass-by-name">pass-by-name</h2>
<p>Modo per passare i parametri ad una funzione.</p>
<pre><code class="lang-ruby"><span class="hljs-keyword">begin</span> integer i;
    integer <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">sum</span><span class="hljs-params">(i, j)</span>;</span>
        integer i, j;
            comment parameters passed <span class="hljs-keyword">by</span> name;
        <span class="hljs-keyword">begin</span> integer sm; sm := <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span> <span class="hljs-keyword">step</span> <span class="hljs-number">1</span> <span class="hljs-keyword">until</span> <span class="hljs-number">100</span> <span class="hljs-keyword">do</span> sm := sm + j; 
            sum := sm
    <span class="hljs-keyword">end</span>; print(sum(i, i*<span class="hljs-number">10</span> ))
<span class="hljs-keyword">end</span>
</code></pre>
<p>In questo caso la chiamata <code>sum(i,i*10)</code> istanzia <code>j</code> a <code>i*10</code>, in questo modo c&#39;è un cambio di contesto e all&#39;interno delle funzione <code>j</code> viene trasformato in <code>i*10</code>, quindi il risultato della somma anziché essere <code>100*j</code> si ottiene qualcosa di totalmente diverso.</p>
<h1 id="lezione-10-gestione-dei-dati-a-runtime">Lezione 10 - Gestione dei dati a Runtime</h1>
<p><em>Capitolo 7 del libro.</em></p>
<p>Fortran nel 60 non permetteva invocazioni ricorsive, ogni variabile e ogni parametro formale avevano una locazione fissa che conteneva il valore.</p>
<p>Questa strategia di gestione della memoria non permette di andare a definire funzioni ricorsive in quanto il numero di variabili è variabile e non può essere calcolato a runtime.</p>
<p>(Per lo stesso motivo non esistevano neanche i blocchi)</p>
<p>Algol60 essendo strutturato a blocchi ha utilizzato una strategia di gestione diversa:</p>
<ul>
<li>Le variabili venivano dichiarate all&#39;interno di un blocco;</li>
<li>Ogni dichiarazione esiste in un solo blocco;</li>
<li>Quando inizia l&#39;esecuzione di un blocco viene allocata la memoria necessaria per contenere le nuove variabili, questa memoria viene poi deallocata all&#39;uscita del blocco.</li>
</ul>
<h2 id="runtime">Runtime</h2>
<p>Al giorno d&#39;oggi la memoria durante l&#39;esecuzione di un programma viene gestita con uno stack di record di attivazione, ognuno di questi record contiene tutti gli r-valori delle variabili del blocco.</p>
<p>Questo stack cresce dall&#39;alto verso il basso.</p>
<p><img src="./notes/immagini/L10-computer.png" alt=""></p>
<p>Nella parte bassa della memoria virtuale c&#39;è l&#39;heap, l&#39;area della memoria adibita a contenere i dati dinamici.</p>
<p>L&#39;indirizzo dell&#39;ultimo record di attivazione (quello che si trova in cima allo stack) viene gestito dal <strong>enviroment pointer</strong>, un registro fisico della macchina.</p>
<p>Un record di attivazione contiene:</p>
<ul>
<li><strong>Control link</strong>: un puntatore al record di attivazione precedente, serve anche per poter scendere nello stack per accedere ai valori delle variabili degli altri blocchi;</li>
<li>Gli <strong>R-Valori</strong> delle variabili dichiarate nel blocco;</li>
<li><strong>Risultati parziali</strong>: nel caso sia necessario avere della memoria d&#39;appoggio per i registri, questa viene allocata dentro il record di attivazione.</li>
</ul>
<p>Segue che ogni record di attivazione (RA) ha una lunghezza variabile.</p>
<p>Da notare che il codice prodotto dal compilatore deve fare riferimento ad indirizzi dello stack dei RA, questo vuol dire che il compilatore deve avere un modello preciso di come sarà lo stack al momento in cui viene eseguito ciascuna operazione.</p>
<p>Inoltre, dato che lo stack cambia durante l&#39;esecuzione del programma, il compilatore deve essere in grado di andare a calcolare gli indirizzi corretti.</p>
<p><img src="./notes/immagini/L10-funzione.png" alt=""></p>
<p>Quando si entra in un blocco è necessario che il compilatore faccia il push del blocco corretto, mentre quando si esce dal blocco è necessario fare il pop per deallocarle e liberare la memoria.</p>
<h3 id="discesa-nello-stack">Discesa nello stack</h3>
<p>Se all&#39;interno di un blocco vengono utilizzate delle variabili di un altro blocco che contiene il blocco corrente, il compilatore deve essere in grado di andare a calcolare l&#39;indirizzo corretto.</p>
<p>Generalmente la variabile da cercare si trova <em>n</em> record indietro ed è la variabile alla posizione <em>P</em>.</p>
<p>Di conseguenza è possibile indicare l&#39;indirizzo della variabile <em>z</em> con la coppia <em>(n,P)</em>.</p>
<p>Questo è possibile perché il compilatore si costruisce uno stack stastico che ha esattamente la stessa struttura dello stack dinamico.</p>
<p>Nello <strong>stack dinamico</strong> (quello usato durante l&#39;esecuzione del programma) ci sono solo gli R-Valori delle variabili.</p>
<p>Nello <strong>stack statico</strong> che utilizza il compilatore sono presenti sono i nomi delle variabili e non gli R-Valori.</p>
<p>Di conseguenza l&#39;indirizzo statico di una variabile è uguale all&#39;indirizzo dinamico dell&#39;R-Valore della variabile.</p>
<h2 id="i-blocchi-in-haskell">I blocchi in Haskell</h2>
<p>Ogni dichirazione in Haskell definisce un blocco e nel caso si utilizzi <code>let x ... in ...</code> va a creare un blocco che è lo scope di <code>x</code>.</p>
<pre><code class="lang-haskell">f x = x+<span class="hljs-number">1</span>
g y = (f y)+ <span class="hljs-number">2</span>
z = g <span class="hljs-number">3</span>
</code></pre>
<p>diventa qualcosa di simile a </p>
<pre><code class="lang-haskell"><span class="hljs-collection">{
    f x = x + <span class="hljs-number">1</span>
    <span class="hljs-collection">{
        g y = <span class="hljs-list">(<span class="hljs-keyword">f</span> y)</span>+ <span class="hljs-number">2</span>
        <span class="hljs-collection">{
            z = g <span class="hljs-number">3</span>
        }</span>
    }</span>
}</span>
</code></pre>
<h2 id="gestione-dello-stack-statico">Gestione dello stack statico</h2>
<p>Finché il programma è sequenziale e senza costrutti iterativi la situazione è semplice, basta che il compilatore analizzi il codice in modo da identificare i vari blocchi.</p>
<p>Nel caso ci sia un&#39;istruzione iterativa, c&#39;è il record che associato al blocco del ciclo che viene ripetuto varie volte.</p>
<p>Durante l&#39;esecuzione verrà sempre fatto un push e pop dello stesso record di attivazione e di conseguenza gli indirizzi delle variabili presenti nel blocco sarà sempre quello.</p>
<p>Inoltre, non è importante sapere quante volte viene ripetuto il ciclo, dato che ci sarà sempre al massimo un record per volta.</p>
<h3 id="stack-statico-per-le-funzioni">Stack statico per le funzioni</h3>
<p>Anche l&#39;esecuzione di una funzione definisce un blocco che corrisponde al corpo della funzione.</p>
<p>Il problema è che le funzioni possono utilizzare delle variabili globali e andare a ricercare il valore della variabile scendendo nello stack non funziona perché è troppo oneroso.</p>
<p>Per risolvere questo problema si sfrutta il fatto che la definizione della funzione deve essere all&#39;interno di un blocco (globale o no) e che l&#39;invocazione delle funzione viene fatta in un blocco che è contenuto dal blocco che contiene le definizione delle funzioni.</p>
<p>In questo modo per recuperare il valore delle variabili globali usate dentro una funzione viene utilizzata <strong>la prima occorrenza a partire dal blocco della definizione</strong>, questo prende il nome di <strong>scoping statico</strong>.</p>
<p>Il record di attivazione di una funzione deve contenere più dati rispetto ad un record normale:</p>
<ul>
<li><strong>Control link</strong>: indirizzo del record di attivazione sottostante;</li>
<li><strong>Indirizzo di ritorno</strong>: indirizzo dell&#39;istruzione successiva, l&#39;indirizzo è sempre un indirizzo ma riferisce un istruzione del codice sorgente e non un dato nella memoria;</li>
<li><strong>Indirizzo del risultato</strong>: è un indirizzo di una locazione intera allo stack dei dati nel quale si andrà ad inserire l&#39;eventuale valore di ritorno;</li>
<li><strong>Parametri formali</strong>: nello stack statico ci saranno i nomi dei parametri, nello stack dinamico ci saranno gli effettivi valori;</li>
<li><strong>Variabili locali</strong>;</li>
<li><strong>Spazio per i risultati parziali</strong>.</li>
</ul>
<p>Quando si hanno chiamate ricorsive, il codice della funzione esiste in un solo posto e, cosa molto importante, tutti i record di attivazione creati dalle chiamate ricorsive devono avere la stessa struttura.</p>
<p>Questo perché viene sempre eseguito lo <strong>stesso codice</strong> utilizzando <strong>record di attivazione diversi</strong>.</p>
<h4 id="creazione-di-un-record-di-attivazione-per-la-chiamata-di-una-funzione-ricorsiva">Creazione di un record di attivazione per la chiamata di una funzione ricorsiva</h4>
<pre><code class="lang-haskell"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fact</span></span>(n) = <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> n*fact(n-<span class="hljs-number">1</span>)
</code></pre>
<p>Calcolo del fattoriale di n-1 nel registro R0, considerando che è già stato fatto il push iniziale. (E&#39; una chiamata ricorsiva)</p>
<p>Viene fatto un push di un record di 5 posti:</p>
<ol>
<li>Control link = EP</li>
<li>Indirizzo di ritorno = Indirizzo di <code>fact</code> successivo alla richiesta ricorsiva</li>
<li>Indirizzo del risultato = EP+4, quarta posizione del blocco precedente</li>
<li>n = R0, valore del parametro attuale</li>
<li>Spazio vuoto a disposizione per il risultato della chiamata ricorsiva</li>
</ol>
<p>Alla fine viene incrementato EP di 5.</p>
<h1 id="lezione-11-dati-a-runtime-2">Lezione 11 - Dati a runtime 2</h1>
<p>Le funzioni <em>tail recursive</em> sono più semplici da gestire dal punto di vista del compilatore, questo perché al termine della chiamata ricorsiva non vengono effettuate altre operazioni.</p>
<p>Grazie a questo fatto è possibile utilizzare un solo record di attivazione per tutte le chiamate ricorsive. Questo record ha come indirizzo di ritorno, l&#39;indirizzo dell&#39;istruzione dopo la prima chiamata e il valore dei parametri viene via via aggiornato, anziché andare ad aggiungere un nuovo blocco.</p>
<h2 id="variabili-globali-nel-corpo-delle-funzioni">Variabili globali nel corpo delle funzioni</h2>
<p>Per la gestione delle variabili globali possono essere utilizzate due regole:</p>
<ul>
<li><strong>static scope</strong>: il compilatore va a cercare la variabile nei blocchi che racchiudono la definizione delle funzione;</li>
<li><strong>dynamic scope</strong>: il compilatore va a cercare la variabile nei blocchi che racchiudono l&#39;invocazione della funzione.</li>
</ul>
<p>In ogni caso si cerca sempre nel blocco più vicino.</p>
<p>Ovviamente l&#39;utilizzo del dynamic scope comporta che la stessa variabile globale può essere associata a valori diversi, dal momento che il valore dipende dal contesto di esecuzione della funzione.</p>
<p>Per la gestione delle eccezioni è preferibile avere la gestione dello scope dinamica in modo da utilizzare sempre le informazioni &quot;di contesto&quot; delle eccezioni piuttosto che quelle statiche presenti dove è stata definita l&#39;eccezione.</p>
<p>L&#39;implementazione dello scope dinamico è semplice, basta avere a disposizione il control link dei vari record di attivazione in modo da poter risalire tra i record di attivazione per cercare le variabili.</p>
<p>Lo static scope invece è più complesso da implementare, è infatti necessario andare ad aggiungere un nuovo puntantore <strong>access link</strong> (detto anche link statico) che permette di arrivare direttamente al blocco corrispondende alla definizione della funzione che è stata invocata. Una volta raggiunto il blocco, si risale lo stack utilizzando il control link per trovare la prima occorrenza della variabile globale.</p>
<p>Per chiarezza, anche la definizione di una funzione costituisce un blocco, così come la definizione di una variabile.</p>
<h2 id="chiusure">Chiusure</h2>
<p>Le funzioni vengono considerate come variabili globali, con la differenza che non si sa che valore sia associato alla variabile.</p>
<p>Infatti, che valore ha una funzione?</p>
<p>Il valore di una funzione prende il nome di <strong>chiusura</strong> e contiene tutte le informazioni necessarie per preparare l&#39;esecuzione della funzione.</p>
<p>Tra queste ci sono un puntatore per il record di attivazione in cui è definita la funzione e un puntatore al codice compilato della funzione.</p>
<p>Ci sono anche altri valori come la dimensione del record di attivazione.</p>
<h1 id="lezione-12">Lezione 12</h1>
<h2 id="funzioni-come-valori-di-prima-classe">Funzioni come valori di prima classe</h2>
<p>Un linguaggio tratta le funzioni come entità di prima classe se:</p>
<ol>
<li>Una funzione può essere dichiarata in un qualsiasi blocco;</li>
<li>Una funzione può essere passata come argomento ad un&#39;altra funzione (<strong>downward funarg problem</strong>);</li>
<li>Una funzione può essere restituita come risultato di una funzione (<strong>upward funresult problem</strong>).</li>
</ol>
<p>Il punto <strong>1</strong> implica che la definizione di una funzione crea un record di attivazione che custodisce la chiusura <em>(RA, C)</em> della funzione.</p>
<p>Il punto <strong>2</strong> implica che passare una funzione <em>f</em> ad un&#39;altra funzione significa passare il valore di <em>f</em>, cioè la sua chiusura.</p>
<p>C&#39;è una differenza tra l&#39;uso di una funzione passata come parametro ad un&#39;altra funzione e l&#39;utilizzo di una funzione globale all&#39;interno di un&#39;altra funzione. </p>
<p>Nel primo caso il compilatore sa che la funzione invocata riceverà una chiusura, mentre nel secondo caso il compilatore sa esattamente quale funzione verrà invocata.</p>
<p>Con lo scoping dinamico il compilatore riesce a raggiungere una variabile globale calcolandosi direttamente un offset a partire dalla cima dello stack, questo perché ha un modello preciso della struttura dello stack durante l&#39;esecuzione.</p>
<p>Con lo scoping statico il compilatore non riesce a calcolare un offeset preciso, perché se ci sono invocazioni ricorsive la distanza dal top dello stack al blocco della definizione delle funzioni è variabile.</p>
<p>Il punto <strong>3</strong> crea qualche problema, perché se l&#39;invocazione di una funzione definisce e ritorna una nuova funzione il record di attivazione relativo alla nuova funzione si trova &quot;sopra&quot; il record dell&#39;invocazione della prima funzione.</p>
<p>Al termine dell&#39;invocazione il record di attivazione deve essere rimosso dal blocco per fare spazio, tuttavia questo blocco non può essere rimosso, perché sopra ad esso c&#39;è il blocco per la definzione della nuova funzione.</p>
<p>C&#39;è chiaramente un problema e la soluzione tipica è quello di spostare il blocco della definizione della funzione in un&#39;area diversa della memoria (spoiler alert: va a finire nello heap e il puntantore presente nella chiusura deve essere aggiornato).</p>
<pre><code>make_counter x =
    let
        <span class="hljs-command">count</span> = x
        counter inc = <span class="hljs-command">count</span>+inc
    <span class="hljs-keyword">in</span>
        counter
    <span class="hljs-keyword">end</span>
</code></pre><p>In questo caso se rimuovo il blocco relativo all&#39;invocazione di <code>make_counter</code> andrei a perdere la locazione di memoria della variabile globale <code>count</code> che usa la funzione <code>counter</code>.</p>
<h1 id="lezione-13-controllo-del-flusso-di-controllo">Lezione 13 - Controllo del flusso di controllo</h1>
<p>Usare i goto fuori dal blocco rende complesso gestire lo stack dei record di attivazione, quindi i goto sono stati rimossi.</p>
<p>Tuttavia i salti condizonati ogni tanto servono.</p>
<h2 id="controlli-strutturati">Controlli strutturati</h2>
<p>Permettono di fare dei salti:</p>
<ul>
<li><code>if then else</code></li>
<li><code>while { }</code></li>
<li><code>return</code></li>
<li><code>continue</code>,<code>break</code></li>
<li>...</li>
</ul>
<p>Tuttavia questi salti possono essere fatti senza andare a violare la struttura a blocchi del codice.</p>
<h2 id="eccezioni">Eccezioni</h2>
<p>Anche le eccezioni fanno dei salti che sono molto più &quot;<em>spericolati</em>&quot; in quanto quando si verifica un eccezione viene fatto un salto ad un blocco sconosciuto.</p>
<p>Haskell permette di gestire le eccezioni come input-output, mentre ML permette di utilizzare una gestione più completa.</p>
<p>Andare a gestire un&#39;eccezione significa andare a modificare lo stack dei recordi di attivazione.</p>
<p>Cosa succede quando si verifica un&#39;eccezione:</p>
<ol>
<li>Si esce da un blocco o dal corpo di una funzione per andare ad un blocco &quot;<em>handler</em>&quot; che si trova sotto il blocco in cui si è verificata;</li>
<li>Si trasportano dei dati relativi al punto in cui si è verificata l&#39;eccezione;</li>
<li>Si ritorna ad una particolare istruzione del programma da cui si può continuare la normale esecuzione.</li>
</ol>
<p>Perché l&#39;eccezioni funzioni devono essere presenti:</p>
<ul>
<li>La dichiarazione dell&#39;eccezione;</li>
<li>Un istruzione <em>raise</em> che la solleva;</li>
<li>Un handler che si occupa di gestire l&#39;eccezione.</li>
</ul>
<p>In un programma ci possono essere molti handler per una eccezione, in questo caso viene scelto il primo handler che si trova andando a risalire lo stack dei RA. Segue che per le eccezioni l&#39;unica scelta ragionevole è quella di utilizzare lo scoping dinamico.</p>
<h3 id="eccezioni-in-ml">Eccezioni in ML</h3>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">esp1</span>&gt;</span> handle <span class="hljs-tag">&lt;<span class="hljs-title">pattern</span>&gt;</span> =&gt; esp2
</code></pre><p>Ricorda un po&#39; il classico <code>try-catch</code>, viene eseguita <code>esp1</code> e se l&#39;esecuzione va a buon fine viene restituito il valore calcolato dell&#39;espressione.</p>
<p>Se invece viene sollevata un&#39;eccezione che matcha <code>pattern</code> allora viene eseguita l&#39;espressione <code>esp2</code>.</p>
<p>Se non c&#39;è nessun match per il pattern, oppure <code>esp2</code> solleva un&#39;altra eccezione, allora si ricerca un altro handler in un blocco superiore.</p>
<p>Tutto il costrutto è a sua volta un&#39;espressione che deve ritornare sempre lo stesso tipo, di conseguenza <code>esp1</code> e <code>esp2</code> devono avere lo stesso tipo (oppure non deve esserci un risultato). </p>
<pre><code>exception uno;
exception due;

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span></span>(x) = <span class="hljs-keyword">if</span> x = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> raise uno <span class="hljs-keyword">else</span> raise due;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">g</span></span>(y) = f(y) handle uno =&gt; <span class="hljs-number">1</span>;
</code></pre><p>Il tipo dedotto (in ML) per <code>f</code> è <code>int -&gt; &#39;a</code>, in quanto il sollevamento di un&#39;eccezione non c&#39;entra nulla con il tipo del valore di ritorno, quindi <code>f</code> ritorna un risultato qualsiasi.</p>
<pre><code>exception <span class="hljs-constant">E</span> <span class="hljs-keyword">of</span> int;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span></span>() = raise <span class="hljs-constant">E</span>(<span class="hljs-number">2</span>);
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">g</span></span>(y) = (<span class="hljs-keyword">if</span> f() <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>) handle <span class="hljs-constant">E</span>(x) =&gt; x*y;

val z = g(<span class="hljs-number">3</span>)
</code></pre><p>Ha come record di attivazione</p>
<pre><code><span class="hljs-number">1</span>[CL=<span class="hljs-number">0</span>, AL=<span class="hljs-number">0</span>, exc E]
<span class="hljs-number">2</span>[CL=<span class="hljs-number">1</span>, AL=<span class="hljs-number">1</span>, (<span class="hljs-number">2</span>,f)]
<span class="hljs-number">3</span>[CL=<span class="hljs-number">2</span>, AL=<span class="hljs-number">2</span>, (<span class="hljs-number">3</span>,g)]
<span class="hljs-number">4</span>[CL=<span class="hljs-number">3</span>, AL=<span class="hljs-number">3</span>, z= ]
<span class="hljs-number">5</span>[CL=<span class="hljs-number">4</span>, AL=<span class="hljs-number">3</span>, rit=end, ris=(CL-&gt;z), y=<span class="hljs-number">3</span>, f()= ] <span class="hljs-comment">//Blocco per l'invocazione di g</span>
<span class="hljs-number">6</span>[CL=<span class="hljs-number">5</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(x)</span> </span>=&gt; x*y] <span class="hljs-comment">//Blocco segnaposto per l'handler presente dentro g</span>
<span class="hljs-number">7</span>[CL=<span class="hljs-number">6</span>, AL=<span class="hljs-number">2</span>, rit=then, ris=(CL-&gt;CL-&gt;f())] <span class="hljs-comment">//Blocco per l'invocazione di f</span>
</code></pre><p>Quando viene eseguito il codice del handler il blocco in cima alla pila è quello che contiene la definizione dell&#39;handler, in questo caso è il blocco 5, con l&#39;aggiunta dei parametri dell&#39;eccezione (in questo caso c&#39;è anche il valore <code>x</code>).</p>
<p>Sempre nell&#39;esempio: quando viene invocata <code>f</code>:</p>
<ol>
<li>Viene sollevata l&#39;eccezione <code>E(2)</code>;</li>
<li>Viene fatto il pop del blocco 7;</li>
<li>Viene posto <code>x=2</code> in <code>E(x) =&gt; x*y</code>;</li>
<li>Viene fatto il pop del blocco 6;</li>
<li>Viene eseguito <code>x*y</code> con <code>x=2</code> e con il blocco 5 in cima alla pila;</li>
<li>Viene memorizzato il risultato in <code>CL-&gt;z</code>.</li>
</ol>
<h3 id="esecirzi-sulla-gestione-delle-eccezioni">Esecirzi sulla gestione delle eccezioni</h3>
<pre><code>exception A of int;
exception E of int;
<span class="hljs-variable"><span class="hljs-keyword">val</span> x</span> = <span class="hljs-number">2</span>;
<span class="hljs-variable"><span class="hljs-keyword">val</span> w</span> = <span class="hljs-number">1</span>;
<span class="hljs-variable"><span class="hljs-keyword">val</span> y</span> = <span class="hljs-number">3</span>;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">h</span><span class="hljs-params">(x)</span> = <span class="hljs-keyword">if</span> x=y then y <span class="hljs-keyword">else</span> raise <span class="hljs-title">A</span><span class="hljs-params">(y)</span>;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> y</span> = <span class="hljs-number">4</span>;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(w)</span> = <span class="hljs-params">(<span class="hljs-keyword">if</span> w = h(w)</span> then raise <span class="hljs-title">E</span><span class="hljs-params">(w)</span> <span class="hljs-keyword">else</span> y) handle <span class="hljs-title">A</span><span class="hljs-params">(x)</span> =&gt; x;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> x</span> = f(y);
</code></pre><p>Lo stack è il seguente</p>
<pre><code><span class="hljs-number">1</span><span class="hljs-list">[<span class="hljs-keyword">CL=0</span>, AL=0, A of int]
<span class="hljs-number">2</span><span class="hljs-list">[<span class="hljs-keyword">CL=1</span>, AL=1, E of int]
<span class="hljs-number">3</span><span class="hljs-list">[<span class="hljs-keyword">CL=2</span>, AL=2, x=2]
<span class="hljs-number">4</span><span class="hljs-list">[<span class="hljs-keyword">CL=3</span>, AL=3, w=1]
<span class="hljs-number">5</span><span class="hljs-list">[<span class="hljs-keyword">CL=4</span>, AL=4, y=3]
<span class="hljs-number">6</span><span class="hljs-list">[<span class="hljs-keyword">CL=5</span>, AL=5, <span class="hljs-list">(<span class="hljs-keyword">6</span>,h)</span>]
<span class="hljs-number">7</span><span class="hljs-list">[<span class="hljs-keyword">CL=6</span>, AL=6, y=4]
<span class="hljs-number">8</span><span class="hljs-list">[<span class="hljs-keyword">CL=7</span>, AL=7, <span class="hljs-list">(<span class="hljs-keyword">8</span>,f)</span>]
<span class="hljs-number">9</span><span class="hljs-list">[<span class="hljs-keyword">CL=8</span>, AL=8, x= ]
<span class="hljs-number">10</span><span class="hljs-list">[<span class="hljs-keyword">CL=9</span>, AL=8, rit=end, ris=CL-&gt;x, w=4, h<span class="hljs-list">(<span class="hljs-keyword">w</span>)</span>= ] //invocazione di f
<span class="hljs-number">11</span><span class="hljs-list">[<span class="hljs-keyword">CL=10</span>, AL=10, handle A<span class="hljs-list">(<span class="hljs-keyword">x</span>)</span> =&gt; x]
<span class="hljs-number">12</span><span class="hljs-list">[<span class="hljs-keyword">CL=11</span>, AL=6, rit=<span class="hljs-list">(<span class="hljs-keyword"><span class="hljs-built_in">if</span></span> di f)</span>, ris=<span class="hljs-list">(<span class="hljs-keyword">CL-&gt;CL-&gt;h</span><span class="hljs-list">(<span class="hljs-keyword">w</span>)</span>)</span>, x=4] //Invocazione di h<span class="hljs-list">(<span class="hljs-keyword">w</span>)</span> dentro f
** eseguita raise di A<span class="hljs-list">(<span class="hljs-keyword">3</span>)</span>, pop<span class="hljs-list">(<span class="hljs-keyword">12</span>)</span>, pop<span class="hljs-list">(<span class="hljs-keyword">11</span>)</span>, esegue A<span class="hljs-list">(<span class="hljs-keyword">3</span>)</span>=3, scrive risultato <span class="hljs-number">3</span> in <span class="hljs-number">9</span>-&gt;x, pop<span class="hljs-list">(<span class="hljs-keyword">10</span>)</span> **</span></span></span></span></span></span></span></span></span></span></span></span>
</code></pre><p>Nel caso l&#39;handler <code>A(x) = x</code> contenesse un&#39;espressione più complessa, come l&#39;invocazione di una funzione <code>g(x)</code>, deve essere previsto uno slot nel record di attivazione dell&#39;esecuzione della funzione per mantenere il risultato parziale:</p>
<pre><code><span class="hljs-number">10</span>[CL=<span class="hljs-number">9</span>, AL=<span class="hljs-number">8</span>, rit=end, ris=CL-&gt;x, w=<span class="hljs-number">4</span>, h(w)= , g(x)= ]
</code></pre><h3 id="problemi-legati-alla-gestione-delle-eccezioni">Problemi legati alla gestione delle eccezioni</h3>
<p>Se quando si effettua il pop per cercare un handler può capitare che dentro uno dei record tolti ci sia un puntatore verso della memoria nello heap.</p>
<p>In questo caso se il linguaggio non possiede un garbage collector, come il C++, si possono usare due strategie:</p>
<ul>
<li><strong>fregarsene</strong>: le eccezioni sono eccezionali per natura e quindi posso fare garbage perché si verificano poche volte;</li>
<li><strong>distruggere</strong>: negli oggetti viene invocato il distruttore in modo da liberare sempre la memoria.</li>
</ul>
<h4 id="handler-dentro-a-funzioni-ricorsive">Handler dentro a funzioni ricorsive</h4>
<pre><code>fun <span class="hljs-literal">f</span>(0) = 1
    | <span class="hljs-literal">f</span>(1) = raise Odd
    | <span class="hljs-literal">f</span>(3) = <span class="hljs-literal">f</span>(3-2)
    | <span class="hljs-literal">f</span>(<span class="hljs-keyword">n</span>) = <span class="hljs-literal">f</span>(<span class="hljs-keyword">n</span>-2) handle Odd =&gt; ~<span class="hljs-keyword">n</span>
</code></pre><p>Invocando <code>f(11)</code> vengono creati 4 handler per la stessa gestione di <code>Odd</code>.
Quando viene sollevata l&#39;eccezione viene invocato il primo handler trovato, cioè l&#39;ultimo creato, che è quello che ritorna <code>-5</code>.</p>
<p>Il problema si verifica con la gestione ottimizzata per le funzioni ricorsive terminale, in quanto non è più possibile andare a riusare lo stesso record di attivazione per tutte le invocazioni ricorsive.</p>
<p>Le funzioni ricorsive terminali possono essere comunque ottimizzate, tuttavia la presenza di handler complica la cosa.</p>
<h4 id="eccezioni-ed-ordine-di-valutazione">Eccezioni ed ordine di valutazione</h4>
<pre><code>exception <span class="hljs-constant">A</span>;
exception <span class="hljs-constant">B</span>;

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span></span>(<span class="hljs-number">0</span>) = raise <span class="hljs-constant">A</span>
    | f(<span class="hljs-number">1</span>) = raise <span class="hljs-constant">B</span>
    | f(x) = x;

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">g</span></span>(x,y) = x+y;

g(f(<span class="hljs-number">1</span>),f(<span class="hljs-number">0</span>)) handle <span class="hljs-constant">A</span> =&gt; <span class="hljs-number">0</span>
                | <span class="hljs-constant">B</span> =&gt; <span class="hljs-number">1</span>;
</code></pre><p>In questo caso l&#39;ordine di sollevazione delle eccezioni dipende dall&#39;ordine di valutazione dei parametri delle funzioni, violando così la dichiaratività del linguaggio.</p>
<h1 id="lezione-14-richiami-ed-esercizi">Lezione 14 - Richiami ed esercizi</h1>
<p>Alcuni linguaggi funzionli come Lisp e ML non sono linguaggi completamente dichiarativi in quanto permettono di eseguire delle assegnazioni.</p>
<p>Haskell invece è dichiarativo (funzionale puro).</p>
<p>Nei linguaggi dichiarativi l&#39;essenza del calcolo consiste nel valutare delle funzioni.</p>
<p>Le invocazioni di queste funzioni non producono dei side effects.</p>
<h2 id="referential-transparency">Referential transparency</h2>
<p>In linguistica si una per ildnciare il denomeno in cui un termine può essere sostituito con un altro mantenendo inalterato il significato della frase.</p>
<p>I linguaggi funzionali puri supportano (maggiromente) la referential transparency, mentre quelli imperativi no (o meno).</p>
<p>Nei linguaggi funzionali puri se <code>x</code> e <code>y</code> anno lo stesso valore, allora <code>f x</code> è equivalente a <code>f y</code>. Nei linguaggi imperativi questo è vero solo se <code>x</code> e <code>y</code> sono alias.</p>
<p>Nei linguaggi funzionali puri una variabile è solo un nome associato ad un valore costante.</p>
<p>Nei linguaggi funzionali due funzioni sono equivalenti se hanno lo stesso grafo, mentre in quelle funzionali ci sono da considerare anche i side effects.</p>
<h2 id="esercizio-sulla-gestione-dello-stack">Esercizio sulla gestione dello stack</h2>
<pre><code>exception E of int;
<span class="hljs-variable"><span class="hljs-keyword">val</span> x</span>=<span class="hljs-number">2</span>;
<span class="hljs-variable"><span class="hljs-keyword">val</span> z</span>=<span class="hljs-number">3</span>;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">f</span><span class="hljs-params">(a)</span>=<span class="hljs-keyword">if</span> <span class="hljs-title">a</span><span class="hljs-params">(x)</span>+1 =2 then raise <span class="hljs-title">E</span><span class="hljs-params">(x)</span> <span class="hljs-keyword">else</span> x;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> x</span>=<span class="hljs-number">4</span>;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">q</span><span class="hljs-params">()</span>=z*x;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> y</span>=<span class="hljs-number">5</span>;
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">g</span><span class="hljs-params">(z)</span>=let <span class="hljs-keyword">fun</span> <span class="hljs-title">h</span><span class="hljs-params">()</span>=<span class="hljs-title">f</span><span class="hljs-params">(z)</span>+x <span class="hljs-keyword">in</span> h end;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">p</span><span class="hljs-params">(a)</span>=<span class="hljs-title">a</span><span class="hljs-params">()</span> handle <span class="hljs-title">E</span><span class="hljs-params">(w)</span>=&gt; <span class="hljs-title">q</span><span class="hljs-params">()</span>+w;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">p1</span><span class="hljs-params">(a)</span>=<span class="hljs-keyword">if</span> a=x then x <span class="hljs-keyword">else</span> raise <span class="hljs-title">E</span><span class="hljs-params">(a)</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">p2</span><span class="hljs-params">(a)</span>=<span class="hljs-keyword">if</span> a=y then y+x <span class="hljs-keyword">else</span> raise <span class="hljs-title">E</span><span class="hljs-params">(y)</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">k</span><span class="hljs-params">()</span>= <span class="hljs-title">g</span><span class="hljs-params">(p1)</span> handle <span class="hljs-title">E</span><span class="hljs-params">(w)</span>=&gt; <span class="hljs-title">g</span><span class="hljs-params">(p2)</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">s</span><span class="hljs-params">()</span>=<span class="hljs-title">k</span><span class="hljs-params">()</span> handle <span class="hljs-title">E</span><span class="hljs-params">(w)</span>=&gt; q;</span>
<span class="hljs-variable"><span class="hljs-keyword">val</span> r</span>=s();
<span class="hljs-variable"><span class="hljs-keyword">val</span> t</span>=p(r);
</code></pre><p>Stack:</p>
<pre><code> <span class="hljs-number">1</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, E of <span class="hljs-keyword">int</span>]
 <span class="hljs-number">2</span> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, x =<span class="hljs-number">2</span>]
 <span class="hljs-number">3</span> [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, z = <span class="hljs-number">5</span>]
 <span class="hljs-number">4</span> [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, f = (<span class="hljs-number">4</span>,f)]
 <span class="hljs-number">5</span> [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, x = <span class="hljs-number">4</span>]
 <span class="hljs-number">6</span> [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, q = (<span class="hljs-number">6</span>,q)]
 <span class="hljs-number">7</span> [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, y = <span class="hljs-number">5</span>]
 <span class="hljs-number">8</span> [<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, g = (<span class="hljs-number">8</span>,g)]
 <span class="hljs-number">9</span> [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, p = (<span class="hljs-number">9</span>,p)]
<span class="hljs-number">10</span> [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>, p1 = (<span class="hljs-number">10</span>,p1)]
<span class="hljs-number">11</span> [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, p2 = (<span class="hljs-number">11</span>,p2)]
<span class="hljs-number">12</span> [<span class="hljs-number">11</span>, <span class="hljs-number">11</span>, k = (<span class="hljs-number">12</span>,k)]
<span class="hljs-number">13</span> [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, s = (<span class="hljs-number">13</span>,s)]
<span class="hljs-number">14</span> [<span class="hljs-number">13</span>, <span class="hljs-number">13</span>, r = _]
<span class="hljs-number">15</span> [<span class="hljs-number">14</span>, <span class="hljs-number">13</span>, rit=<span class="hljs-string">"fine di r"</span>, res=EP-&gt;CL-&gt;r, k() = ] <span class="hljs-comment">//invocazione di s</span>
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(w)</span> </span>=&gt; q]
<span class="hljs-number">17</span> [<span class="hljs-number">16</span>, <span class="hljs-number">12</span>, rit=<span class="hljs-string">"handler di s"</span>, res = CL-&gt;CL-&gt;k(), g(p1) = _, g(p2) = _] <span class="hljs-comment">//invocazione di k</span>
<span class="hljs-number">18</span> [<span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(w)</span> </span>=&gt; g(p2)]
<span class="hljs-number">19</span> [<span class="hljs-number">18</span>, <span class="hljs-number">8</span>, rit=<span class="hljs-string">"handler di k"</span>, ris=CL-&gt;CL-&gt;g(p1), z = (<span class="hljs-number">10</span>,p1), h = (<span class="hljs-number">19</span>,h)] <span class="hljs-comment">// Invocazione di g(p1)</span>
</code></pre><p>L&#39;esecuzione di <code>g(p1)</code> termina, ma il record di attivazione deve essere portato nello heap perché contiene la definizione di <code>h</code>.</p>
<pre><code><span class="hljs-number">19</span>* [<span class="hljs-number">18</span>, <span class="hljs-number">8</span>, rit=<span class="hljs-string">"handler di k"</span>, ris=CL-&gt;CL-&gt;g(p1), z = (<span class="hljs-number">10</span>,p1), h = (<span class="hljs-number">19</span>*,h)]
</code></pre><p>Una volta copiato il record è possibile fare il pop del record 19 e 18.</p>
<pre><code><span class="hljs-number">14</span> [<span class="hljs-number">13</span>, <span class="hljs-number">13</span>, r = _]
<span class="hljs-number">15</span> [<span class="hljs-number">14</span>, <span class="hljs-number">13</span>, rit=<span class="hljs-string">"fine di r"</span>, res=EP-&gt;CL-&gt;r, <span class="hljs-function"><span class="hljs-title">k</span><span class="hljs-params">()</span></span> = ] <span class="hljs-comment">//invocazione di s</span>
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, handle <span class="hljs-function"><span class="hljs-title">E</span><span class="hljs-params">(w)</span></span> =&gt; q]
<span class="hljs-number">17</span> [<span class="hljs-number">16</span>, <span class="hljs-number">12</span>, rit=<span class="hljs-string">"handler di s"</span>, res = CL-&gt;CL-&gt;<span class="hljs-function"><span class="hljs-title">k</span><span class="hljs-params">()</span></span>, <span class="hljs-function"><span class="hljs-title">g</span><span class="hljs-params">(p1)</span></span> = (<span class="hljs-number">19</span>*,h), <span class="hljs-function"><span class="hljs-title">g</span><span class="hljs-params">(p2)</span></span> = _] <span class="hljs-comment">//invocazione di k</span>
</code></pre><p>L&#39;invocazione di <code>k</code> termina e viene fatto il pop di 17, 16, fatto questo termina anche <code>s</code>, causando il pop di 15.</p>
<pre><code><span class="hljs-number">14</span> [<span class="hljs-number">13</span>,<span class="hljs-number">13</span>, r = (<span class="hljs-number">19</span>*,h)]
<span class="hljs-number">15</span> [<span class="hljs-number">14</span>,<span class="hljs-number">14</span>, t = _]
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">9</span>, rit=<span class="hljs-string">"fine"</span>, ris=CL-&gt;t, <span class="hljs-tag">a</span> = (<span class="hljs-number">19</span>*,h), <span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">()</span></span> = _, <span class="hljs-tag">q</span> = _] <span class="hljs-comment">//invocazione di p(r)</span>
<span class="hljs-number">17</span> [<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, handle <span class="hljs-function"><span class="hljs-title">E</span><span class="hljs-params">(w)</span></span> =&gt; <span class="hljs-function"><span class="hljs-title">q</span><span class="hljs-params">()</span></span> + w]
<span class="hljs-number">18</span> [<span class="hljs-number">17</span>, <span class="hljs-number">19</span>*, rit=<span class="hljs-string">"handle di p"</span>, ris=CL-&gt;CL-&gt;<span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">()</span></span>, <span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(z)</span></span>] <span class="hljs-comment">//invocazione di h</span>
<span class="hljs-number">19</span> [<span class="hljs-number">18</span>, <span class="hljs-number">4</span>, rit=<span class="hljs-string">"+ di h"</span>, ris=CL-&gt;<span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(z)</span></span>, <span class="hljs-tag">a</span> = (<span class="hljs-number">10</span>,p1), <span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(x)</span></span> = _] <span class="hljs-comment">//invocazione di f(z)</span>
<span class="hljs-number">20</span> [<span class="hljs-number">19</span>, <span class="hljs-number">10</span>, rit=<span class="hljs-string">"+ di f"</span>, ris=CL-&gt;<span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(x)</span></span>, <span class="hljs-tag">a</span> = <span class="hljs-number">2</span>, ] <span class="hljs-comment">//invocazione di p1(x)</span>
</code></pre><p>Esegue <code>if a=x</code>, con a=2 e x=4, viene quindi eseguito il ramo else che solleva l&#39;eccezione E(2).
Viene fatto il pop di 20, 19 e 18.
Viene trovato un handler in 17, con il conseguente pop del record.
Viene eseguito il corpo dell&#39;handler <code>q()+w</code> con il record 16 in cima e <code>w=2</code>.</p>
<pre><code><span class="hljs-number">15</span> [<span class="hljs-number">14</span>,<span class="hljs-number">14</span>, t = _]
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">9</span>, rit=<span class="hljs-string">"fine"</span>, ris=CL-&gt;t, a = (<span class="hljs-number">19</span>*,h), a() = _, q = _] <span class="hljs-comment">//invocazione di p(r)</span>
<span class="hljs-number">17</span> [<span class="hljs-number">16</span>, <span class="hljs-number">6</span>, rit=<span class="hljs-string">"+ di handle di p"</span>, ris=CL-&gt;q()] <span class="hljs-comment">//invocazione di q</span>
</code></pre><p>Viene eseguito <code>z*x</code> con <code>z=3</code> e <code>x=4</code>.
L&#39;esecuzione di <code>q()</code> termina con il conseguente pop di 17.</p>
<pre><code><span class="hljs-number">15</span> [<span class="hljs-number">14</span>,<span class="hljs-number">14</span>, t = _]
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">9</span>, rit=<span class="hljs-string">"fine"</span>, ris=CL-&gt;t, a = (<span class="hljs-number">19</span>*,h), a() = _, q() = <span class="hljs-number">12</span>] <span class="hljs-comment">//invocazione di p(r)</span>
</code></pre><p>L&#39;esecuzione di <code>p(r)</code> termina ritornando 14.</p>
<pre><code><span class="hljs-number">15</span> [<span class="hljs-number">14</span>,<span class="hljs-number">14</span>, t = <span class="hljs-number">14</span>]
</code></pre><p>Inoltre il record 19* può essere rimosso dallo heap dal momento che non c&#39;è più nessun riferimento verso tale blocco.</p>
<p>Variabili di <code>h</code></p>
<ul>
<li><code>z = EP-&gt;AL-&gt;z</code></li>
<li><code>x = EP-&gt;AL-&gt;AL-&gt;CL-&gt;CL-&gt;CL-&gt;x</code></li>
</ul>
<p><strong>Da notare</strong>: il record 19 quando viene messo nello heap ha un CL verso il record 18 dello heap, che però non esiste più. Questa cosa non da problemi, in quanto il record 19* è il record di attivazione dell&#39;invocazione di una funzione e quindi per recuperare il contesto di quel record è necessario seguire l&#39;AL e non il CL. 
Se il record di attivazione puntato da AL deve uscire dallo stack è necessario copiarlo nello heap e aggiornare i vari riferimenti.</p>
<h2 id="punto-fisso-di-una-funzione">Punto fisso di una funzione</h2>
<pre><code>y f = f <span class="hljs-comment">(y f)</span>
:t y
<span class="hljs-comment">((a-&gt;b)</span>-&gt;<span class="hljs-comment">(a-&gt;b)</span>)-&gt;<span class="hljs-comment">(a-&gt;b)</span>
</code></pre><p><code>y</code> calcola il punto fisso di <code>f</code>, cioè qunado <code>f(g) = g</code>.</p>
<p><code>f</code> sarebbe una funzione che esegue un passo di un algoritmo che funziona a punto fisso, mentre <code>y</code> è la funzione che esegue il calcolo dell&#39;algoritmo.</p>
<p>Se</p>
<pre><code>f g x = <span class="hljs-keyword">if</span> x = <span class="hljs-number">1</span> then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-function">x*<span class="hljs-title">g</span><span class="hljs-params">(x-<span class="hljs-number">1</span>)</span></span>
</code></pre><p>In questo caso se <code>g</code> è la funzione fattoriale, il punto fisso di <code>f</code> è il fattoriale.</p>
<p>Se applico <code>y</code> a <code>f</code>, ottengo qualcosa di simile a</p>
<pre><code>y f x = <span class="hljs-keyword">if</span> x = <span class="hljs-number">1</span> then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x*(Y <span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(x-<span class="hljs-number">1</span>)</span></span>)
</code></pre><p>È possibile andare a ripertere lo stesso ragionamento per vedere che viene calcolato il fattoriale di <code>x</code>.</p>
<h1 id="lezione-15-funtori-e-funtori-applicativi">Lezione 15 - Funtori e Funtori Applicativi</h1>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f <span class="hljs-keyword">where</span></span>
    fmap :: (a-&gt;b) -&gt; f a -&gt; f b
</code></pre>
<p><code>f</code> è un tipo parametrico (<em>type constructor</em>) quindi <code>(f a)</code> indica il tipo <code>f</code> instanziato con <code>a</code>.</p>
<p>I funtori devono avere solo un tipo parametrico.</p>
<pre><code class="lang-haskell">instance Functor Maybe where
    fmap f<span class="hljs-function"> (</span>Just x<span class="hljs-function">)</span> = Just<span class="hljs-function"> (</span>f x<span class="hljs-function">)</span>
    fmap f Nothing = Nothing 
<span class="hljs-instruction">
instance </span>Functor Tree where
    fmap f EmptyTree = EmptyTree
    fmap f<span class="hljs-function"> (</span>Node x leftsub rightsub<span class="hljs-function">)</span> = Node<span class="hljs-function"> (</span>f x<span class="hljs-function">)</span><span class="hljs-function"> (</span>fmap f leftsub<span class="hljs-function">)</span><span class="hljs-function"> (</span>fmap f rightsub<span class="hljs-function">)</span> 
<span class="hljs-instruction">
instance </span>Functor<span class="hljs-function"> (</span>Either a<span class="hljs-function">)</span> where
    fmap f<span class="hljs-function"> (</span>Right x<span class="hljs-function">)</span> = Right<span class="hljs-function"> (</span>f x<span class="hljs-function">)</span>
    fmap f<span class="hljs-function"> (</span>Left x<span class="hljs-function">)</span> = Left x -- La parte left è fissa.
</code></pre>
<h2 id="funtori-applicativi">Funtori Applicativi</h2>
<p>I funtori permettono di spalmare una funzione su un oggetto &quot;scatola&quot; e che ritorna un altro oggetto scatola.</p>
<pre><code class="lang-haskell">class (Functor f) =&gt; Applicative f where
    pure :: <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">a</span>
    (&lt;*&gt;) :: f (<span class="hljs-tag">a</span> -&gt; b) -&gt; f <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">b</span>

(&lt;$&gt;) :: (Functor f) =&gt; (<span class="hljs-tag">a</span> -&gt; b) -&gt; f <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">b</span>
f &lt;$&gt; x = fmap f x
</code></pre>
<p><code>pure :: a -&gt; f a</code> da un tipo qualsiasi ritorna un funtore istanziato a quel tipo.</p>
<p>Le <code>( )</code> nella definizione del tipo rappresentano una funzione infissa.</p>
<pre><code class="lang-haskell">instance Applicative Maybe where
    pure = Just
    Nothing <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> _ = Nothing
    (Just f) <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> something = fmap f something

f <span class="hljs-tag">&lt;<span class="hljs-title">$</span>&gt;</span> something = fmap f something
</code></pre>
<pre><code class="lang-haskell">ghci&gt; :t pure (+)
pure (+) :: (Num a, Applicative f) =&gt; f (a -&gt; a -&gt; a)
ghci&gt; :t pure (+) <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 3
pure (+) <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 3 :: Num a =&gt; Maybe (a -&gt; a)
ghci&gt; pure (+) <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 3 <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 5
Just 8
ghci&gt; (+) <span class="hljs-tag">&lt;<span class="hljs-title">$</span>&gt;</span> Just 3 <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 5
Just 8
ghci&gt; (+) <span class="hljs-tag">&lt;<span class="hljs-title">$</span>&gt;</span> Just 3 <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Nothing
Nothing
ghci&gt; (+) <span class="hljs-tag">&lt;<span class="hljs-title">$</span>&gt;</span> Nothing <span class="hljs-tag">&lt;<span class="hljs-title">*</span>&gt;</span> Just 5
Nothing
</code></pre>
<p>Un funtore applicativo viene quindi utilizzato per eseguire una funzione all&#39;interno di altri alcuni funtori.</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> [] <span class="hljs-keyword">where</span></span>
    pure = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]
</code></pre>
<pre><code>ghci&gt; [(*<span class="hljs-number">0</span>),(+<span class="hljs-number">100</span>),(^<span class="hljs-number">2</span>)] &lt;*&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">101</span>,<span class="hljs-number">102</span>,<span class="hljs-number">103</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>]
ghci&gt; [(+),(*)] &lt;*&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] &lt;*&gt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]
ghci&gt; filter (&gt;<span class="hljs-number">50</span>) $ pure (*) &lt;*&gt; [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>] &lt;*&gt; [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]
[<span class="hljs-number">55</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">110</span>]
</code></pre><p>Da notare che il numero di <code>&lt;*&gt;</code> deve coincidere con tutti il numero dei parametri delle funzione che viene &quot;<em>purificata</em>&quot;.</p>
<pre><code>pure <span class="hljs-comment">(,,)</span>:: Applicative f =&gt; f <span class="hljs-comment">(a-&gt;b-&gt;c-&gt;(a,b,c)</span>)
</code></pre><p>Il “resto” determina il funtore f: guarda gli esempi seguenti</p>
<pre><code>-- f=Maybe
ghci&gt; k = <span class="hljs-keyword">pure</span> (,,)&lt;*&gt; Just <span class="hljs-string">"pippo"</span>&lt;*&gt; Just <span class="hljs-string">"pluto"</span>&lt;*&gt; Just <span class="hljs-string">"pappa”
Just ("</span>pippo<span class="hljs-string">","</span>pluto<span class="hljs-string">","</span>pappa<span class="hljs-string">")
-- f=list
ghci&gt; z = pure (,,) &lt;*&gt; ["</span><span class="hljs-keyword">pure</span><span class="hljs-string">","d</span>opo<span class="hljs-string">"] &lt;*&gt; ["</span>pippo<span class="hljs-string">","</span>pluto<span class="hljs-string">"] &lt;*&gt; [3]
[("</span><span class="hljs-keyword">pure</span><span class="hljs-string">","</span>pippo<span class="hljs-string">",3),("</span><span class="hljs-keyword">pure</span><span class="hljs-string">","</span>pluto<span class="hljs-string">",3),("d</span>opo<span class="hljs-string">","</span>pippo<span class="hljs-string">",3),("d</span>opo<span class="hljs-string">","</span>plu
to<span class="hljs-string">",3)]</span>
</code></pre><p>Da notare che non posso mettere <code>3</code> al posto di <code>[3]</code> perché serve un funtore e <code>3</code> non lo è.</p>
<p>Giocando con le liste sarebbe bello poter arrivare ad avere la possibilità di fare questo:</p>
<pre><code>[(+), (*), (/)] &lt;*&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &lt;*&gt; [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] =[<span class="hljs-number">1</span>+<span class="hljs-number">2</span>,<span class="hljs-number">2</span>*<span class="hljs-number">3</span>,<span class="hljs-number">3</span>/<span class="hljs-number">4</span>]
</code></pre><p>Per fare ciò è possibile definire il tipo <code>ZipList</code>, che è un funtore applicativo definito come:</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">ZipList</span> <span class="hljs-keyword">where</span></span>
    pure x = <span class="hljs-type">ZipList</span> (repeat x) <span class="hljs-comment">--Serve per limitare il numero di elemeni alla lunghezza della prima lista</span>
    <span class="hljs-type">ZipList</span> fs &lt;*&gt; <span class="hljs-type">ZipList</span> xs = <span class="hljs-type">ZipList</span> (zipWith (\f x -&gt; f x) fs xs)
</code></pre>
<p>Anche <code>r -&gt; a</code> è un funtore applicativo.</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-container">((-&gt;)</span> r) <span class="hljs-keyword">where</span></span>
    pure x = (\_ -&gt; x)
    f &lt;*&gt; g = \x -&gt; f x (g x)
</code></pre>
<pre><code>ghci&gt; :t pure <span class="hljs-comment">(+)</span> &lt;*&gt; <span class="hljs-comment">(+3)</span> &lt;*&gt; <span class="hljs-comment">(*100)</span>
pure <span class="hljs-comment">(+)</span> &lt;*&gt; <span class="hljs-comment">(+3)</span> &lt;*&gt; <span class="hljs-comment">(*100)</span> :: <span class="hljs-comment">(Num a)</span> =&gt; a -&gt; a
ghci&gt; pure <span class="hljs-comment">(+)</span> &lt;*&gt; <span class="hljs-comment">(+3)</span> &lt;*&gt; <span class="hljs-comment">(*100)</span> $ <span class="hljs-number">5</span>
<span class="hljs-number">508</span>
</code></pre><p><code>5</code> viene usato prima come operando di <code>(*100)</code> e poi viene usato come operando per <code>(+3)</code>, dopodiché ai due risultati viene applicata la funzione <code>(+)</code>, ottenendo così <code>508</code>.</p>
<pre><code>ghci&gt; pure (\x y z -&gt; [x,y,z]) &lt;*&gt; (+<span class="hljs-number">3</span>) &lt;*&gt; (*<span class="hljs-number">2</span>) &lt;*&gt; (/<span class="hljs-number">2</span>) $ <span class="hljs-number">5</span>
[<span class="hljs-number">8.0</span>,<span class="hljs-number">10.0</span>,<span class="hljs-number">2.5</span>]
</code></pre><pre><code class="lang-haskell">sequenceA :: (Applicative f) =&gt; <span class="hljs-string">[f a]</span> -&gt; f <span class="hljs-string">[a]</span>
sequenceA <span class="hljs-string">[]</span> = pure <span class="hljs-string">[]</span>
sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs
</code></pre>
<pre><code class="lang-haskell">ghci&gt; sequenceA [Just <span class="hljs-number">3</span>, Just <span class="hljs-number">2</span>, Just <span class="hljs-number">1</span>]
Just [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
ghci&gt; sequenceA [Just <span class="hljs-number">3</span>, Nothing, Just <span class="hljs-number">1</span>]
Nothing
ghci&gt; sequenceA [(+<span class="hljs-number">3</span>),(+<span class="hljs-number">2</span>),(+<span class="hljs-number">1</span>)] <span class="hljs-number">3</span>
[<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]
{-
    f = a-&gt;b
    sequenceA ::[a-&gt;b] -&gt; a-&gt;[b]
-}
ghci&gt; sequenceA [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]
[[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]]
</code></pre>
<h1 id="lezione-16-monadi">Lezione 16 - Monadi</h1>
<p>-- Assente --</p>
<p><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Funtori, applicativi e monadi</a></p>
<pre><code class="lang-haskell">data Maybe <span class="hljs-literal">a</span> = Nothing | Just <span class="hljs-literal">a</span>
</code></pre>
<p><code>Maybe</code> è un datatype di default che è sia un funtore, sia un applicativo che una monade e verrà utilizzato per fare i vari esempi. </p>
<h2 id="funtori">Funtori</h2>
<p>Permettono di esegurie delle funzioni su valori che sono raccolti all&#39;interno di un contesto.</p>
<p>Perché un tipo si comporti come funtore, deve istanziare la typeclass <code>Functor</code> fornendo una definizione per la funzione <code>fmap</code>:</p>
<pre><code class="lang-haskell">instance Functor Maybe where
    fmap <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Just val)</span> = <span class="hljs-title">Just</span> <span class="hljs-params">(func val)</span></span>
    fmap <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nothing</span> = <span class="hljs-title">Nothing</span></span>
</code></pre>
<p>Un esempio di utilizzo è dato da</p>
<pre><code class="lang-haskell">&gt; fmap <span class="hljs-list">(<span class="hljs-keyword">+3</span>)</span> <span class="hljs-list">(<span class="hljs-keyword">Just</span> <span class="hljs-number">2</span>)</span>
Just <span class="hljs-number">5</span>
</code></pre>
<p>che è equivalente a scrivere</p>
<pre><code class="lang-haskell">&gt; (+<span class="hljs-number">3</span>) &lt;$&gt; Just <span class="hljs-number">2</span>
Just <span class="hljs-number">5</span>
</code></pre>
<p>Le funzioni in Haskell sono a loro volta dei funtori, così come le liste.</p>
<h2 id="applicativi">Applicativi</h2>
<p>Funtori particolare che possono racchiudere anche delle funzioni.</p>
<pre><code class="lang-haskell">&gt; (+) &lt;$&gt; (Just <span class="hljs-number">5</span>)
Just (+<span class="hljs-number">5</span>)
&gt; Just (+<span class="hljs-number">5</span>) &lt;*&gt; (Just <span class="hljs-number">3</span>)
Just <span class="hljs-number">8</span>
&gt; (*) &lt;$&gt; Just <span class="hljs-number">5</span> &lt;*&gt; Just <span class="hljs-number">3</span>
Just <span class="hljs-number">15</span>
</code></pre>
<p>Perché un tipo di comporti come applicativo deve istanziale la typeclass <code>Applicative</code></p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-container">(<span class="hljs-type">Functor</span> <span class="hljs-title">f</span>)</span> =&gt; <span class="hljs-type">Applicative</span> f <span class="hljs-keyword">where</span></span>  
    pure :: a -&gt; f a  
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>Ad esempio <code>Maybe</code> è definito in questo modo</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>  
    pure = <span class="hljs-type">Just</span>  
    <span class="hljs-type">Nothing</span> &lt;*&gt; _ = <span class="hljs-type">Nothing</span>  
    (<span class="hljs-type">Just</span> f) &lt;*&gt; something = fmap f something
</code></pre>
<h2 id="monadi">Monadi</h2>
<p>Le monadi permetto di estrarre il valore da un contesto e di applicarci una funzione che ritorna una monade contenente il risultato dell&#39;applicazione della funzione.</p>
<p>Data la funzione <code>half</code> che dato un intero restituisce un valore <code>Maybe</code> contenente la metà del valore dato.</p>
<pre><code class="lang-haskell">half x = <span class="hljs-keyword">if</span> even x
           <span class="hljs-keyword">then</span> Just (x `<span class="hljs-keyword">div</span>` <span class="hljs-number">2</span>)
           <span class="hljs-keyword">else</span> Nothing
</code></pre>
<p>Non è possibile invocare <code>half (Just 2)</code>.</p>
<p>Tuttavia usando le monadi si riesce ad eseguire le seguenti operazioni:</p>
<pre><code class="lang-haskell">&gt; <span class="hljs-constant">Just</span> <span class="hljs-number">3</span> <span class="hljs-prompt">&gt;&gt;= </span>half
<span class="hljs-constant">Nothing</span>
&gt; <span class="hljs-constant">Just</span> <span class="hljs-number">4</span> <span class="hljs-prompt">&gt;&gt;= </span>half
<span class="hljs-constant">Just</span> <span class="hljs-number">2</span>
&gt; <span class="hljs-constant">Nothing</span> <span class="hljs-prompt">&gt;&gt;= </span>half
<span class="hljs-constant">Nothing</span>
</code></pre>
<p>Una monade è quindi una typeclass che richiede la definzione della funzione <code>&gt;&gt;=</code>:</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monad</span> <span class="hljs-title">m</span> <span class="hljs-title">where</span></span>
    <span class="hljs-function"><span class="hljs-params">(&gt;&gt;=)</span> :: <span class="hljs-title">m</span> <span class="hljs-title">a</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(a -&gt; m b)</span> -&gt;</span> m b
</code></pre>
<p>Una funzione che data una monade e una funzione applicabile al contenuto della monade, ritorna una nuova monade conentene la funzione applicata al valore iniziale.</p>
<p><code>Maybe</code> definisce la funzione in questo modo</p>
<pre><code class="lang-haskell">instance Monad Maybe where
    <span class="hljs-typename">Nothing</span> &gt;&gt;= func = <span class="hljs-typename">Nothing</span>
    Just <span class="hljs-variable"><span class="hljs-keyword">val</span> &gt;&gt;</span>= func  = func <span class="hljs-variable"><span class="hljs-keyword">val</span></span>
</code></pre>
<p>In questo modo è possibile concatenare l&#39;esecuzione delle funioni:</p>
<pre><code class="lang-haskell">&gt; <span class="hljs-constant">Just</span> <span class="hljs-number">20</span> <span class="hljs-prompt">&gt;&gt;= </span>half &gt;&gt;= half &gt;&gt;= half
<span class="hljs-constant">Nothing</span>
</code></pre>
<h3 id="typeclass-monad">Typeclass Monad</h3>
<p>La typeclass precedenemente riportata non è completa.</p>
<p>La versione corretta è:</p>
<pre><code class="lang-haskell">class Monad m where  
    return :: <span class="hljs-tag">a</span> -&gt; m <span class="hljs-tag">a</span>  

    (&gt;&gt;=) :: m <span class="hljs-tag">a</span> -&gt; (<span class="hljs-tag">a</span> -&gt; m b) -&gt; m <span class="hljs-tag">b</span>  

    (&gt;&gt;) :: m <span class="hljs-tag">a</span> -&gt; m <span class="hljs-tag">b</span> -&gt; m <span class="hljs-tag">b</span>  
    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y  

    fail :: String -&gt; m <span class="hljs-tag">a</span>  
    fail msg = error msg
</code></pre>
<p><code>return</code> permette di creare una monade a partire da un valore.</p>
<p><code>&gt;&gt;</code> è una cosa strana e poco usata, viene implementata di default.</p>
<h3 id="esempio-d-uso-delle-monadi">Esempio d&#39;uso delle monadi</h3>
<pre><code class="lang-haskell">type Birds = <span class="hljs-built_in">Int</span>
type Pole = (Birds, Birds)


landLeft :: Birds -&gt; Pole -&gt; Maybe Pole
landLeft n (<span class="hljs-built_in">left</span>,<span class="hljs-built_in">right</span>)
    | <span class="hljs-built_in">abs</span> ((<span class="hljs-built_in">left</span> + n) - <span class="hljs-built_in">right</span>) &lt; <span class="hljs-number">4</span> = Just (<span class="hljs-built_in">left</span> +n , <span class="hljs-built_in">right</span>)
    | otherwise                    = <span class="hljs-literal">Nothing</span> 

landRight :: Birds -&gt; Pole -&gt; Maybe Pole
landRight n (<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>)
    | <span class="hljs-built_in">abs</span> ((<span class="hljs-built_in">right</span> + n) - <span class="hljs-built_in">left</span>) &lt; <span class="hljs-number">4</span> = Just (<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span> + n)
    | otherwise                    = <span class="hljs-literal">Nothing</span>
</code></pre>
<p>È possibile concatenare l&#39;esecuzione di queste funzioni utilizzando le monadi:</p>
<pre><code class="lang-haskell">Main&gt; <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &gt;&gt;= landLeft <span class="hljs-number">2</span>
Just (<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)
Main&gt; <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &gt;&gt;= landLeft <span class="hljs-number">2</span> &gt;&gt;= landRight <span class="hljs-number">2</span>
Just (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
Main&gt; <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &gt;&gt;= landLeft <span class="hljs-number">2</span> &gt;&gt;= landRight <span class="hljs-number">2</span> &gt;&gt;= landRight <span class="hljs-number">4</span>
Nothing
Main&gt; <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &gt;&gt;= landLeft <span class="hljs-number">2</span> &gt;&gt;= landRight <span class="hljs-number">2</span> &gt;&gt;= landRight <span class="hljs-number">4</span> &gt;&gt;= landLeft <span class="hljs-number">2</span>
Nothing
</code></pre>
<h1 id="lezione-17-introduzione-parte-2-correzione-parziale">Lezione 17 - Introduzione parte 2 + Correzione parziale</h1>
<p>Nelle prossime puntante:</p>
<ul>
<li>I linguaggi OO</li>
<li>Il lato oscuro del C++</li>
<li>Il lato positivo di Java</li>
<li>Il lato oscuro di Java (Generics)</li>
<li>Lazy evalation di Haskell</li>
<li>(an c&#39;è anche il progetto)</li>
</ul>
<p>Con i linguaggi funzionali è possibile &quot;imitare&quot; il concetto di oggetti sfruttando il l&#39;upward fun result che copia nello heap un record di attivazione che può contenere dei valori, i quali possono essere considerati sia come attributi che come metodi dell&#39;oggetto.</p>
<p>Si riesce così ad ottenere sia un sistema di incapsulamento (o astrazione) e anche il polimorfismo parametrico.</p>
<p>Perché un linguaggio sia considerato OO deve avere le seguenti caratteristiche:</p>
<ul>
<li>dynamic lookup</li>
<li>astrazione</li>
<li>sottotipaggio</li>
<li>ereditarietà</li>
</ul>
<hr>
<h1 id="correzione-primo-paziale">Correzione primo paziale</h1>
<h2 id="domanda-1">Domanda 1</h2>
<pre><code> <span class="hljs-number">1</span> [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, E]
 <span class="hljs-number">2</span> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, A]
 <span class="hljs-number">3</span> [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, x=<span class="hljs-number">2</span>]
 <span class="hljs-number">4</span> [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, y=<span class="hljs-number">3</span>]
 <span class="hljs-number">5</span> [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, h = (<span class="hljs-number">5</span>,h)]
 <span class="hljs-number">6</span> [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, f0 = (<span class="hljs-number">6</span>,f0)]
 <span class="hljs-number">7</span> [<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, r = <span class="hljs-number">2</span>]
 <span class="hljs-number">8</span> [<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, q = (<span class="hljs-number">8</span>,q)]
 <span class="hljs-number">9</span> [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, w1 = _]
<span class="hljs-number">10</span> [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, rit=<span class="hljs-string">"prox istruzione"</span>, rit=CL-&gt;w1, f0y=_] <span class="hljs-comment">//Invocazione di q</span>
<span class="hljs-number">11</span> [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-function">handle <span class="hljs-title">A</span><span class="hljs-params">(x)</span></span>=&gt;x]
<span class="hljs-number">12</span> [<span class="hljs-number">11</span>, <span class="hljs-number">6</span>, rit=<span class="hljs-string">"handle di q"</span>, ris=CL-&gt;CL-&gt;f0y, x=<span class="hljs-number">3</span>, z=<span class="hljs-number">5</span>, f1=(<span class="hljs-number">12</span>,f1)] <span class="hljs-comment">//invocazione di f0(3)</span>
</code></pre><p>Viene eseguita <code>f0</code> che ritorna <code>(12,f1).</code>
Dovrebbe essere tolto il record 12 dalla pila, ma contiene la definizione di una funzione, quindi deve essere spostato nello heap.</p>
<pre><code><span class="hljs-number">12</span>* [<span class="hljs-number">11</span>, <span class="hljs-number">6</span>, rit=<span class="hljs-string">"handle di q"</span>, ris=CL-&gt;CL-&gt;f0y, x=<span class="hljs-number">3</span>, z=<span class="hljs-number">5</span>, f1=(<span class="hljs-number">12</span>*,f1)] <span class="hljs-comment">//invocazione di f0(3)</span>
</code></pre><p>Viene fatto il pop di 12 e 11.
Continua l&#39;esecuzione di q con il record 10 in cima.</p>
<pre><code><span class="hljs-number">10</span> [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, rit=<span class="hljs-string">"prox istruzione"</span>, rit=CL-&gt;w1, f0y=(<span class="hljs-number">12</span>*)] <span class="hljs-comment">//Invocazione di q</span>
</code></pre><p>L&#39;esecuzione di <code>q</code> termina, ritornando il valore <code>(12*,f1)</code>, dopodiché viene fatto il pop di 10.</p>
<p>L&#39;esecuzione del programma riparte con il record 9 in cima.</p>
<pre><code> <span class="hljs-number">9</span> [<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, w1 = (<span class="hljs-number">12</span>*,f1)]
<span class="hljs-number">10</span> [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>, p=(<span class="hljs-number">10</span>,p)]
<span class="hljs-number">11</span> [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, w2= _]
<span class="hljs-number">12</span> [<span class="hljs-number">11</span>, <span class="hljs-number">10</span>, rit=<span class="hljs-string">"fine programma"</span>, ris=CL-&gt;w2, w1x=_, xr=_] <span class="hljs-comment">//p()</span>
<span class="hljs-number">13</span> [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(x)</span> </span>= x*y | A(x)=&gt; x(r)]
<span class="hljs-number">14</span> [<span class="hljs-number">13</span>, <span class="hljs-number">12</span>*, rit=<span class="hljs-string">"handle di p"</span>, ris=CL-&gt;CL-&gt;w1x, z1=<span class="hljs-number">2</span>, f2=(<span class="hljs-number">14</span>,f2), hf2=_]<span class="hljs-comment">//w1(x)</span>
<span class="hljs-number">15</span> [<span class="hljs-number">14</span>, <span class="hljs-number">5</span>, rit=<span class="hljs-string">"fine di f1"</span>, ris=CL-&gt;hf2, a=(<span class="hljs-number">14</span>,f2), ax=_, ay2=_] <span class="hljs-comment">//h(f2)</span>
<span class="hljs-number">16</span> [<span class="hljs-number">15</span>, <span class="hljs-number">14</span>, rit=<span class="hljs-string">"condizione di h"</span>, ris=CL-&gt;ax, z2=<span class="hljs-number">2</span>, xy=_]<span class="hljs-comment">//a(x)</span>
<span class="hljs-number">17</span> [<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(x)</span> </span>=&gt; x+<span class="hljs-number">2</span> | A(x) =&gt; x(y)]
</code></pre><p>Esegue il corpo di <code>f2</code> che fa il test <code>x+z2 = z</code>, <code>z2</code> vale 2, <code>x</code> vale 3, <code>z</code> vale 5 (parametro formale di <code>f0</code>).
Viene quindi eseguito il primo ramo dell&#39;if, che ritorna <code>z2</code>.</p>
<p>Viene quindi fatto il pop di 17 e 16.
Continua quindi l&#39;esecuzione del corpo di h con il record 15 in cima.</p>
<pre><code><span class="hljs-number">15</span> [<span class="hljs-number">14</span>, <span class="hljs-number">5</span>, rit=<span class="hljs-string">"fine di f1"</span>, ris=CL-&gt;hf2, a=(<span class="hljs-number">14</span>,f2), ax=<span class="hljs-number">2</span>, ay2=_] <span class="hljs-comment">//h(f2)</span>
</code></pre><p>Il test dell&#39;if di <code>h</code> viene valutato vero, viene quindi eseguito il raise di <code>A(a)</code>.</p>
<p>Viene fatto il pop di 15 e 14, tuttavia il record 14 contiene la definzione di a quindi deve essere copiato nello heap.</p>
<pre><code><span class="hljs-number">14</span>* [<span class="hljs-number">13</span>, <span class="hljs-number">12</span>*, rit=<span class="hljs-string">"handle di p"</span>, ris=CL-&gt;CL-&gt;w1x, z1=<span class="hljs-number">2</span>, f2=(<span class="hljs-number">14</span>*,f2), hf2=_]<span class="hljs-comment">//w1(x)</span>
</code></pre><p>Viene trovato un handler nel record 13, di conseguenza viene eseguito il pop di 13 ed eseguito l&#39;handler con il record 12 in cima alla pila.</p>
<pre><code><span class="hljs-number">12</span> [<span class="hljs-number">11</span>, <span class="hljs-number">10</span>, rit=<span class="hljs-string">"fine programma"</span>, ris=CL-&gt;w2, w1x=_, xr=_] <span class="hljs-comment">//p()</span>
<span class="hljs-number">13</span> [<span class="hljs-number">12</span>, <span class="hljs-number">14</span>*, rit=<span class="hljs-string">"fine di p"</span>, ris=CL-&gt;xr, z2=<span class="hljs-number">2</span>, xy=_] <span class="hljs-comment">//x(r)</span>
<span class="hljs-number">14</span> [<span class="hljs-number">13</span>, <span class="hljs-number">13</span>, <span class="hljs-function">handle <span class="hljs-title">E</span><span class="hljs-params">(x)</span> </span>= x+y | A(x)=&gt; x(r)]
</code></pre><p>Si esegue il corpo di <code>f2</code> con <code>x+z2=z</code>, <code>x=3</code>, <code>z=5</code>, <code>z2=2</code>, il test viene valutato vero, viene quindi ritornato <code>z2=2</code>.</p>
<p>Viene quindi fatto il pop di 14 e 13. Con 12 in cima alla pila viene riprende l&#39;esecuzione di p.</p>
<pre><code><span class="hljs-number">12</span> [<span class="hljs-number">11</span>, <span class="hljs-number">10</span>, rit=<span class="hljs-string">"fine programma"</span>, ris=CL-&gt;w2, w1x=_, xr=<span class="hljs-number">2</span>] <span class="hljs-comment">//p()</span>
</code></pre><p>L&#39;esecuzione di <code>p</code> termina ritornano il valore 2, portando anche alla terminazione del programma.
Inoltre è possibile rimuovere il record <code>14*</code> dallo heap.</p>
<p>I valori di <code>w1</code> e <code>w2</code> sono:</p>
<ul>
<li><code>w1 = (12*,f1)</code></li>
<li><code>w2 = 2</code></li>
</ul>
<p>Dentro f2 vengono utilizzati gli indirizzi:</p>
<ul>
<li>x: AL-&gt;AL-&gt;x</li>
<li>y: AL-&gt;AL-&gt;AL-&gt;CL-&gt;CL-&gt;y</li>
<li>z: AL-&gt;AL-&gt;z</li>
<li>z2: EP-&gt;z2</li>
</ul>
<p>(La mancanza di EP per x, y e z è dovuta al fatto che i record per gli handle sono &quot;farlocchi&quot; quindi conviene ometterli, in ogni caso se li mettiamo cambia poco).</p>
<p>Il codice che esegue la prima parte di h:</p>
<pre><code><span class="hljs-comment">//Costruzione del RA per l'esecuzione di h</span>
<span class="hljs-number">1</span>. metti EP-&gt;CL-&gt;CL-&gt;x <span class="hljs-keyword">in</span> r0
<span class="hljs-number">2</span>. sia (c,d) il valore <span class="hljs-tag">del</span> parametro formale <span class="hljs-tag">a</span>.
<span class="hljs-number">3</span>. push RA di <span class="hljs-number">6</span> posizioni sulla pila e ci scriviamo:
    - <span class="hljs-number">0</span>: EP
    - <span class="hljs-number">1</span>: AL = c
    - <span class="hljs-number">2</span>: istruzione K di questo codice.
    - <span class="hljs-number">3</span>: <span class="hljs-keyword">in</span> *EP-&gt;<span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(x)</span></span> (dereferenzio EP, cioè prendo il valore <span class="hljs-tag">del</span> campo CL <span class="hljs-tag">del</span> record e poi vado su <span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(x)</span></span>)
    - <span class="hljs-number">4</span>: load r0
    - <span class="hljs-number">5</span>: <span class="hljs-function"><span class="hljs-title">x</span><span class="hljs-params">(y)</span></span>=_
<span class="hljs-number">4</span>. EP=EP+<span class="hljs-number">6</span>
<span class="hljs-number">5</span>. jump d <span class="hljs-comment">//invocazione di a</span>
K. ...
K+<span class="hljs-number">1</span>. esegue il confronto tra <span class="hljs-function"><span class="hljs-title">a</span><span class="hljs-params">(x)</span></span> e la variabile globale x.
</code></pre><h2 id="domanda-2">Domanda 2</h2>
<pre><code>f g <span class="hljs-number">1</span> = <span class="hljs-number">1</span>
f g x = x * <span class="hljs-list">(<span class="hljs-keyword">g</span> <span class="hljs-list">(<span class="hljs-keyword">x</span> - <span class="hljs-number">1</span>)</span>)</span>
</code></pre><p><code>1</code> ha come tipo Num non Int.</p>
<p>Il tipo finale viene quindi <code>(Num -&gt; Num) -&gt; Num -&gt; Num</code>.</p>
<h2 id="domanda-3">Domanda 3</h2>
<p>Funtori applicativi in haskell</p>
<pre><code class="lang-haskell">class (Functor f) =&gt; Applicative f where    
    pure :: <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">a</span>
    (&lt;*&gt;) :: f (<span class="hljs-tag">a</span> -&gt; b) -&gt; f <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">b</span> 
    (&lt;$&gt;) :: (<span class="hljs-tag">a</span> -&gt; b) -&gt; f <span class="hljs-tag">a</span> -&gt; f <span class="hljs-tag">b</span> -- non obbligatoria
</code></pre>
<h2 id="domanda-4">Domanda 4</h2>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> <span class="hljs-type">Applicative</span> [] <span class="hljs-keyword">where</span></span>
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]
</code></pre>
<h2 id="domanda-5">Domanda 5</h2>
<ul>
<li>Göedel: solo alcune funzioni sono calcolabili (terminazione della macchina di turing)</li>
<li>Tesi di Church: tutte le funzioni parziali ricorsive sono calcolabili</li>
<li>I linguaggi moderni calcolano tutte le funzioni calcolabili e quindi questo non può essere utilizzato come criterio di confronto</li>
<li>Le proprietà &quot;interessanti&quot; dei linguaggi di programmazione non sono calcolabili, bisogna quindi apporsimarle con tecniche di analisi statica.</li>
</ul>
<h1 id="lezione-18-programmazione-oo">Lezione 18 - Programmazione OO</h1>
<h2 id="dynamic-lookup">Dynamic Lookup</h2>
<p>Detto anche binding dinamico o polimorfismo di sotto-tipo, stabilisce come vengono selezionati i metodi di un oggetto.</p>
<p>In C++ e Java si parla di invocazione di un metodo di un oggetto, mentre in Smalltalk si parla di mandare un messaggio ad un oggetto <code>x-&gt;m(args)</code>.</p>
<p>Il dynamic lookup richiede che ad ogni esecuzione dell&#39;istruzione <code>x-&gt;m(args)</code>, il metodo <code>m</code> che viene eseguito sia deciso dal valore dinamico del tipo di <code>x</code>.</p>
<p>La stessa variabile infatti ha sempre un tipo statico e almeno un tipo dinamico:</p>
<ul>
<li><strong>Tipo statico</strong>: cioè il tipo definito dal compilatore (non cambia).</li>
<li><strong>Tipo dinamico</strong>: cioè il tipo determinato dal valore assegnato alla variabile durante l&#39;esecuzione del programma.</li>
</ul>
<p>Quindi, quando viene inviato un messaggio alla variabile <code>x</code> è il tipo dinamico che determina quale funzione viene invocata. Di conseguenza l&#39;istruzione <code>x-&gt;m(args)</code> può portare all&#39;invocazione di funzione diversa se cambia il tipo dinamico di <code>x</code>.</p>
<p>Il dynamic lookup è diverso dall&#39;<strong>overloading</strong>.</p>
<p>L&#39;overloading (sovraccaricamento) avviene con un polimorfiso <em>ad-hoc</em> e si basa sul tipo statico dei parametri passati ad un metodo, pertanto la funzione da eseguire viene decisa a compile-time.</p>
<p>In generale, data una collezione <em>C</em> di oggetti diversi, ognugno con il metodo <code>pippo</code>, è possibile mandare lo stesso messaggio <code>pippo</code> a tutti gli elementi della collezione. Si occuperà il compilatore di produrre il codice necessario affinché venga sempre eseguita la funzione corretta.</p>
<p>Da notare che non devono essere presenti particolari relazioni tra i vari oggetti, se non la presenza del metodo <code>pippo</code> in ognuno di essi. Non è quindi necessario che ci sia una gerarchia tra i vari tipi degli oggetti.</p>
<p>Effettuare il dynamic lookup richide un costo in termini di efficacia, pertanto è possibile scegliere di implementarlo per qualsiasi metodo oppure solo per alcuni metodi (metodi <strong>virtuali</strong> del c++).</p>
<p>È quindi possibile seguire due strategie:</p>
<ul>
<li>Fare quasi tutto a compile time, tranne per alcuni metodi virtuali, come fa il C++, ottenendo così delle prestazioni migliori;</li>
<li>Fare tutto a run-time, come fa Smalltalk.</li>
</ul>
<p>Il dynamic lookup può essere considerato come un overloading dinamico nel quale la valutazione del metodo da invocare viene fatta a runtime valutando il tipo dinamico dell&#39;oggetto.
Dal momento che <code>x-&gt;m(a,b)</code> equivale a <code>m(x,a,b)</code> e il dynamic lookup viene effettauato solo sul valore di <code>x</code>.</p>
<p>In alcuni linguaggi il dynamic lookp viene fatto su tutti gli argomenti del messaggio (es: Common Lisp Object System), ciò prende il nome di <strong>multiple dispatch</strong>.</p>
<p>Il multiple dispatch può essere utilizzato per implementare il test di uguaglianza in base al tipo dei due oggetti, creando però un incapsulamento più debole.</p>
<h2 id="astrazione">Astrazione</h2>
<p>Aka: incapsulamento.</p>
<p>È la capacità di nascondere i dettagli implementativi di un oggetto, creando una distinzione tra una parte pubblica (interfaccia) e una parte privata contenente i dettagli implementativi.</p>
<p>Inizialmente c&#39;era solamente il concetto di pubblico o privato, col tempo sono state poi aggiunte nuove tipologie di visibilità come package e protected.</p>
<p>L&#39;astrazione dipende dal linguaggio, ad esempio per Smalltalk tutti i campi dati sono privati e tutti i metodi sono pubblici</p>
<h2 id="subtyping">Subtyping</h2>
<p><code>A &lt;: B</code>, <code>A</code> è <strong>sotto tipo</strong> di <code>B</code>.</p>
<p>Ovvero dovunque serve un valore di tipo <code>B</code> è possibile utilizzare un oggetto di tipo <code>A</code>.</p>
<p>Il subtyping è una relazione di inclusione tra le interfacce di due tipi. Quindi se <code>A</code> è sotto tipo di <code>B</code>, tutti i metodi che posso invocare su <code>B</code> li posso anche invocare su <code>A</code>.</p>
<p>Vantaggi del subtyping:</p>
<ul>
<li>Permette di trattare in modo uniforme valori di tipo diverso.</li>
<li>Permette di avere una base comune per ogni oggetto.</li>
<li>Rende possibile aggiungere funzionalità senza cambiare il resto del programma.</li>
<li>Velocizza il prototipaggio.</li>
</ul>
<h2 id="ereditariet-">Ereditarietà</h2>
<p>L&#39;ereditarietà significa riutilizzo di codice. Ho una classe e voglio crearne una nuova riutilizzando almeno una parte del codice della classe che ho già.</p>
<p>Il subtyping riguarda le interfacce degli oggetti mentre l&#39;ereditìarietà riguarda l&#39;implementazione degli oggetti.</p>
<p>Lo stesso effetto dell&#39;ereditarietà si può ottenere duplicando il codice di una classe, ma usando l&#39;ereditarietà:</p>
<ul>
<li>Si evita il copia-incolla, diminuendo la possibilità che si verifichino errori.</li>
<li>Viene creato un legame tra la classe base e quelle che ereditano, in questo modo un cambiamento alla classe base si ripercuote automaticamente sulle classi che ereditano, evitando così il rischio di inconsistenze.</li>
</ul>
<h3 id="subtyping-e-ereditariet-sono-due-cose-diverse">Subtyping e Ereditarietà sono due cose diverse</h3>
<p>Si vogliono realizzare 2 tipi di coda:</p>
<ul>
<li>FIFO: push alla fine, pop all&#39;inizio.</li>
<li>LIFO: push e pop alla fine.</li>
</ul>
<p>Un modo poco ortodosso di farlo è quello di definire un tipo <code>doppia_coda</code> che permette di eseguire push e pop su entrambi gli estremi.</p>
<p>Si possono così definire LIFO e FIFO con l&#39;ereditarietà dalla classe doppia coda.</p>
<p>Ottenendo LIFO nascondendo tutti i metodi di <code>doppia_coda</code> e inserendo due nuovi metodi che permettono di invocare i due metodi di <code>doppia_coda</code> che interessano, ottenendo una classe con solo due metodi pubblici. Allo stesso modo è possibile definire FIFO.</p>
<p>In C++ è possibile fare ciò utilizzando la <strong>private inheritance</strong> e si aggiungno dei metodi pubblici.</p>
<p>Definendo così LIFO e FIFO si ottengo due classi che ereditano da <code>doppia_coda</code> ma che non hanno la stessa interfaccia.</p>
<p>Quindi è falso dire che <code>FIFO &lt;: doppia_coda</code> e <code>LIFO &lt;: doppia_coda</code>.</p>
<p>Infatti, il subtyping è una relazione sulle interfacce mentre l&#39;ereditarietà è una relazione sull&#39;implementazione dei metodi.</p>
<p>Alcuni linguaggi creano confusione perché l&#39;unico modo per ottenere il dynamic lookup in modo efficente, è legare il subtyping con l&#39;ereditarietà.</p>
<h2 id="storia-della-oop-simula-e-smalltalk">Storia della OOP - Simula e Smalltalk</h2>
<p>Simula nasce in Norvegia negli ultimi anni 60 progettato da Ole-Johan Dahl e Kristn Nygaard, due matematici che cercavano un modo per effettuare delle simulazioni basate su eventi.</p>
<p>I due tizi volevano fare qualcosa del genere:</p>
<pre><code>costruisci coda <span class="hljs-keyword">di</span> eventi <span class="hljs-literal">Q</span>
<span class="hljs-keyword">repeat</span>
    rimuovi <span class="hljs-keyword">e</span> da <span class="hljs-literal">Q</span>
    simula <span class="hljs-literal">e</span>
    metti i nuovi eventi <span class="hljs-keyword">in</span> <span class="hljs-literal">Q</span>
until Q vuota
</code></pre><p>C&#39;era quindi il bisogno di avere delle struttre dati che possono rappresentare eventi di vario tipo.</p>
<p>In questo caso è tornato utile anche il dynamic lookup per la scelta del metodo da invocare e il subtyping per i vari eventi che avevano un&#39;interfaccia comune.</p>
<p>In Simula sono presenti:</p>
<ul>
<li><strong>Classi</strong>: un funzione che restituisce il puntatore al suo record di attivazione (upward funresult problem).</li>
<li><strong>Oggetto</strong>: il record di attivazione che funziona da istanza della classe.</li>
</ul>
<p>Un oggetto contiene delle funzioni, cioè delle chiusure, e dei campi dati, entrambie presenti nel record di attivazione ritornato dalla classe.</p>
<p>Dal momento che si lavora con lo heap è stato previsto anche un garbage collector.</p>
<p>La versione prima versione <strong>Simula67</strong> prevede:</p>
<ul>
<li>Dynamic lookup</li>
<li>Inheritance e subtyping</li>
<li><strong>Inner</strong>: un metodo della classe base può essere marcato con la keyword inner per prevedere la chiamata ad un secondo metodo aggiuntivo della classe derivata, permettendo così di estendere il codice di un metodo della classe base.</li>
<li><strong>Inspect</strong>: permette di fare un test dinamico sul tipo di un dato a runtime.</li>
<li>Manca l&#39;incapsulation così come super/self.</li>
</ul>
<pre><code><span class="hljs-keyword">class</span> Point(x,y); real x,y;
<span class="hljs-keyword">begin</span>
    boolean <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">equals</span><span class="hljs-params">(r)</span>;</span> ref(Point) r;
        <span class="hljs-keyword">if</span> r =/= none <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">equals</span> := abs(x-r.x)+abs(y-r.y) &lt; <span class="hljs-number">0.00001</span>;

    real <span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">distance</span><span class="hljs-params">(p)</span>;</span> ref(Point) p;
        <span class="hljs-keyword">if</span> p == none <span class="hljs-keyword">then</span>
            error
        <span class="hljs-keyword">else</span>
            distance := sqrt((x-p.x)**<span class="hljs-number">2</span>+(y-p.y)**<span class="hljs-number">2</span>);
<span class="hljs-keyword">end</span>

...

p :- <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.5</span>);
</code></pre><p>Si può notare:</p>
<ul>
<li>La sintassi è molto influenzata da Algol60.</li>
<li>La presenza di puntatori per riferire altri oggetti.</li>
<li>Ogni metodo della classe ha di default un riferimento all&#39;oggetto.</li>
<li>Il fatto che la classe abbia due metodi implica che il record di attivazione conterrà due chiusure.</li>
<li>La funzione <code>Point</code> non ha corpo, serve solo per creare il record di attivazione da mettere nell heap.</li>
<li>La variabile <code>p</code> ha come tipo <code>ref(Point)</code>.</li>
<li>Ad ogni invocazione della funzione <code>Point</code> viene creato un nuovo record di attivazione che corrisponde all&#39;oggetto.</li>
</ul>
<p><img src="./notes/immagini/l18-ra.png" alt=""></p>
<p>In modo analogo funziona anche l&#39;invocazione del metodo di un oggetto</p>
<p><img src="./notes/immagini/l18-point.png" alt=""></p>
<h3 id="sottoclassi-e-subtyping">Sottoclassi e subtyping</h3>
<p>Il seguente codice permette di definire una classe <code>C2</code> che deriva da <code>C1</code>.</p>
<pre><code>class <span class="hljs-type">C1</span>
//dichiarazione

<span class="hljs-type">C1</span> class <span class="hljs-type">C2</span>
//dichiarazione aggiuntive

<span class="hljs-keyword">ref</span>(<span class="hljs-type">C2</span>) c2 = new <span class="hljs-type">C2</span>
</code></pre><p>La costruzione degli oggetti viene trattata come il ritorno di una funzione definita all&#39;interno di una funzione. In questo modo viene creato un record di attivazione per l&#39;oggetto della classe base e un altro record per l&#39;oggetto che estende la classe base.</p>
<p>Questo record avrà come access link l&#39;indirizzo del sotto oggetto della classe base.</p>
<p>Ad esempio </p>
<pre><code><span class="hljs-type">Point</span> class <span class="hljs-type">ColorPt</span>(c); color c;
begin
    boolean procedure equals(q); <span class="hljs-keyword">ref</span>(<span class="hljs-type">ColorPt</span>) q;
        ...
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">ref</span>(<span class="hljs-type">ColorPt</span>) cp = new <span class="hljs-type">ColorPt</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> giallo);
</code></pre><p><img src="./notes/immagini/l18-heap.png" alt=""></p>
<p>Da notare che <code>equals</code> di <code>ColorPt</code> copre l&#39;altro <code>equals</code> della classe <code>Point</code>, mentre quando viene eseguito il metodo <code>distance</code> che non è presente nella classe derivata, viene eseguito il metodo della classe base, raggiunto grazie all&#39;access link.</p>
<h1 id="lezione-19-oggetti-3">Lezione 19 - Oggetti 3</h1>
<p>Tutti gli oggetti vengono messi nello heap e vengono riferiti da una variabile presente nello stack.</p>
<p>È quindi necessario avere un sistema di garbage collection per togliere dallo heap gli oggetti che non servono più.</p>
<p>Quando si utilizzano oggetti di classe derivate, questi sono composti da un record di attivazione relativo all&#39;oggetto della classe base e da un secondo record di attivazione conenente le informazioni aggiuntive e con un riferimento al primo.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">ref</span>(<span class="hljs-type">Point</span>) p=new <span class="hljs-type">Point</span>(<span class="hljs-number">1</span>.<span class="hljs-number">1</span>,<span class="hljs-number">3</span>.<span class="hljs-number">0</span>); 
<span class="hljs-keyword">ref</span>(<span class="hljs-type">ColorPt</span>) cp= new <span class="hljs-type">ColorPt</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>.<span class="hljs-number">2</span>,red);
</code></pre>
<p>Per definzione un <code>ColorPoint</code> è un sotto tipo di <code>Point</code>, quindi al posto di un <code>Point</code> è possibile utilizzare <code>ColorPoint</code>.</p>
<p>Quindi:</p>
<pre><code class="lang-c++"><span class="hljs-attribute">p </span>:- cp; <span class="hljs-comment">//Assegnamento</span>
</code></pre>
<p>è un operazione legale per il subtyping, mentre</p>
<pre><code class="lang-c++"><span class="hljs-keyword">cp</span> :- p
</code></pre>
<p>è sempre legale ma serve un controllo a runtime per verificare che l&#39;oggetto puntato da <code>p</code> sia un <code>ColorPoint</code>, altrimenti è necessario sollevare un&#39;errore.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">ref</span>(<span class="hljs-type">Point</span>) r=new <span class="hljs-type">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); 
<span class="hljs-keyword">ref</span>(<span class="hljs-type">ColorPt</span>) cp= new <span class="hljs-type">ColorPt</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,red); 
r.distance(cp);
cp.distance(r);
r:-cp
r.distance(cp);
</code></pre>
<p>la memoria dopo la creazione dei due oggetti è:</p>
<pre><code class="lang-c++">HEAP:
<span class="hljs-number">1</span>* [AL=def P., x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>, equals=(<span class="hljs-number">1</span>*,eq), distance=(<span class="hljs-number">1</span>*,dist)]
<span class="hljs-number">2</span>* [AL=def P., x=<span class="hljs-number">3</span>, y=<span class="hljs-number">4</span>, equals=(<span class="hljs-number">2</span>*,eq), distance=(<span class="hljs-number">2</span>*,dist)]
<span class="hljs-number">3</span>* [AL=<span class="hljs-number">2</span>*, c=red, equals=(<span class="hljs-number">3</span>*,eq’)]

STACK
<span class="hljs-number">1</span>[CL=<span class="hljs-number">0</span>,AL=<span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>*]
<span class="hljs-number">2</span>[CL=<span class="hljs-number">1</span>,AL=<span class="hljs-number">1</span>, cp = <span class="hljs-number">3</span>*]
</code></pre>
<p>Per l&#39;esecuzione di <code>r.distance(cp)</code>, dove il tipo statico di <code>r</code> è <code>Point</code>, viene scelta come funzione da invocare <code>distance</code> di <code>Point</code>.</p>
<p>Tuttavia la funzione <code>distance</code> si aspetta un parametro di tipo <code>ref(Point)</code> ma riceve una variabile di tipo <code>ref(ColorPoint)</code>.</p>
<p>Quindi a runtime il codice di <code>distance</code> deve essere compatibile con <code>ColorPoint</code>. 
In particolare <code>ColorPoint</code> deve contere <code>x</code> e <code>y</code>, ma queste variabili non vengono trovate nel record puntato da <code>cp</code> e pertanto bisogna risalire utilizzando l&#39;access link per trovarle nel record corrispondente al sotto oggeto di tipo <code>Point</code>.</p>
<p>Un&#39;altra istruzione interessante è <code>cp.distance(r)</code>, dal momento che nel record puntato da <code>cp</code> non è presente <code>distance</code>, pertanto è necessario cercare la funzione utilizzando l&#39;access link.</p>
<p>Segue che gli oggetti della classe base e derivata hanno una forma diversa, quindi le operazioni da fare per raggiungere i campi dati possono essere stabilite solo a runtime.</p>
<p>A compile time è solo possibile definire delle strategie di ricerca per recuperare i vari valori e trattandosi di una ricerca a runtime alcuni errori possono non essere scoperti a compile time.</p>
<p>Ad esempio, l&#39;istruzione <code>cp.equals(r)</code> da un errore a runtime perché la funzione invocata ha bisogno di utilizzare dei campi dati che non sono presenti nell&#39;oggetto puntato da <code>r</code>.</p>
<p>Per rilevare questo errore il compilatore deve inserire un controllo di tipo a runtime.
Ma non è così semplice, perché possono verificarsi dei casi ancora più tricky:</p>
<pre><code class="lang-c++">r :- cp;
r<span class="hljs-built_in">.</span><span class="hljs-keyword">equals</span>(<span class="hljs-literal">new</span> Point(<span class="hljs-attribute">...</span>));
</code></pre>
<p>A compile time i tipi statici coincidono, però a runtime viene eseguita la funzione <code>equals</code> di <code>ColorPoint</code> e ciò porta ad un errore e non tutti i compilatori sono in grado di prevedere questo tipo di errori.</p>
<p>Quindi il compilatore può scegliere di mettere i controlli di tipo sempre oppure accontentarsi di non riscuiscre a mettere abbastanza controlli.</p>
<p><strong>Recall variance</strong> (?) Simula (ma anche Java) assume che se <code>B &lt;: A</code> allora anche <code>ref(B) &lt;: ref(A)</code>.</p>
<pre><code class="lang-c++">A class B; <span class="hljs-keyword">ref</span>(A) a; <span class="hljs-keyword">ref</span>(B) b;

<span class="hljs-keyword">proc</span> assignA(<span class="hljs-keyword">ref</span>(A) x) 
begin
    x:-a
<span class="hljs-keyword">end</span>;

assignA(b);
</code></pre>
<p>Questo crea un errore di tipo (<code>b</code> diventa di tipo <code>ref(A)</code>) che viene rilevato solo a tempo di esecuzione.</p>
<h2 id="smalltalk">Smalltalk</h2>
<p>Linguaggio completamente nuovo in cui ogni cosa è considerata come un oggetto, comprese le classi.</p>
<p><em>È proprio estremista come linguaggio, ha anche la cintura esplosiva</em></p>
<p>Tutte le operzioni venogno richieste inviando un messaggio ad un oggetto e l&#39;unico errore di tipo si verifica quando viene inviato ad un oggetto un messaggio che non è in grado di riconoscere.</p>
<p>Non sono quindi presenti tipi statici e il controllo dell&#39;errore viene fatto a runtime, rendendo la cosa molto inefficente.</p>
<p>In ogni caso è un linguaggio <strong>type-safe</strong> in quanto ogni errore di tipo viene segnalato, anche se questo viene rilevato solamente a runtime.</p>
<p>La definizione di una classe avviene in un modo simile alla compilazione di un form, mentre la definzione dei metodi è più strana</p>
<pre><code class="lang-obj-c"><span class="hljs-string">newX:</span>xval <span class="hljs-string">Y:</span>yval ||
    ^self <span class="hljs-keyword">new</span> <span class="hljs-string">x:</span>xval <span class="hljs-string">y:</span>yval
</code></pre>
<p>In questo caso si definisce il metodo <code>newX:Y:</code> che ha come corpo <code>self new...</code> cioè invia a <code>self</code> il messaggio <code>newx:y:</code>, <code>^</code> serve per ritornare un valore.</p>
<pre><code class="lang-obj-c">newOrigin ||
    ^self <span class="hljs-keyword">new</span> x:<span class="hljs-number">0</span> y:<span class="hljs-number">0</span>

initialize ||
    pi &lt;- <span class="hljs-number">3.1415926535897238653</span>
</code></pre>
<p>Altri metodi generici per la classe <code>Point</code> possono essere</p>
<pre><code class="lang-obj-c">x:xcord y:ycord <span class="hljs-string">||</span>
    x &lt;- xcord
    y &lt;- ycord

x <span class="hljs-string">|| ^x</span>
y <span class="hljs-string">|| ^y</span>
</code></pre>
<p>Il metodo <code>x || ^x</code> permette di accedere al valore di <code>x</code>. Questo metodo è necessario perché in Smalltalk tutti i campi dati sono privati.</p>
<pre><code class="lang-obj-c"><span class="hljs-tag">i</span> &lt; j ifTrue: [<span class="hljs-tag">i</span> + j] ifFalse:[j - <span class="hljs-number">1</span>]
</code></pre>
<p>In questo caso viene inviato a <code>i</code> il messaggio <code>&lt;</code> con argomento <code>j</code>.
La chiamata a questo metodo ritorna quindi un valore che può essere <code>True/False</code>.</p>
<p>Al valore ritornato dal metodo viene inviato il messaggio <code>ifTrue: [i + j] ifFalse:[j - 1]</code>, il quale in base al valore esegure il ramo then o else.</p>
<p>Questo perché sia <code>True</code>/<code>False</code> che i blocci di codice, come <code>[j-1]</code>,  sono degli oggetti che possono essere valutati.</p>
<pre><code class="lang-obj-c">index &lt;- 1.
<span class="hljs-keyword">[</span>index &lt;=<span class="hljs-instruction"> array </span>size]
    whileTrue: <span class="hljs-keyword">[</span>array at: index put:0. 
                index &lt;- index +1]
</code></pre>
<p>Il ciclo <code>while</code> viene implementato come un messaggio che viene invato al valore ritornato da <code>[index &lt;= array size]</code>.
Se viene ritornato <code>True</code> viene eseguito il corpo, dopodiché viene rieseguito il tutto.</p>
<p>La struttura di un <code>while</code> può essere schematizzata come:</p>
<pre><code class="lang-obj-c">{C = (A <span class="hljs-keyword">while</span>True: B)} = ^A <span class="hljs-keyword">if</span>True: B;C <span class="hljs-keyword">if</span>False: []
</code></pre>
<p>In Smalltalk anche i numeri sono degli oggetti, in particolare c&#39;è la classe <code>Integer</code> dalla quale derivano <code>small</code> e <code>big</code>.</p>
<p>Si può quindi definire una funzione <code>factorial</code> per <code>Integer</code>:</p>
<pre><code class="lang-obj-c">factorial ||
    self &lt;= <span class="hljs-number">1</span>
        ifTrue: [^<span class="hljs-number">1</span>]
        ifFalse: [^(self-<span class="hljs-number">1</span>) factorial * self]
</code></pre>
<p>In Smalltalk è presente anche un oggetto <code>super</code> che rappresenta la classe base, in questo modo quando si ridefinisce un metodo è comunque possibile richiedere l&#39;esecuzione del metodo originale delle classe base inviando lo stesso messaggio all&#39;oggetto <code>super</code>.</p>
<p>Dal momento che non ci sono tipi statici la scelta del metodo da invocare in risposta ad un determinato messaggio si basa solamente sul nome del metodo e il numero dei parametri, la combinazione <em>nome messaggio</em> e <em>arietà</em> prende il nome di <strong>selettore</strong>.</p>
<h3 id="rappresentazione-degli-oggetti">Rappresentazione degli oggetti</h3>
<p><img src="./notes/immagini/l19-oggetti.png" alt=""></p>
<p>Ci sono due parti, una parte principale relativa all&#39;oggetto di tipo <code>Point</code> che contiene i dati dell&#39;oggetto e un puntatore ad un altro oggetto che rappresenta la definizione della classe <code>Point</code>, la quale contiene tutte le altre informazioni come:</p>
<ul>
<li>un puntatore a <code>super</code></li>
<li>un puntatore alla tabella dei metodi, un altro oggetto che contiene tutti i metodi della classe e i riferimento al loro codice sorgente</li>
<li>un puntatore al template della classe.</li>
</ul>
<p>L&#39;oggetto template serve per permettere al codice di una classe derivata di risalire alla posizione delle variabili all&#39;interno di un oggetto della classe base e viceversa.</p>
<p><img src="./notes/immagini/l19-oggetto-2.png" alt=""></p>
<p>Da notare che la tabella dei metodi della classe <code>ColoredPoint</code> contiene solo i nuovi metodi, inoltre, l&#39;oggetto di tipo <code>ColoredPoint</code> contiene tutti i campi dati, compresi quelli della classe base.</p>
<p>Spiegando meglio l&#39;utilità del template: se ad un oggetto di una classe derivata invio un messaggio che esegue un metodo della classe base, questo metodo ha informazioni solamente riguardo la struttura della classe base e non di quella derivata, viene quindi utilizzato il template per risalire alla posizione della variabile all&#39;interno dell&#39;oggetto di classe derivata.
Questo perché i campi dati di una classe derivata possono avere un ordine diverso rispetto a quelli della classe base.</p>
<p>Quando viene inviato un messaggio ad un oggetto di classe derivata viene:</p>
<ol>
<li>Cercato il metodo nella tabella dei metodi per la classe derivata</li>
<li>Se non viene trovato, si cerca nella tabella della superclasse</li>
<li>Se non viene trovato, si continua a cercare nella gerarchia.</li>
</ol>
<p>Questo approccio è costosto, pertanto i linguaggi moderni utilizzano vari stratagemmi per velocizzare il processo.</p>
<h1 id="lezione-20-conformit-">Lezione 20 - Conformità</h1>
<p><em>gran parte della lezione è stata occupata dalla didscussione riguardo la didattica della laurea magistrale</em></p>
<p><strong>Che influenza ha la calcolabilità nei linguaggi di programmazione?</strong></p>
<p>Tesi Church fornisce la definizione di funzione calcolabile, cioè tutte le funzioni parziali ricorsive, che possono essere calcolate utilizzando vari approcci. Si tratta di una tesi e non un teorema perché si tratta di una semplice intuizione.</p>
<p>Tutti i linguaggi di programmazione che permettono l’iterazione e/o la ricorsione riescono a calcolare tutte le funzioni parziali ricorsive.</p>
<p>Inoltre, l’esistenza di funzioni non decidibili comporta che non è possibile calcolare alcune proprietà dei programmi, come la terminazione.
Quindi quando si progetta un compilatore c’è da tenere in considerazione che devono essere utilizzate delle approssimazioni di queste proprietà.</p>
<p>Esiste la tecnica di riduzione che permette di stabilire la decidibilità di un problema a partire da un problema che si sa essere non decidibile.</p>
<h2 id="conformit-">Conformità</h2>
<p>Si dice che due classi in gerarachia tra loro sono <strong>conformi</strong> quando i campi dati della classe derivata sono nello stesso ordine dei campi dati della classe base. </p>
<p>In Smalltalk non viene forzata la conformità ed è per questo che viene utilizzato il template. 
Se la conformità viene forzata dal compilatore, allora il template non è più necessario.</p>
<p>In Simula i campi dati di un oggetto si trovano nei vari record di attivazione che compongno l&#39;oggetto, garantendo così la conformità.
Un oggetto Smalltalk invece contiene tutti i campi dati, compresi quelli della classe base, quindi l&#39;ordine con il quale compaiono nella classe derivata può non essere conforme a quello della classe base.</p>
<p>In Smalltalk c&#39;è comunque bisogno di una ricerca a runtime quando viene richiesta l&#39;invocazione di un metodo che non è ridefinito nella classe base. Questo approcccio è costoso, però si possono migliorare le prestazioni tenendo una cache dei metodi invocati di recente (Java adotta questo approccio).</p>
<p>Tornando sul discorso della conformità, se viene imposta la conformità tra classe base e le sue derivate, allora quando viene modificata la classe base, devono essere ricompilate anche tutte le classi derivate.</p>
<p>In Smalltalk il subtyping e l&#39;ereditarietà sono indipendenti.</p>
<p>I tipi sono dati dall&#39;interfaccia delle classi, cioè dai messaggi che possono ricevere, quindi due oggetti che non sono in una relazione di erediterietà possono avere tra loro una relazione di subtyping.</p>
<p>Il legame tra erediterietà e subtyping esiste, ma non è né necessario né sufficente, questo perché in Smalltalk una classe derivata può evitare di ereditare dei metodi della classe base (<strong>ereditarietà selettiva</strong>).</p>
<h2 id="modulatit-">Modulatità</h2>
<p>Perché un linguaggio orientato agli oggetti sia <strong>puro</strong>, ogni classe deve poter essere sostituita da un suo sottotipo senza che il programma smetta di funzionare. Questa modularità deve essere garantita anche per le classi &quot;standard&quot; come quella degli interi.</p>
<p>Dal momento che Smalltalk è basato sull&#39;invio di messaggi, può essere considerato come un linguaggio puro, ottenendo però un programma più inefficente.</p>
<h1 id="lezione-21-c-">Lezione 21 - C++</h1>
<p>Lo scopo principale del linguaggio è quello di andare ad aggiungere caratteristiche OO al C restando comunque compatibile con il C puro.</p>
<p>Il C++ aggiunge anche un maggiore controllo statico dei tipi mantenendo comunque l&#39;efficenza del C, al punto che un programma C compilato dal compilatore C++ deve essere efficente come se fosse compilato da un compilatore C.</p>
<p><em>Se non si usa una caratteristica allora non si deve pagare per essa</em></p>
<p>Questo non vuol dire che i costrutti C devono essere tradotti come fa il compilatore C, ma solo che la loro efficenza deve essere la stessa.</p>
<p>In C++ non c&#39;è garbage collection, non per questioni di efficenza, in quanto poteva essere introdotta solo per gli oggetti, ma perché il C++ <strong>non è type-safe</strong> e pertanto non è possibile determinare se un determinato oggetto è inutile, questo perché ogni variabile intera può essere convertita in un puntatore. 
Quindi il vero problema è dato dalla presenza dei cast e non da questioni di efficenza.</p>
<h2 id="classi-in-c-">Classi in C++</h2>
<p>Le classi sono state implementate a partire dalle strutture, aggiungendo il concetto di astrazione.</p>
<p>Ci sono quindi delle variabili di tipo classe che non sono puntatori ad oggetti. Gli oggetti possono anche essere allocati nello stack dei record di attivazione ed esiste il concetto di assegnazione tra gli oggetti che va oltre all&#39;assegnamento dei puntatori.</p>
<h2 id="caratteristiche">Caratteristiche</h2>
<p>Il C++ è un linguaggio progettato bene che offre un buon controllo di tipi, tuttavia ci sono dei punti complessi e pertanto alcuni programmatori utilizzano solo parti del linguaggio. 
Oltretuttto, il C++ non impone un buono stile di programmazione, perché per esempio il vincolo dei tipi può essere raggirato.</p>
<p>Tra i vari miglioramenti al C, ci sono:</p>
<ul>
<li>Il tipo bool che può essere considerato come un intero</li>
<li>L&#39;utilizzo dei riferimenti per gli oggetti nello heap</li>
<li>Prevede l&#39;overloading di operatori e funzioni in base alla definizione dell&#39;utente</li>
<li>Template di funzione per ottenere il polimorfismo parametrico con le variabili di tipo</li>
<li>Oggetti</li>
<li>Eccezioni</li>
</ul>
<h2 id="la-parte-oo">La parte OO</h2>
<p>Noi ci contreremo di più nella parte legata agli oggetti. Tra le varie cose ci concetremo principalmente su:</p>
<ul>
<li>Classi</li>
<li>Oggetti</li>
<li>Dynamic lookup</li>
<li>Astrazione, con vari livelli di accessibilità: public, private e protected</li>
<li>Ereditarietà, che può essere singola o multipla</li>
<li>Subtyping, legato all&#39;ereditarietà ma non coincide con questa perché esiste anche l&#39;ereditarietà privata.</li>
</ul>
<p>L&#39;astrazione in C++ risulta molto buona, oltre ai 3 livelli di visibilità c&#39;è la possibilità di definire classi friend.</p>
<p>La relazione tra subtyping e ereditarietà sono tra loro collegate.</p>
<p>È presente il polimorfismo parametrico utilizzando le classi template.</p>
<p>Typechecking statico migliore rispetto a quello del C.</p>
<h3 id="il-lato-oscuro-del-c-">Il lato oscuro del C++</h3>
<p>La maggior parte dei problemi del C++ deriva dal vincolo della retrocompatibilità con il C.</p>
<p>Alcuni di questi sono:</p>
<ul>
<li>Cast e conversioni automatiche</li>
<li>Oggetti allocati sullo stack</li>
<li>Overloading (che risulta essere complicato)</li>
<li>Ridefinizione/Overriding: quando un metodo della classe astratta ha la stessa firma di un metodo della classe base. Solo che nel caso dell&#39;overriding la classe base ha marcato il metodo come virtuale. La ridefinizione è più generale. In C++ questi due concetti si sovrappongono e possono causare dei comportamenti inattesi.</li>
<li>Ereditarietà multipla, che causa un numero multiplo di problemi implementativi.</li>
</ul>
<p>Quando lo stesso programma utilizza overloading, overriding, ridefinizioni e dynamic lookup c&#39;è il rischio che la situazione diventi molto caotica.
Aggiungendo poi l&#39;ereditarietà multipla, il tutto diventa complesso sia da implementare che da capire.</p>
<h3 id="cast-e-conversioni">Cast e conversioni</h3>
<p>I cast permettono di eseguire delle operazioni <strong>type-unsafe</strong>, come la conversione da un intero a un puntatore.</p>
<p>In generale le conversioni tra puntatori non portano modifiche ai valori, viene solo cambiato il tipo del puntatore, che da quel momento in poi viene considerato di un tipo diverso, il valore del puntatore e il valore dell&#39;oggetto puntato non cambiano. </p>
<p>Con l&#39;ereditarietà multipla, il valore del puntatore deve essere modificato, questo perché quando si cambia il tipo di un puntatore ad una classe derivata al tipo di una classe base, il valore del puntatore deve essere modificato in modo che il puntatore riferisca il sotto-oggetto specifico.</p>
<p>Il programmatore deve quindi occuparsi di questioni tecniche legate al linguaggio.</p>
<h3 id="oggetti-allocati-sullo-stack">Oggetti allocati sullo stack</h3>
<p>Nei linguaggi ad oggetti come Simula e Smalltalk, gli oggetti vengono allocati solo sullo heap. 
In C++, gli oggetti possono essere allocati sia sullo heap che sullo stack, questo per mantere la retro compatibilità con il C.</p>
<p>Esiste quindi l&#39;assegnazione tra variabili di tipo classe, che è diversa dall&#39;assegnazione di due puntatori.</p>
<p>Quando si effettua un&#39;assegnazione tra una variabile di tipo derivato ad una variabile di tipo base si perde il subtyping in quanto l&#39;oggetto di classe derivata viene &quot;tagliato&quot; in modo che abbia la stessa dimensione dell&#39;oggetto di classe base e non si riesce quindi ad avere il dynamic lookup.</p>
<h3 id="il-punto-della-situazione">Il punto della situazione</h3>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> Pt{
    <span class="hljs-keyword">public</span>: <span class="hljs-comment">// metodi per leggere ma non modificare</span>
        Pt(<span class="hljs-keyword">int</span> xv);
        Pt(Pt* pv);
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx)</span></span>;
    <span class="hljs-keyword">protected</span>: <span class="hljs-comment">//metodo che cambia i dati</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xv)</span></span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// i dati sono privati</span>
        <span class="hljs-keyword">int</span> x;
} <span class="hljs-comment">// seguono le dichiarazioni dei costruttori e member functions </span>

...

Pt x=Pt(<span class="hljs-number">2</span>); <span class="hljs-comment">// sullo stack</span>
Pt * px=<span class="hljs-keyword">new</span> Pt(<span class="hljs-number">3</span>); <span class="hljs-comment">// sullo heap</span>
</code></pre>
<p>L&#39;invocazione dei metodi di una classe, come <code>getX()</code>, avviene nel classico modo, prima si fa il push del RA di <code>getX</code> e poi si fa il salto al codice della funzione.</p>
<p>Per i metodi <strong>virtuali</strong> come <code>move(int dx)</code> viene generato del codice diverso per permettere il dynamic lookup, questo perché il compilatore non riesce a stabilire qual&#39;è il metodo che verrà chiamato.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> ColorPt : <span class="hljs-keyword">public</span> Pt{ <span class="hljs-comment">// public inheritance ColorPt &lt;: Pt</span>
    <span class="hljs-keyword">public</span>:
        ColorPt(<span class="hljs-keyword">int</span> xv, <span class="hljs-keyword">int</span> cv);
        ColorPt(Pt* pv, <span class="hljs-keyword">int</span> cv);
        ColorPt(ColorPt * cp);
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">darken</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span>; <span class="hljs-comment">// nuova</span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx)</span></span>; <span class="hljs-comment">//overriding</span>
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cv)</span></span>; <span class="hljs-comment">// nuova</span>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> color;
}
</code></pre>
<p>I costruttori di <code>ColorPt</code> devono invocare quelli di <code>Pt</code> in modo da poter costruire il sotto-oggetto di classe base, inoltre il campo <code>x</code> di <code>Pt</code> è privato e non c&#39;è altro modo di assengarlo.</p>
<p>Ad esempio il costruttore di <code>ColorPt</code> può essere:</p>
<pre><code class="lang-c++">ColorPt(<span class="hljs-keyword">int</span> xv,<span class="hljs-keyword">int</span> cv) : Pt(xv)
{
    color=cv;
}
</code></pre>
<p><code>ColorPt</code> ha tutti i membri di <code>Pt</code> più o meno come se avessero la stessa specifica che hanno in <code>Pt</code>:</p>
<ul>
<li>i <code>public</code> sono visibili a tutti anche negli oggetti
<code>ColorPt</code></li>
<li>i <code>protected</code> sono visibili in <code>ColorPt</code> e nelle classi
derivate da <code>ColorPt</code></li>
<li>i <code>private</code> sono <code>private</code> anche negli oggetti <code>ColorPt</code>
ed quindi non sono accessibili dai nuovi metodi di
<code>ColorPt</code>, possono essere utilizzanti solo con i metodi di <code>Pt</code></li>
</ul>
<h3 id="dynamic-lookup">Dynamic lookup</h3>
<p>L&#39;overriding di un metodo virtuale può essere fatto con:</p>
<pre><code class="lang-c++"><span class="hljs-keyword">void</span> Pt::move(<span class="hljs-keyword">int</span> dx) {
    x=x+dx;
}
<span class="hljs-keyword">void</span> ColorPt::move(<span class="hljs-keyword">int</span> dx)
{
    Pt::move(dx);
    darken(<span class="hljs-number">1</span>);
}
</code></pre>
<p>Il dynamic lookup deve dipendere dal valore dinamico dell&#39;oggetto di invocazione, che è sconosciuto al compilatore. 
Per questo motivo viene utilizzata una <strong>vtable</strong> per ogni classe, cioè una tabella che contiene le informazioni riguardanti i metodi virtuali della classe.
La tabella contiene solamente i metodi virtuali perché l&#39;invocazione dei metodi non virtuali viene decisa a compile time.</p>
<p>Quindi ad ogni oggetto viene associato un record contenente un puntatore <code>vptr</code> che punta alla tabella dei metodi virtuali per la classe dell&#39;oggetto. </p>
<p><img src="./notes/immagini/l21-colorpt.png" alt=""></p>
<p>Per eseguire il metodo</p>
<pre><code class="lang-c++">Pt * p = <span class="hljs-keyword">new</span> Pt(<span class="hljs-number">3</span>);
p-&gt;move(<span class="hljs-number">2</span>);
</code></pre>
<p>il compilatore produce il codice </p>
<pre><code class="lang-c++"><span class="hljs-list">(<span class="hljs-keyword"><span class="hljs-built_in">*</span></span><span class="hljs-list">(<span class="hljs-keyword">p-&gt;vptr</span><span class="hljs-collection">[<span class="hljs-number">1</span>]</span> )</span>)</span> <span class="hljs-list">(<span class="hljs-keyword">p</span>,<span class="hljs-number">2</span>)</span>
</code></pre>
<p><em>Da notare che l&#39;indice della tabella dei metodi virtuali parte da 1 e non da 0. È una notazione del libro anche se si tratta di un libro di informatica.</em></p>
<p>Tutto questo perché non è possibile determinare il tipo dinamico dell&#39;oggetto puntato da <code>p</code>.
Tra l&#39;altro lo stesso codice prodotto dal compilatore funziona anche se l&#39;oggetto puntato da <code>p</code> è di tipo <code>ColorPt</code>, perché gli elementi della tabella dei metodi virtuali di una classe derivata hanno lo stesso ordine di quelli della tabella della classe base (sono <strong>conformi</strong>).</p>
<p><img src="./notes/immagini/l21-vtable-1.png" alt=""></p>
<p>In C++ l&#39;erediterietà è <strong>conforme</strong>, cioè sia i campi dati, sia i metodi virtuali che vengono ereditati, compaiono nello stesso ordine con il quale compaiono della classe base.</p>
<p>Così facendo è possibile evitare di utilizzare un puntantore al sotto-oggetto come succede con Smalltalk, racchiudendo tutte le informazioni di un oggetto o di una classe in uno stesso record.</p>
<p><em>Ripetendo il concetto:</em> la prima parte della vtable di una classe derivata conincide con l&#39;ordine dei metodi della vtable della classe base (<strong>vtable conformi</strong>).</p>
<p><img src="./notes/immagini/l21-vtable-2.png" alt=""></p>
<p>Questo permette di scrivere le seguenti istruzioni</p>
<pre><code class="lang-c++"> p = cp<span class="hljs-comment">; </span>
 p-&gt;move(2)<span class="hljs-comment">;</span>
</code></pre>
<p><img src="./notes/immagini/l21-vtable-3.png" alt=""></p>
<p>Il compilatore produce il codice <code>(*(p-&gt;vptr[1]))(p,2)</code> che funziona correttamente sia se l&#39;oggetto puntato da <code>p</code> è di tipo <code>Pt</code> sia se è di tipo <code>ColorPt</code>, questo grazie alla conformità delle vtable.</p>
<p>La stessa strategia non può funzionare in Smalltalk perché non essendoci un tipo statico il compilatore non riesce a farsi un idea di che tipo di oggetto potrebbe essere puntato, inoltre due oggetti di due classi in relazione gerarchica potrebbero avere lo stesso metodo in posizioni diverse a causa del fatto che Smalltalk non impone la conformità.</p>
<p>Volendo si potrebbe utilizzare una mega tabella con tutti i possibili metodi virtuali ma questa imporrebbe troppa rigidità e sarebbe troppo inefficente.</p>
<h3 id="dynamic-lookup-vs-overloading-overriding-ridefinzione">Dynamic lookup VS overloading/overriding/ridefinzione</h3>
<p><strong>Overloading</strong>: operatore/metodi con lo stesso nome e parametri formali con tipi diversi, la scelta dell&#39;operatore/metodo viene fatta a  compile time per ogni invocazione.</p>
<p><strong>Overriding</strong>: metodo di una sotto-classe con nome e tipo degli argomenti uguali a quelli di un metodo virtuale della classe base e il tipo del risultato può essere sotto-tipo.</p>
<p><strong>Ridefinizione</strong>: in una sotto-classe c&#39;è un metodo con lo stesso nome di un metodo della classe base che non è stato dichiarato come virtuale</p>
<h1 id="lezione-22-c-">Lezione 22 - C++++</h1>
<p><strong>Overloading</strong>: possono esserci più operatori o metodi che sono diversi ma che hanno lo stesso nome e hanno parametri formali con tipi diversi. Per scegliere quale metodo invocare il compilatore usa l&#39;algoritmo di <strong>overloading resolution</strong>, questo algoritmo viene eseguito a tempo di compilazione e non durante l&#39;esecuzione del codice.</p>
<p>L&#39;overloading resolution sceglie quindi il metodo meno costoso: ogni conversione ha un costo, vengono preferite le uguaglianze perfette, cioè quando c&#39;è già un match perfetto tra i tipi, vengono poi scelte le promozioni, il contrario delle promozioni o nel caso pessimo le conversioni definite dall&#39;utente. 
Nel caso di metodi con più parametri vengono calcolate delle tuple con i vari costi di conversione e viene scelta la tupla che ha tutti gli elementi minori o uguali delle altre.</p>
<p><strong>Overriding</strong>: quando il metodo di una sotto classe ha come nome e tipo degli argomenti uguali a quelli di un metodo virtuale della classe base. Il tipo del valore di ritorno può essere uguale oppure un sotto-tipo.</p>
<p><strong>Ridefinizione</strong>: in una sotto-classe c&#39;è un metodo che compare con lo stesso nome di un metodo della classe base, sia che sia virtuale che non. La ridefinzione comprende anche l&#39;overriding.</p>
<h2 id="la-scelta-del-metodo-da-invocare">La scelta del metodo da invocare</h2>
<p>Quando il compilatore deve compilare l&#39;istruzione</p>
<pre><code class="lang-c++">a-&gt;<span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(...)</span></span> <span class="hljs-comment">//a:A</span>
</code></pre>
<p>esegue l&#39;algoritmo di <strong>overloading resolution</strong> per determinare quale metodo deve venire invocato. 
Solo una volta completato l&#39;algoritmo il compilatore riesce a scoprire se il metodo da invocare è virtuale o meno. 
Se il metodo non è virtuale, il compilatore produce il codice di invocazione della funzione, altrimenti deve produrre il codice per la risoluzione dinamica dell&#39;invocazione.</p>
<p>Viene quindi utilizzato il tipo statico dell&#39;oggetto di invocazione per determinare se la risoluzione del metodo da invocare sarà statica o dinamica.</p>
<p>Ad esempio se il metodo <code>move(x)</code> è virutale il compitore produce il codice:</p>
<pre><code class="lang-c++">p-&gt;move<span class="hljs-list">(<span class="hljs-keyword">x</span>)</span> --&gt; <span class="hljs-list">(<span class="hljs-keyword">*</span><span class="hljs-list">(<span class="hljs-keyword">p-&gt;vptr</span>[<span class="hljs-number">1</span>])</span>)</span><span class="hljs-list">(<span class="hljs-keyword">p</span>,x)</span>
</code></pre>
<p>Da notare che anche i metodi non virtuali di una classe possono essere <strong>ridefiniti</strong> dalle classi derivate, ma in questo caso il metodo da chiamare viene scelto a compile time sulla base del tipo statico dell&#39;oggetto di invocazione.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> parent {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printclass</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"parent"</span>; }
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printvirtual</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"parent"</span>; }
};

<span class="hljs-keyword">class</span> child: <span class="hljs-keyword">public</span> parent {
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printclass</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"child"</span>; }
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printvirtual</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"child"</span>; }
};

main() {
    parent *p=<span class="hljs-keyword">new</span> parent(); 
    child *c=<span class="hljs-keyword">new</span> child();
    p-&gt;printclass(); <span class="hljs-comment">//stampa: parent, metodo statico</span>
    p-&gt;printvirtual(); <span class="hljs-comment">//stampa: parent, ma la decisione viene fatta a rutime</span>

    p=c; <span class="hljs-comment">//cambia il tipo dinamico di p, ma al compilatore questa cosa non interessa</span>
    p-&gt;printclass(); <span class="hljs-comment">//stampa: parent, è un metodo statico, l'invocazione viene scelta a compile time</span>
    p-&gt;printvirtual(); <span class="hljs-comment">//stampa: child, la decisione del metodo viene fatta in modo dinamico</span>
    c-&gt;printclass();  <span class="hljs-comment">//stampa: child, metodo statico</span>
}
</code></pre>
<p>Quando c&#39;è una ridefinizione dei metodi delle sottoclassi questi nascodono la definizione dei metodi delle classi base.</p>
<pre><code class="lang-c++"><span class="hljs-preprocessor"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl; }
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl; }
};

<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl; }
};

main()
{
 A* a=<span class="hljs-keyword">new</span> A;
 B* b=<span class="hljs-keyword">new</span> B;

 a-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//1, viene scelto f(int) che è un metodo statico</span>
 a-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//2, viene scelto f(double) che è un metodo virtuale, </span>
            <span class="hljs-comment">//il metodo effettivamente invocato viene scelto a runtime</span>

 a=b;

 b-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//3, viene scelto il metodo f(int) di B, è un metodo statico</span>
 b-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//3, viene scelto f(int) di B, in quanto la ridefinzione copre i metodi f della classe A.</span>

 a-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//1, viene scelto il metodo f(int) di A, </span>
            <span class="hljs-comment">// perché l'overloading resolution viene fatta solamente sui metodi di A</span>
 a-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//2, viene scelto il metodo f(double) di A, per lo stesso motivo di prima, </span>
            <span class="hljs-comment">// trattandosi di un metodo virtuale l'invocazione viene determinata a runtime, </span>
            <span class="hljs-comment">// in ogni caso viene invocato f(dobule) di A perché la classe B non fa l'overriding del metodo.</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> S1{<span class="hljs-keyword">int</span> a;};
<span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl;}};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(S1 a)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl;}
};

main(){ 
    A* a= <span class="hljs-keyword">new</span> A; B* b=<span class="hljs-keyword">new</span> B;
    a-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//1, f(int) di A con invocazione dinamica</span>
    a-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//2, f(double) di A con invocazione dinamica</span>

    a=b;

    b-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//Errore di compilazione, l'overloading resolution non trova nessun metodo da invocare in B</span>
    b-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//Errore di compilazione, l'overloading resolution non trova nessun metodo da invocare in B</span>

    a-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//1, f(int) di A con invocazione dinamica</span>
    a-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//2, f(double) di A con invocazione dinamica</span>

    <span class="hljs-comment">/* Vengono invocati i metodi di A perché B non fornisce nessun override per quei metodi */</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl; }
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl; }
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl; }
};

main() { 
    A* a= <span class="hljs-keyword">new</span> A; B* b=<span class="hljs-keyword">new</span> B;
    a-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//1, f(int) di A in modo dinamico</span>
    a-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//2, f(double) di A in modo dinamico</span>

    a=b;

    b-&gt;f(<span class="hljs-number">5</span>);   <span class="hljs-comment">//3, overloading resolution sceglie f(int) di B, con invocazione dinamica</span>
    b-&gt;f(<span class="hljs-number">5.0</span>); <span class="hljs-comment">//3, overloading resolution sceglie f(int) di B, con invocazione dinamica</span>

    a-&gt;f(<span class="hljs-number">5</span>);    <span class="hljs-comment">//3, l'overloading resolution sceglie f(int) di A, che è un metodo virtuale, </span>
                <span class="hljs-comment">// il tipo dinamico poi porta ad invocare il metodo f(int) di B.</span>
    a-&gt;f(<span class="hljs-number">5.0</span>);  <span class="hljs-comment">//2, l'overloading resolution sceglie f(double) di A, che è un metodo virtuale, </span>
                <span class="hljs-comment">// tuttavia B non fa l'overloading del metodo quindi viene eseguito il f(double) di A</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A {
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;}
};

<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl;}
};

main() {
 A* a;
 B* b=<span class="hljs-keyword">new</span> B;
 a=b;

 b-&gt;f(<span class="hljs-number">3</span>); <span class="hljs-comment">//2, l'overloading resulution su B trova solo f(float) viene quindi scelto quel metodo </span>
          <span class="hljs-comment">// con invocazione dinamica</span>

 a-&gt;f(<span class="hljs-number">3</span>); <span class="hljs-comment">//1, l'overloading resolution su A trova solo f(int) e viene scelto per l'invocazione </span>
          <span class="hljs-comment">// dinamica in quanto metodo virtuale. B non esegue l'override del metodo quindi viene </span>
          <span class="hljs-comment">// invocato f(int) di A.</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A {
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">2</span>&lt;&lt;endl;}
};

<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A { 
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">4</span>&lt;&lt;endl;}
};

main() {
    A* a= <span class="hljs-keyword">new</span> A; B *b=<span class="hljs-keyword">new</span> B;

    a-&gt;f(<span class="hljs-number">3.14f</span>); <span class="hljs-comment">//1, f(float) di A con dynamic lookup</span>
    b-&gt;f(<span class="hljs-number">3.14f</span>); <span class="hljs-comment">//3, f(double) di B con dynamic lookup</span>

    a=b;

    a-&gt;f(<span class="hljs-number">3.14f</span>); <span class="hljs-comment">//1, f(fload) di A con dynamic lookup</span>
    b-&gt;f(<span class="hljs-number">3</span>);     <span class="hljs-comment">//4, f(int) di B con dynamic lookup </span>
    a-&gt;f(<span class="hljs-number">3</span>);     <span class="hljs-comment">//4, l'overload resolution sceglie f(int) di A con dynamic lookup, </span>
                 <span class="hljs-comment">// a runtime viene eseguito f(int) di B</span>
}
</code></pre>
<p>Riassumento, quando in una sottoclasse viene definito un meotodo <code>f(..)</code>, questo nasconde all&#39;overloading resolution <strong>tutti i metodi</strong> della classe base. Questa scelta è stata fatta per semplificare l&#39;implementazione dell&#39;overloading resolution.</p>
<p>Un altra motivazione per questa scelta deriva dal fatto che tipicamente una classe derivata fa l&#39;override dei metodi della classe base ed effettuare una ridefinzione tipicamente è sbagliato.</p>
<h3 id="la-presenza-del-this">La presenza del this</h3>
<p>Supponiamo di avere</p>
<pre><code class="lang-c++">class A{
    public:
        virtual <span class="hljs-type">int</span> f(<span class="hljs-type">int</span> x);
        virtual <span class="hljs-type">int</span> g(<span class="hljs-type">int</span> y);
...
};
<span class="hljs-type">int</span> A::f(<span class="hljs-type">int</span> x)<span class="hljs-decorator">{...g(i)...}</span>
<span class="hljs-type">int</span> A::g(<span class="hljs-type">int</span> y)<span class="hljs-decorator">{...f(j)...}</span>
</code></pre>
<p>e che ci sia una sotto class <code>B</code> che ridefinisce <code>f</code> ma non <code>g</code>.</p>
<p>Se abbiamo <code>B* b=new B(); b-&gt;g(k)</code> viene ovviamente invocata la funzione <code>g</code> di <code>B</code>, ma se nel corpo di <code>g</code> invochiamo <code>f</code>, quale <code>f</code> viene invocata?</p>
<p>Deve essere quindi possibile utilizzare il dynamic lookup per invocare <code>B::f</code>, pertanto è necessario che il compilatore, quando compila un meotodo, aggiunga un riferimento all&#39;oggetto sul quale viene invocato il metodo:</p>
<pre><code class="lang-c++"><span class="hljs-type">int</span> A:: g( A* o, <span class="hljs-type">int</span> y)<span class="hljs-decorator">{...o-&gt;f(j)...}</span>
</code></pre>
<p>L&#39;oggetto di invocazione deve essere passato ad <strong>ogni</strong> metodo, sia che questo sia virtuale o meno.</p>
<p>Questo serve sia per chiamare a runtime le corrette funzioni virtuali, sia per accedere ai campi dati dell&#39;oggetto corrente.</p>
<p>Nel caso il metodo invocato sia non virtuale, il tipo statico dell&#39;oggetto serve al compilatore per stabilire quale funzione invocare e produrre il corretto <em>push+jump</em> per l&#39;esecuzione del codice.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{f(); <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-number">2</span>;}
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{f(); <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-number">4</span>;}};
main(){
    A*a; B* b=<span class="hljs-keyword">new</span> B();
    a=b;
    a-&gt;g(); <span class="hljs-comment">//l'overloading resolution secglie A::g() </span>
    <span class="hljs-comment">// che non è virtuale quindi viene scelto subito a compile time.</span>

    <span class="hljs-comment">//Dentro A::g viene invocata f sull'oggetto di invocazione</span>
    <span class="hljs-comment">//che ha tipo statico A, pertanto l'overloading resolution</span>
    <span class="hljs-comment">//sceglie A::f, viene quindi stampato "1 2"</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> x;
        A(<span class="hljs-keyword">int</span> y){x=y;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{f(); <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-number">2</span>&lt;&lt; x &lt;&lt;endl;}
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        B(<span class="hljs-keyword">int</span> y):A(y){}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{f(); <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-number">4</span> &lt;&lt; x&lt;&lt;endl;}
};

main(){
    A*a=<span class="hljs-keyword">new</span> A(<span class="hljs-number">5</span>); B* b=<span class="hljs-keyword">new</span> B(<span class="hljs-number">10</span>);
    a=b;
    a-&gt;g();
<span class="hljs-comment">/*
 Il tipo statico è A quindi viene fatto l'overloading resolution su A,
 viene trovato A::g che viene scelto per l'invoazione già a compile
 time in quanto non è virtuale.
 A::g esegue f e viene scelta A::f perché non è virtuale e come 
 valore di x viene usato 10, che è il valore del campo x del sotto
 oggetto di b.
*/</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> x;
        A(<span class="hljs-keyword">int</span> y){x=y;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">1</span>;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{f(); <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-number">2</span>&lt;&lt;x&lt;&lt;endl;}};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        B(<span class="hljs-keyword">int</span> y):A(y){}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">3</span>;}
};
main(){
    A*a=<span class="hljs-keyword">new</span> A(<span class="hljs-number">5</span>); B* b=<span class="hljs-keyword">new</span> B(<span class="hljs-number">10</span>);

    a-&gt;g(); <span class="hljs-comment">//1 2 5, sempre la solita storia</span>

    a=b;

    a-&gt;g();

 <span class="hljs-comment">/*
  Prima viene scelta A::g dall'overloading resolution.
  Poi viene scelta A::f che è virtuale, a runtime viene poi eseguita
  B::f e come valore di x viene stampato 10, che è il valore di x
  nell'oggetto b:
  1 3 10
 */</span>
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-keyword">int</span> x;
        A(<span class="hljs-keyword">int</span> y){x=y;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"A-int "</span>&lt;&lt;x&lt;&lt;endl;}
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>: 
        B(<span class="hljs-keyword">int</span> y):A(y){}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"B-int "</span>&lt;&lt;x&lt;&lt;endl;} 
};
main() {
    A a=A(<span class="hljs-number">2</span>); B b=B(<span class="hljs-number">10</span>); <span class="hljs-comment">//Sono nello stack, non nello heap</span>

    a.f(<span class="hljs-number">1</span>); <span class="hljs-comment">//A::f, funzione virutale che dovrebbe essere compilata con  indirezione</span>
            <span class="hljs-comment">//Stampa A-int 2</span>

    a=b; <span class="hljs-comment">//La vtable di a non cambia perché si tratta di un assegnazione</span>
         <span class="hljs-comment">//tra oggetti e non tra puntatori</span>

    a.f(<span class="hljs-number">1</span>); <span class="hljs-comment">//A::f, funzione virtuale ma la vtable non è cambiata</span>
            <span class="hljs-comment">//quindi a runtime viene invocata A::f e non B::f</span>
            <span class="hljs-comment">//Il campo dati x però è cambiato, viene quindi stampato</span>
            <span class="hljs-comment">// A-int 10</span>

    b.f(<span class="hljs-number">1</span>); <span class="hljs-comment">//B::f, funzione virtuale, viene stampato B-int 10</span>
}
</code></pre>
<pre><code class="lang-c++">class A{
    public: 
        <span class="hljs-type">int</span> x;
        virtual <span class="hljs-type">void</span> f(<span class="hljs-type">int</span> i)<span class="hljs-decorator">{...}</span>
        };
class B: public A{
    public:
        virtual <span class="hljs-type">void</span> f(<span class="hljs-type">int</span> i)<span class="hljs-decorator">{...}</span>
        virtual <span class="hljs-type">void</span> f(double)<span class="hljs-decorator">{...}</span> 
};
main() {
    A* a; B*b=new B(..); a=b, 
    a-&gt;f(<span class="hljs-number">3</span>.<span class="hljs-number">4</span>); //L'overloading resolution trova A::f(<span class="hljs-type">int</span>) che è virtuale
               //viene quindi predisposto il dynamic lookup che
               //a runtime invoca B::f(<span class="hljs-type">int</span>)
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>: 
        <span class="hljs-keyword">int</span> x;
        A(<span class="hljs-keyword">int</span> y){x=y;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"A-int"</span>&lt;&lt;endl;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">char</span> i)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"A-char"</span>&lt;&lt;endl;} 
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>: 
        B(<span class="hljs-keyword">int</span> y):A(y){}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"B-int"</span>&lt;&lt;endl;}};
main() {
    A* a=<span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>); B* b=<span class="hljs-keyword">new</span> B(<span class="hljs-number">10</span>);
    a-&gt;f(<span class="hljs-string">'a'</span>); 

    a=b; 

    a-&gt;f(<span class="hljs-string">'a'</span>); 
    <span class="hljs-comment">/*
     L'overloading resolution sceglie A::f(char) che è virtuale, 
     viene quindi predisposto il dynamic lookup.
     A runtime viene invocata A::f(char) perché B non fa l'override
     della funzione
    */</span>

    b-&gt;f(<span class="hljs-string">'a'</span>);
    <span class="hljs-comment">/*
     L'overloading resolution sceglie B::f(int) con dynamic lookup
     A runtime viene quindi eseguito B::f(int)
    */</span>
}
</code></pre>
<h1 id="lezione-23-subtyping-tra-funzioni-e-ereditariet-multipla">Lezione 23 - Subtyping (tra funzioni) e Ereditarietà multipla</h1>
<h2 id="subtyping-tra-funzioni">Subtyping tra funzioni</h2>
<p>Il subtyping <code>A &lt;: B</code> al posto di <code>B</code> possiamo usare <code>A</code>. Inoltre, se <code>B::f</code> è overriddato in <code>A::f</code>, il dynamic lookup prevede che venga invocato <code>A::f</code> al posto di <code>B::f</code> se il tipo dinamico dell&#39;oggetto di invocazione è <code>A</code>.</p>
<p>In un certo senso si può dire che dovunque funziona l&#39;invocazione di <code>B::f</code> funziona anche l&#39;invocazione di <code>A::f</code> che si avvicina alla definizione di sotto tipo, si può quindi dire che <code>A::f &lt;: B::f</code>?</p>
<p>Il subtyping tra funzioni può essere definito in due modi:</p>
<ul>
<li><strong>Covariante sul codominio</strong>: <em>A-&gt;B&#39;</em> ha come sotto tipo <em>A-&gt;B</em> se <em>B</em> è un sotto tipo di <em>B&#39;</em>. Ovvero: una funzione è sotto tipo di un&#39;altra funzione se il tipo dei parametri coincide e il valore che ritorna è un sotto tipo del valore di ritorno dell&#39;altra funzione.</li>
</ul>
<blockquote>
<p>If B &lt;: B&#39; then A-&gt;B &lt;: A-&gt;B&#39;</p>
</blockquote>
<ul>
<li><strong>Contro-variante sul dominio</strong>: <em>A&#39;-&gt;B</em> ha come sotto tipo <em>A-&gt;B</em> se  <em>A&#39;</em> è un sotto tipo di <em>A</em>. Ovvero: una funzione è sotto tipo di un&#39;altra funzione se il tipo dei parametri è un sopra tipo dei parametri dell&#39;altra funzione.</li>
</ul>
<blockquote>
<p>If A&#39; &lt;: A then A-&gt;B &lt;: A&#39;-&gt;B</p>
<p><code>int F(Point x) è sotto tipo di int F(ColoredPoint x)</code></p>
</blockquote>
<p>Nel caso ci siano più parametri si ha che <code>A::f &lt;: B::f</code> se le due funzioni sono contro-varianti sul dominio e covarianti sul valore di ritorno. Ovvero se i parametri di <code>A::f</code> sono dei sotto-tipi dei parametri di <code>B::f</code> e se il valore di ritorno di <code>A::f</code> <em>è più specifico</em> del valore di ritornodi <code>B::f</code>, cioè il tipo del valore di ritorno di <code>B::f</code> è sotto tipo di <code>A::f</code>.</p>
<blockquote>
<p>B::T f(T<sub>1</sub>, ..., T<sub>k</sub>) e A::S f(S<sub>1</sub>, ..., S<sub>k</sub>) </p>
<p>A::f &lt;: B::f</p>
<p>se T<sub>1</sub>, ..., T<sub>k</sub> &lt;: S<sub>1</sub>, ..., S<sub>k</sub> e S &lt;: T</p>
</blockquote>
<p>Ad esempio, se <code>circle &lt;: shape</code>:</p>
<p><img src="./notes/immagini/l23-sub.png" alt=""></p>
<p>Nell&#39;esempio non si riescono a trovare altri sotto tipi per <code>shape -&gt; circle</code>, perché non c&#39;è nessuna classe più generica di <code>shape</code> e nessuna più specifica di <code>circle</code>.</p>
<p>Tuttavia si può risalire la gerarchia, rendendo più specifico <code>shape</code> o più generco <code>circle</code>.</p>
<p>Quindi <code>circle -&gt; circle &lt;: circle -&gt; shape</code>, perché ovunque è richiesta l&#39;esecuzione di una funzione <code>circle -&gt; shape</code> è possibile utilizzare una funzione <code>circle -&gt; circle</code>, questo perché le due funzioni hanno lo stesso dominio e il codominio di <code>circle-&gt;circle</code> è un sotto tipo del dominio di <code>circle -&gt; shape</code>.</p>
<p>Inoltre, <code>shape -&gt; circle &lt;: circle -&gt; circle</code>, questo perché qualunque sotto tipo di <code>circle</code> è anche sotto tipo di <code>shape</code>, quindi le invocazioni di <code>circle -&gt; circle</code> sono compatibili con <code>shape -&gt; circle</code> e i risultati sono dello stesso tipo.</p>
<p>Da notare che tutto questo ragionamento si <strong>basa sui tipi</strong>, non viene tenuto in considerazione che cosa fa effettivamente una funzione, quindi il sotto-tipaggio tra funzioni <strong>non implica</strong> che le due funzioni facciano le stesse cose o che siano corrette.</p>
<p>In C++ la regola per il subtyping tra funzioni è più rigida, viene imposto che i domini delle funzioni siano uguali, quindi:</p>
<blockquote>
<p>T<sub>1</sub>,...,T<sub>k</sub> = S<sub>1</sub>,...,S<sub>k</sub> e S &lt;:T</p>
</blockquote>
<p>Questo perché il tipo del risultato di una funzione di ritorno non viene considerato dall&#39;algoritmo di overloading resolution, quindi l&#39;overriding può cambiare il tipo del valore di ritorno senza interferire con l&#39;overloading resolution.</p>
<p>In questo modo quando viene scelto un metodo virtuale non c&#39;è il rischio che il dynamic lookup invochi un metodo che si aspetta dei parametri di tipo diverso.</p>
<p>Se non ci fosse questo vincolo un metodo della classe base potrebbe essere overriddato da un metodo che si aspetta dei parametri diversi e se ci sono più override dello stesso metodo, la scelta del metodo da invocare diventerebbe ambigua.</p>
<p>Ricapitolando, in C++ l&#39;unico subtyping tra funzioni consentito è:</p>
<pre><code class="lang-c++"><span class="hljs-function">Point* <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; &lt;: <span class="hljs-function">ColorPoint* <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
</code></pre>
<h2 id="ereditariet-multipla">Ereditarietà Multipla</h2>
<p>In C++ una classe può avere più classi basi, in questo modo si possono ereditare funzionalità indipendenti che possono essere utilizzate per creare nuove funzionalità.</p>
<p>Ci sono però vari problemi, primo tra tutti è che la vtable della classe ottenuta per ereditarietà multipla deve essere conforme con quelle di tutte le classi base.</p>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> x;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
};
<span class="hljs-keyword">class</span> B {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> y;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-keyword">class</span> C: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B { <span class="hljs-comment">//L'ordine delle classi base è importante</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> z;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
};
...
C *pc = <span class="hljs-keyword">new</span> C;
A *pa = pc;
B *pb = pc;
</code></pre>
<p>L&#39;ordine con cui vengono dichiarate le classi base influisce sulla struttura dell&#39;oggetto, quindi la classe <code>class C: public A, public B</code> è diversa dalla classe <code>class C: public B, public A</code>.</p>
<p>Questo perché l&#39;ordine con cui vengono dichiarate le classi base corrisponde con l&#39;ordine dei sotto oggetti.</p>
<p>Anche per questo motivo il valore di <code>pc</code> è diverso dal valore di <code>pb</code>.</p>
<p><img src="./notes/immagini/l23-ered-mult.png" alt=""></p>
<p>La parte iniziale di un oggetto <code>C</code> è identica ad un oggetto <code>A</code>, dopodiché c&#39;è una parte identica ad un oggetto di tipo <code>B</code> e per finire ci sono le parti aggiunte dalla classe <code>C</code>.</p>
<p>La classe <code>C</code> ha quindi due vtable, una conforme alla classe <code>A</code> e l&#39;altra conforme alla classe <code>B</code>. C&#39;è anche una colonna aggiuntiva con contenete l&#39;offset dal puntatore all&#39;inzio dell&#39;oggetto. Questo è necessario perché se viene invocata <code>C::f</code> utilizzando un puntatore di tipo <code>B*</code> si ha come valore l&#39;inizio del sotto oggetto di tipo <code>B</code> e quindi per trovare il corretto indirizzo di inzio dell&#39;oggetto è necessario utilizzare il <strong>displacement</strong> presente nella colonna della vtable, così facendo l&#39;esecuzione di <code>f</code> riesce ad accedere sempre agli indirizzi corretti.</p>
<p>Quindi, alla compilazione di <code>pb-&gt;f(...)</code> il compilatore produrrà il codice <code>(*(pb-&gt;vtbl[2]))(pb,...)</code> mentre per <code>pc-&gt;f(...)</code>, <code>(*(pc-&gt;vtbl[1]))(pc,...)</code>.</p>
<p>Il valore dell&#39;offset (<em>displacement</em>) viene preso in considerazione nel codice compilato per la funzione, non nell&#39;invocazione. Quindi supponendo di avere</p>
<pre><code class="lang-c++">C::f(){
    x=x+<span class="hljs-number">2</span>
}
</code></pre>
<p>per calcolare l&#39;indirizzo di <code>x</code> il compilatore utilizza <code>o + disp + dx</code> dove <code>dx</code> è la distanza della variabile <code>x</code> dall&#39;inizio dell&#39;oggetto, indicato da <code>o</code>. <strong>Il valore del displacement viene <em>passato</em> alla funzione quando viene invocata a runtime, recuperandolo dalla vtable corretta.</strong></p>
<p>L&#39;offset non viene preso in considerazione nella compilazione dell&#39;invocazione <code>(*(pb-&gt;vtbl[2]))(pb,...)</code> perché varia in base al tipo dinamico, quindi il compilatore non riesce a stabilire l&#39;offset a compile time.</p>
<p>Le complicazioni causate dall&#39;ereditarietà multipla sono quindi:</p>
<ul>
<li>La classe derivata ha diverse vtable, una per ogni classe base.</li>
<li>Un puntatore <code>B*</code> ad un oggetti di tipo <code>C</code> punta ad un indirizzo differenzte dell&#39;oggetto rispetto ad un puntatore <code>A*</code> o <code>C*</code>.</li>
<li>Le vtable contengono degli offeset per alcuni metodi.</li>
</ul>
<h3 id="esercizio">Esercizio</h3>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> x;
        A(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>){x=a;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{g();}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt; “g di A”&lt;&lt;endl;}};
<span class="hljs-keyword">class</span> B{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> y;
        B(<span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>){y=b;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">r</span><span class="hljs-params">()</span></span>{f();}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"h di B"</span>&lt;&lt;endl;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{h();}
};
<span class="hljs-keyword">class</span> C: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> z;
        C(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> c=<span class="hljs-number">0</span>):A(a),B(b){z=c;}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{h();}
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{r();}
};
</code></pre>
<h4 id="domanda-1">Domanda 1</h4>
<p>Si chiede di disegnare in dettaglio la struttura di un oggetto della classe <code>C</code> spiegando le ragiuni di questa struttura</p>
<p><img src="./notes/immagini/l23-rappr.png" alt=""></p>
<blockquote>
<p><strong>Attenzione</strong>: l&#39;ordine delle classi base influisce sull&#39;ordine dei sotto oggetti</p>
</blockquote>
<p>Come prima cosa conviene disegnare l&#39;oggetto principale indicando i vari sottooggetti e i campi dati, seguendo l&#39;ordine di come compaiono nei sotto oggetti.</p>
<blockquote>
<p><strong>Attenzione</strong>: i metodi che <strong>non</strong> sono marcati come virtuali <strong>non</strong> devono comparire da nessuna parte del disegno, perché le loro invocazioni vengono decise a compile time, quindi non hanno senso si esistere a runtime.</p>
</blockquote>
<p>Dopo aver definito i sottooggetti si passa alle vtable, andando ad aggiungere i metodi virtuali e solo una volta completate tutte le vtable si passa ad inserire il displacement, questo perché il displacement serve se lo stesso metodo virtuale compare contemporaneamente su più vtable.</p>
<p>L&#39;oggetto ha questa struttura per garantire la conformità con gli oggetti delle classi base e il displacement serve per calcolare gli indirizzi corretti per i metodi virtuali che vengono definiti su più vtable.</p>
<h4 id="domanda-2">Domanda 2</h4>
<p>Si chiede di spiegare il tipo dei parametri formali dei metodi: <code>s</code>, <code>r</code>, <code>C::f</code>, <code>B::f</code>, e <code>B::h</code> e anche di descrivere come vengono compilate le invocazioni contenute nel corpo di questi 5 metodi.</p>
<blockquote>
<p><strong>Attenzione</strong> per riverirsi all&#39;oggetto di invocazione si utilizza <code>o</code>.</p>
</blockquote>
<p> <code>C::s(C*)</code>, <code>B::r(B* )</code>, <code>C::f(C*)</code>, <code>B::f(B*)</code>, <code>B::h(B*)</code>
corpo di <code>C::s</code>:</p>
<ul>
<li><code>s(C* o){o-&gt;r();}</code> il compilatore sa che <code>o</code> punterà sempre all’entrata principale, <code>r</code> è non virtuale, quindi produrrà un push+jump, ma, visto che <code>B::r</code> aspetta un <code>B*</code>, deve passare come parametro implicito <em>(o+δ)</em> per effettuare la conversione del puntatore. </li>
<li><code>r(B* o){o-&gt;f();}</code>, l’overloading resolution individua <code>B::f (B*)</code> che è virtuale, quindi l’invocazione viene compilata con: <code>*(o-&gt;vtbl[2])(o)</code> nota che c’è concordanza tra il tipo di <code>o</code> e il parametro formale di <code>B::f(B*)</code>, quindi niente conversioni.</li>
<li><code>C::f(C* o){o-&gt;h(B*);}</code> <code>C::f</code> può venire invocata con oggetto d’invocazione di tipo statico <code>A*</code>, <code>C*</code>, e <code>B*</code>. L&#39;invocazione di <code>h</code> viene quindi compilata con <code>*((o + δ - disp)-&gt;vtbl)[1](o + δ - disp)</code>.</li>
</ul>
<p>Nell&#39;ultimo esempio il problema sorge perché si sta compilando l&#39;invocazione di un metodo virtuale, senza sapere il tipo dinamico dell&#39;oggetto di invocazione e sapendo che è necessaria una conversione di tipo, dal momento che <code>o</code> è di tipo <code>C*</code> mentre <code>h</code> deve essere invocata con un <code>B*</code>.</p>
<p>Con questa gerarchia, <code>o</code> può avere tipo dinamico <code>A*</code>, <code>B*</code> e <code>C*</code>, pertanto, per effettuare la conversione di tipo a <code>B*</code> è necessario considerare l&#39;offset del sotto oggetto di tipo <code>B</code>, ovvero <code>o + δ</code>.
Tuttavia, il valore dinamico del puntatore <code>o</code> potrebbe già puntare al sotto oggetto di tipo <code>B</code> e in questo caso, la somma dell&#39;offset porta ad un errore. Pertanto viene preso anche in considerazione il displacement <code>o + δ - disp</code>.</p>
<p>Così facendo, il displacement memorizzato nella vtable del sotto oggetto <code>A</code>/<code>C</code> è <code>0</code> e a runtime viene effettuata la conversione di tipo corretta: <code>o + δ - 0</code>, che è l&#39;indirizzo del sotto-oggetto <code>B</code> se <code>o</code> punta a <code>C</code> o a <code>A</code>. </p>
<p>Mentre se <code>o</code> punta già al sotto oggetto di tipo <code>B</code> il valore del displacement prensete nella vtable è <code>δ</code>, pertanto <code>o + δ - disp</code> viene calcolato come <code>o + δ - δ</code>, che è l&#39;indirizzo del sotto oggetto <code>B</code> se <code>o</code> punta già al sotto oggetto <code>B</code>.</p>
<p><em>Possibile spoiler: il displacement viene memorizzato nelle vtable degli oggetti.</em></p>
<p><em>Possibile affermazione errata: come &quot;rule-of-thumb&quot;, se nella riga della vtable associata alla funzione invocata (non quella da invocare) è presente il displacement, molto probabilmente questo è da tenere in considerazione nella compilazione</em></p>
<h1 id="lezione-24-eredit-multipla-2">Lezione 24 - Eredità Multipla 2</h1>
<p><strong>Precisazione sul displacement della vtable</strong>: se un metodo della classe derivata esegue l&#39;override di un metodo virtuale di <strong>una sola classe base</strong> non serve considerare il displacement.</p>
<p><strong>Precisazione sul dynamic lookup</strong>: se in una qualche gerarchia di classi, c&#39;è un metodo <code>f</code> virtuale che viene ridefinito in più sottoclassi, l&#39;istruzione <code>C::f</code> invoca il metodo <code>f</code> della classe <code>C</code>, in questo caso l&#39;invocazione viene decisa a compile time e non utilizza  il dynamic lookup.</p>
<h2 id="cosa-fa-veramente-il-compilatore">Cosa fa veramente il compilatore</h2>
<p>Utilizzando il flag <code>-fdump-class-hierarchy</code> il compilatore <code>g++</code> mostra la struttura delle classi.</p>
<p>Dai risultati forniti dal compilatore si riescono a vedere le due vtable. In particolare tutti i metodi overriden della classe derivata si trovano nella prima vtable e nelle entrate delle altre vtable c&#39;è un riferimento al record relativo alla prima vtable.</p>
<p><img src="./notes/immagini/l24-compilatore.png" alt=""></p>
<p>Tuttvia questa potrebbe essere un&#39;ottimizzazione effettuata dal compilatore, non è detto che sia un&#39;implementazione standard.
Negli esercizi si può utilizzare l&#39;approccio visto in classe (default) oppure se si vuole utilizzare questo approccio è da specificare.</p>
<h2 id="cast-pericolosi">Cast pericolosi</h2>
<p>Supponiamo di avere 5 classi, <code>A0</code>, <code>A1</code>, <code>B</code> che deriva da <code>A0</code>, <code>C</code> che deriva da <code>A1</code> e <code>D</code> che deriva da <code>B</code> e <code>C</code>.</p>
<p>Il seguente frammento di codice compila correttamente</p>
<pre><code class="lang-c++">A0<span class="hljs-keyword">*</span> a0 = new A0;
A1<span class="hljs-keyword">*</span> a1 = new A1;
D<span class="hljs-keyword">*</span> d = (D<span class="hljs-keyword">*</span>) a0;
d = (D<span class="hljs-keyword">*</span>) a1;
</code></pre>
<p>Questo porta ad un errore a runtime, perché non esiste nessun oggetto di tipo <code>D</code>. </p>
<h2 id="caso-con-3-classi-base">Caso con 3 classi base</h2>
<p><img src="./notes/immagini/l24-base-multipla.png" alt=""></p>
<p>In questo caso il compilatore da un errore, perché <code>E</code> non ridefinisce <code>f</code> e c&#39;è un&#39;ambiguità nella scelta, quindi il compilatore per non sapere né leggere né scrivere, solleva un&#39;errore.</p>
<p>Nel caso ci fosse anche <code>E::f</code> le varie tabelle utilizzerebbero <code>&amp;E::f</code>, con displacmente <code>0</code>, <code>δ</code> e <code>δ + δ&#39;</code>.</p>
<p>Se non ci fossero né <code>D::f</code> né <code>E::f</code>, l&#39;istruzione <code>E* e = new E(); e-&gt;f()</code> è senza dubbio corretta, ma come fa il compilatore a trovare <code>f</code>? Dal momento che <code>f</code> viene eriditata da <code>C</code>, aggiunge al valore di <code>e</code> il displacement per arrivare al sotto-oggetto <code>C</code>. </p>
<h2 id="conflitto-nei-nomi">Conflitto nei nomi</h2>
<p>Per risolvere il conflitto dell&#39;esempio precedente si possono utilizzare 3 strategie:</p>
<ul>
<li><strong>Risoluzione implicita</strong>: sceglie il compilatore che metodo invocare</li>
<li><strong>Risoluzione esplicita</strong>: il compilatore segnala errore se il programmatore non disambigua in modo esplicito.</li>
<li><strong>Avoid name clash</strong>: il compilatore non permette che si verifichino questi conflitti.</li>
</ul>
<p>Nessuna delle 3 è le migliore, ma la risoluzione esplicita è la meno peggio.</p>
<h2 id="ereditariet-a-diamante">Ereditarietà a Diamante</h2>
<p>Utilizzando l&#39;ereditarietà multipla può essere che compaia il diamante della morte, ovvero quando si ha una classe <code>D</code>, dalla quale derivano <code>A</code> e <code>B</code>, e si aggiunge alla festa una classe <code>C</code> che eredita sia da <code>A</code> che da <code>B</code>.</p>
<p><img src="./notes/immagini/l24-diamante.png" alt=""></p>
<p>Per gestire questa situazione si possono utilizzare due strategie diverse:</p>
<ul>
<li>Si tengono due copie dei dati dell&#39;oggetto <code>D</code>, quando un metodo della classe <code>C</code> deve accedere ad un dato dell&#39;sottooggetto <code>D</code> deve specificare con l&#39;operatore di scoping <code>::</code>, alcune istruzioni non possono essere più eseguite, come <code>D* d = new C()</code>.</li>
<li>Si tiene una copia sola dei dati, rischiando però di avere delle incoerenze.</li>
</ul>
<p>C++ permette di utilizzare entrambe le strategie. Se non viene specificato nulla vengono tenute due copie dei sotto-oggetti, mentre con l&#39;<strong>ereditarietà virtuale</strong> viene utilizzato un singolo sotto-oggetto.</p>
<p><img src="./notes/immagini/l24-virtuale.png" alt=""></p>
<p>Ovvero il sotto oggetto di tipo <code>D</code> viene distaccato e sostituito con un puntatore.
Il nuovo sotto oggetto ha una vtable che contiene dei riferimenti ai metodi che sono stati overridati da <code>A</code>.</p>
<p>Da notare che in questo modo viene aggiunto un livello di indirezione che crea dei problemi quando è necessario fare un downcast, dal momento che la distanza δ non è più costante. È quindi necessario utilizzare il <strong>dynamic cast</strong> il quale utilizza delle informazioni presenti nella vtable del sotto oggetto <code>D</code> per recuperare l&#39;indirizzo dell&#39;oggetto <code>A</code>.</p>
<p><img src="./notes/immagini/l24-vtable.png" alt=""></p>
<p>Il tutto può essere riassunto dicendo che il sotto oggetto virtuale viene messo in fondo all&#39;oggetto derivato, man mano che si effettuano derivazioni, la distanza del sotto oggetto virtuale aumenta.
Trattandosi poi di un valore che varia dinamicamente, questa distanza deve essere specificata nella vtable degli oggetti.</p>
<p><img src="./notes/immagini/l24-sottooggetto.png" alt=""></p>
<h3 id="casi-strani">Casi strani</h3>
<p><img src="./notes/immagini/l24-f.png" alt=""></p>
<p>Se viene usata l&#39;ereditarietà virtuale, il compilatore solleva un errore perché nella vtable del sotto oggetto <code>D</code> non può contenere due definizioni di <code>f</code>. Se anche <code>C</code> defince <code>f</code>, allora non ci sono problemi.</p>
<p>Se invece <code>f</code> viene overridata solamente da <code>A</code>, allora non ci sono problemi.</p>
<p>C&#39;è un problema anche con i costruttori, in questo caso il compilatore impedisce ai costruttori di <code>A</code> e <code>B</code> di invocare i costruttori di <code>D</code>, solo il costruttore di <code>C</code> può invocarli, questo perché c&#39;è un solo sotto oggetto.</p>
<p>Dal momento che come si eredita viene deciso quando viene progettata la classe, è necessario tenere conto di come verrà utilizzata la classe quando si sceglie che tipo di ereditarietà utilizzare. Questo perché l&#39;ereditarietà virtuale o meno, influenza come altre classi possano derivare la classe che si sta definendo.</p>
<h2 id="classi-astratte">Classi astratte</h2>
<p>Sono classi non completamente definite, che possono essere utilizzate solamente per definire dei sottotipi conformi ad essa.</p>
<p>Perché una classe sia virtuale è sufficente che un metodo abbia corpo nullo <code>=0</code>.</p>
<p>Sono state introdotte per rendere meno problematica l&#39;ereditarietà multipla, dato che servono solamente a fissare l&#39;ordine delle vtable delle classi derivate.</p>
<h1 id="lezione-25-esercizi-e-considerazioni-varie">Lezione 25 - Esercizi e considerazioni varie</h1>
<p>Quando una sottoclasse fa l&#39;overriding di un metodo virtuale, la visibilità del metodo deve rimanere la stessa. Se questa viene modificata, il compilatore ignora la modifica.</p>
<p><strong>Filosofia di programmazione del C++</strong>: nelle sottoclassi si aggiungo metodi con nuovi nomi e al più si fa overriding dei metodi ereditati. Lo stesso approccio vale anche per la visibilità dei metodi che non va cambiata nelle sottoclassi.</p>
<h2 id="metodi-fantasma-proposta-di-modifica-del-c-">Metodi fantasma (proposta di modifica del c++)</h2>
<p>Sono metodi che si comportano come metodi virtuali solo se viene effettuato l&#39;overriding. Sono ereditabili sono se la classe li ridefinisce, altrimenti non vengono ereditate</p>
<pre><code class="lang-c++">class A{
<span class="hljs-attribute">...</span>
    <span class="hljs-keyword">public</span>: phantom <span class="hljs-literal">void</span> f() {<span class="hljs-attribute">...</span><span class="hljs-built_in">.</span>}
};
class B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>: <span class="hljs-comment">/* no def of f */</span>
};

<span class="hljs-comment">//---</span>

A* a = <span class="hljs-literal">new</span> A();
a<span class="hljs-subst">-&gt;</span>f() <span class="hljs-comment">// ok</span>
B* b = <span class="hljs-literal">new</span> B();
b<span class="hljs-subst">-&gt;</span>f() <span class="hljs-comment">// errore, rilevabile a compile time</span>

a = b;
a<span class="hljs-subst">-&gt;</span>f() <span class="hljs-comment">// non si riesce a rilevare questo errore (almeno a compile time)</span>
</code></pre>
<p>Inoltre, viene violato il fatto che in C++ l&#39;eredietarietà pubblica soddisfa la definizione di sotto-tipo. </p>
<h2 id="visibilit-">Visibilità</h2>
<pre><code class="lang-c++">class <span class="hljs-type">Base</span>{
public: virtual f()<span class="hljs-decorator">{...}</span>
};
class <span class="hljs-type">Derived</span>: public <span class="hljs-type">Base</span>{
private: virtual f()<span class="hljs-decorator">{...}</span>
};
</code></pre>
<p>È ragionevole che l&#39;ereditarietà pubblica implichi il subtyping, perché con l&#39;ereditarietà pubblica viene garantito che l&#39;interfaccia della classe derivata contenga l&#39;interfaccia della classe base.</p>
<p>Per quanto detto all&#39;inzio della lezione, nel programma sopra riportato, il compilatore ignora il fatto che la visibilità del metodo overridden sia stata cambiata.</p>
<pre><code class="lang-c++">int <span class="hljs-keyword">g</span>(Base &amp;x) { <span class="hljs-keyword">return</span> x.<span class="hljs-literal">f</span>()+1; }
main() {
    Base b; cout&lt;&lt;<span class="hljs-string">"g(b)="</span>&lt;&lt;<span class="hljs-keyword">g</span>(b)&lt;&lt;endl; <span class="hljs-comment">//Invoca f della classe base</span>
    Derived <span class="hljs-keyword">d</span>; cout&lt;&lt;<span class="hljs-string">"g(d)="</span>&lt;&lt;<span class="hljs-keyword">g</span>(<span class="hljs-keyword">d</span>)&lt;&lt;endl; <span class="hljs-comment">//Invoca f della classe derivata</span>
}
</code></pre>
<p>Il codice precedente permette di invocare un metodo privato di un&#39;oggetto, creando un&#39;incoerenza sulla definizione delle interfacce.
Questo perché, il compilatore darebbe un errore sull&#39;invocazione <code>d-&gt;f()</code> perché privato, ma le istruzioni <code>Base* b = new Derived(); b-&gt;f()</code> compila ed esegue correttamente, invocando il metodo <code>D::f</code>.</p>
<h2 id="subtyping-e-overriding">Subtyping e overriding</h2>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> A{
    <span class="hljs-keyword">public</span>:
        A(<span class="hljs-keyword">int</span> x){a=x;}
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{f(x);}
    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span> a;
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;endl;}
};
<span class="hljs-keyword">class</span> B: <span class="hljs-keyword">public</span> A{
    <span class="hljs-keyword">public</span>:
        B(<span class="hljs-keyword">int</span> x):A(x){}
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;x+<span class="hljs-number">2</span>&lt;&lt;endl;}
};

main() {
    A* a= <span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>);
    B* b=<span class="hljs-keyword">new</span> B(<span class="hljs-number">3</span>);
    a-&gt;g(<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span>
    a=b;
    a-&gt;g(<span class="hljs-number">1</span>); <span class="hljs-comment">//2</span>
}
</code></pre>
<p>Il C++ permette di avere anche i metodi privati virtuali, e questi sono overriddabili dalle classe basi, pertanto:</p>
<ol>
<li>L&#39;invocazione di <code>g</code> esegue <code>A::f</code></li>
<li>L&#39;invocazione di <code>g</code> esegue <code>B::f</code></li>
</ol>
<p>Inoltre, se <code>B::f</code> non fosse virtuale, il compilatore si comporterebbe allo stesso modo, considerandolo comunque come un override di un metodo virtuale.</p>
<p>Se <code>B::f</code> fosse <code>public</code>, verrebbe solamente cambiata l&#39;interfaccia di <code>B</code>, senza andare ad influire sul subtyping tra <code>B</code> e <code>A</code>.</p>
<h2 id="eiffel">Eiffel</h2>
<pre><code><span class="hljs-keyword">class</span> Point
x:int
<span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">equals</span> <span class="hljs-params">(pt: like current)</span>:</span> bool return <span class="hljs-keyword">self</span>.x==pt.x

<span class="hljs-keyword">class</span> ColPoint inherits Point
color:string
<span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">equals</span> <span class="hljs-params">(cpt: like current)</span>:</span> bool return <span class="hljs-keyword">self</span>.x==cpt.x <span class="hljs-keyword">and</span> <span class="hljs-keyword">self</span>.color==cpt.color
</code></pre><p>Eiffel permette di utilizzare il tipo <code>like current</code> che rappresenta il tipo dinamico della classe.
L&#39;utilizzo di questo tipo viene utilizzato in Eiffel per effettuare l&#39;overriding dei metodi.</p>
<p>Nell&#39;esempio, la classe <code>ColPoint</code> non è sotto tipo di <code>Point</code>, perché i parametri della funzione <code>equals</code> di <code>ColPoint</code> non sono un sovra-tipo di quelli della funzione <code>equals</code> di <code>Point</code>.</p>
<p>Ad esempio il codice:</p>
<pre><code>Point <span class="hljs-tag">p</span> = new <span class="hljs-function"><span class="hljs-title">ColPoint</span><span class="hljs-params">()</span></span>
<span class="hljs-tag">p</span>.<span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">(new Point()</span></span>)
</code></pre><p>in questo caso il compilatore non riesce a trovare l&#39;errore, perché i tipi statici coincidono, ma quelli a runtime i no.</p>
<p>Tuttavia Eiffel permette di considerare <code>ColPoint</code> come sotto tipo di <code>Point</code> anche se questo può portare errori a runtime.
Quando i volponi che hanno fatto il linguaggio si sono accorti che la cosa è sbagliata, hanno aggiunto un sistema di analisi statica per rilevare questi errori.</p>
<p>Il problema è che la ricerca di questo errore è non decidibile, quindi il l&#39;analisi statica introdotta fornisce un&#39;approsimazione, quindi ci sono dei casi in cui l&#39;analisi statica segnala degli errori che in realtà non ci sono (questo perché l&#39;approsimazione deve essere pessimistica).</p>
<h1 id="lezione-26-java">Lezione 26 - Java</h1>
<p>Nasce negli anni &#39;90 con il nome di Oak per far funzionare delle &quot;smart tv&quot;.</p>
<p>Per il Java è presente sia un compilatore che un interprete: il programmatore compila il codice Java con il compilatore, il quale produce il <em>Java bytecode</em> che può essere interpretato dalla <strong>Java Virtual Machine</strong>.</p>
<p>L&#39;utilizzo dell&#39;interprete fornisce maggiore sicurezza, dal momento che durante l&#39;esecuzione si ha un maggior controllo sulle istruzioni che si stanno eseguento.
Viene comunque fornita la possibilità di effettuare delle chiamate native.</p>
<p>Obiettivi del linguaggio:</p>
<ul>
<li><strong>Portabilità</strong>: il linguaggio deve poter essere &quot;internet-wide&quot;, ovvero compatibile con i vari sistemi operativi;</li>
<li><strong>Reliability</strong>: i programmi devono evitare crash e comportamenti in attesi, programmi solidi e rubusti;</li>
<li><strong>Safety</strong>: il linguaggio deve controllare che non vengano eseguite istruzioni maligne;</li>
<li><strong>Dynamic Linking</strong>: il programma può essere eseguito anche se tutte le classi che lo compongno non sono presenti, ciò deriva dal fatto che il programma può essere caricato da più computer connessi in rete;</li>
<li><strong>Multi-Threaded</strong>: possibilità di scrivere programmi concorrenti;</li>
<li><strong>Simplicity</strong>: il linguaggio deve essere facilmente comprensibile dai programmatori medi, ovvero la sinstassi deve ricordare quella del C++ (era il linguaggio del momento);</li>
<li><strong>Efficenza</strong>: tenuta in secondo piano.</li>
</ul>
<p>Java non ha lo stesso problema del C++ per quanto riguarda l&#39;ereditarietà dal momento che non deve mantenere la retrocompatibilità con il C.
Non sono quindi presenti i cast e l&#39;aritmetica dei puntatoro, inoltre il paradigma OO può essere integrato maggiormente nel linguaggio.</p>
<h2 id="compilazione-in-bytecode">Compilazione in Bytecode</h2>
<p>Il compiltatore Java produce un programma in Bytecode che può essere eseguito dalla JVM.</p>
<p>Questa scelta assicura:</p>
<ul>
<li><strong>Portabilità</strong>: basta avere l&#39;implementazione della JVM compatibile con il sistema operativo per poter eseguire il programma scritto in Bytecode.</li>
<li><strong>Safety</strong>: interpretare da maggior controllo</li>
<li><strong>Efficency</strong>: questo approccio risulta <strong>meno</strong> efficente perché interpretare è più costoso del compilare. Con il tempo è stato introdotta la compilazione JIT (Just In Time).</li>
</ul>
<h2 id="type-safeness">Type-safeness</h2>
<p>Il controllo sui tipi viene fatto a 3 livelli:</p>
<ul>
<li>Type check sul codice sorgente scritto in Java, che risulta più efficace dal momento che non c&#39;è da tenere in considerazione l&#39;aritmentica dei puntatori e cast. Ciò ha permesso anche di implementare la garbage collection.</li>
<li>Ogni istruzione Bytecode viene poi <em>typecheck-ata</em> prima di essere eseguita (check statico eseguito quando viene caricato il Bytecode).</li>
<li>Controlli a runtime, come i limiti degli array e i down-cast (ad esempio da Object a String).</li>
</ul>
<p>L&#39;efficenza diminuisce a causa del numero dei controlli, specialmente per quelli eseguiti a run time.</p>
<h2 id="oggetti-e-riferimenti">Oggetti e riferimenti</h2>
<p>In Java <strong>quasi</strong> tutto è un oggetto, infatti i tipi primitivi non sono oggetti per creare un compromesso tra semplicità ed efficenza.</p>
<p>Per semplificare il linguaggio è stato poi posto il vincolo che gli oggetti possono essere acceduti solamente tramite puntatori, che prendono il nome di <strong>riferimenti</strong> e che vengono &quot;nascosti&quot; dal compilatore.
Di conseguenza l&#39;unica assegnazione tra oggetti è quella tra i puntatori.</p>
<p>Il passaggio dei parametri alle funzioni avviene sempre per valore. Quando viene passato un oggetto, viene forinto il valore del puntatore (riferimento).</p>
<p><img src="./notes/immagini/l26-base.png" alt=""></p>
<p>In Java vale l&#39;<strong>array covariance</strong>, ovvero se <code>Shape</code> è sotto tipo di <code>Circle</code>, anche <code>Shape[]</code> è sotto tipo di <code>Circle[]</code>. Questo è uno dei punti discutibili del Java.</p>
<p>La classe <code>ClassLoader</code> rapprenseta la classe che viene utilizzata per caricare dinamicamente le altre classi. Risulta importare avere la possibilità di utilizzare più <code>ClassLoader</code> per una questione di sicurezza: è possibile avere un loader per caricare delle classi ritenute sicure che esegue meno controlli sulla sicurezza e fornisce privilegi maggiori e avere altri loader meno permissivi.</p>
<p>Tutti gli oggetti Java estendono (ereditano) da una classe, se questa non è specificata viene utilizzato di default <code>Object</code>, che contiene alcuni metodi generici come <code>toString()</code>, <code>equals()</code> e altri metodi legati alla concorrenza.</p>
<h2 id="tipi-e-sotto-tipi-in-java">Tipi e sotto tipi in Java</h2>
<ul>
<li><strong>Tipi primitivi</strong>: non sono oggetti, <code>int</code> <code>bool</code></li>
<li><strong>Reference Type</strong>: vengono utilizzati i riferimenti per gli oggetti,  classi, interfaccie e array. Inolre, la sintassi non prevede l&#39;utilizzo di <code>Object*</code> a contrario del C++.</li>
<li><strong>Type Conversion</strong>: se <code>B &lt;: A</code> e <code>A x</code> allora è possibile fare il cast di <code>x</code> a <code>B</code> (programmazione generica). Tutti questi cast vengono verificati a run time e possono sollevare delle eccezioni.</li>
</ul>
<h2 id="garbage-collection">Garbage Collection</h2>
<p>Grazie alla concorrenza è possibile effettuare la garbage collection, che è necessaria per la type safety dal momento che se non ci fosse, sarebbe compito del programmatore gestire la memoria (evita i dangling pointer).</p>
<p>La garbage collection utilizza un&#39;approssimazione per determinare se un oggetto servirà in futuro o meno.
L&#39;approssimazione risulta comunque accurata e raramente sbaglia. In ogni caso è necessaria per il buon funzionamento del programma.</p>
<h2 id="dynamic-linking">Dynamic linking</h2>
<p>Le classi che compongono il programma possono venire caricate nella JVM in modo incrementale per velocizare l&#39;inizio dell&#39;esecuzione del programma.</p>
<p>È una sorta di lazy-evaluation delle classi: se durante l&#39;esecuzione una classe non serve questa non vienne caricata.</p>
<p>Risulta fondamentale che le classi abbiano un&#39;interfaccia chiara che permette il controllo del programma con le classi mancanti rapprentando la loro interfaccia. <strong>Sistemami!</strong></p>
<h2 id="java-vs-c-">Java VS C++</h2>
<p>Semplicazioni:</p>
<ul>
<li>Non c&#39;è l&#39;ereditarietà multipla;</li>
<li>Non c&#39;è l&#39;overloading degli operatori, solo delle funzioni;</li>
<li>Non ci sono coercizioni automatiche nell&#39;overloading resolution</li>
</ul>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> f(int)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">A</span> :</span> f(double)

<span class="hljs-type">A</span> a = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>();
a.f(<span class="hljs-number">2.4</span>);   <span class="hljs-comment">//C++ invoca f(int)</span>
            <span class="hljs-comment">//Java da un errore di compilazione a causa della conversione Double -&gt; Int</span>
a = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();
a.f(<span class="hljs-number">2.4</span>)
<span class="hljs-comment">// C++ invoca f(int) per via del tipo statico</span>
<span class="hljs-comment">//Anche in questo caso Java segnala l'errore. </span>
<span class="hljs-comment">//(non ne sono sicuro, ma sembra avere senso perché staticamente non sa il tipo dinamico)</span>
</code></pre>
<ul>
<li>Non ci sono puntatori espliciti e le relative operazioni.</li>
</ul>
<p>Punti in cui il Java migliora il C++:</p>
<ul>
<li>Garbage collection e metodi <code>finalize</code></li>
<li>Costruttori e costruttori delle superclassi, per la costruzione dei sotto oggetti</li>
<li>Classi e metodi final</li>
<li>Ereditarietà multipla ma solo con interfacce</li>
<li>Eccezioni integrate nelle classi e controllo degli handlers</li>
<li>Overloading</li>
<li>Enforcing delle regole di overriding dei metodi che sono virtuali</li>
<li>Concorrenza</li>
</ul>
<p>Aspetti negativi del Java:</p>
<ul>
<li>Array covariance (trattata dopo);</li>
<li>Realizzazione della concorrenza non sempre accettabile, specialmente in ambito real time, però si tratta già di un passo avanti rispetto al C++;</li>
<li>Programmazione generica inizialemente assente (introdotta negli anni 2000) e comunque è stata implementata in modo diverso dal solito dal momento che il Java con Generics viene compilato allo stesso modo del Java senza Generics, mantenendo la retrocompatibilità.</li>
</ul>
<h3 id="garbage-collection-e-finalize">Garbage collection e finalize</h3>
<p>Gli oggetti vengono deallocati solamente dal garbage collector, evitando così i puntatori a null.</p>
<p>Possono esserci dei problemi nella deallocazione se l&#39;oggetto in questione possiede delle risorse o ha dei lock.</p>
<p>Sono stati quindi introdotti i metodi <code>finalize</code> che vegnono invocati dal garbage collector in modo da liberare le risorse.
Questi metodi possono essere quindi invocati prima di deallocare l&#39;oggetto o all&#39;uscita del programma.</p>
<p>La necessità di liberare spazio non è sempre la motivazione giusta per liberare le risorse, perché può creare problemi quando l&#39;oggetto ha un lock (per la programmazione concorrente).</p>
<p>È una convenzione invocare <code>super.finalize</code> all&#39;interno del metodo, anche se non è obbligatorio.</p>
<h3 id="costruttori-e-super">Costruttori e super</h3>
<p>Java garantisce che il costruttore venga invocato per ogni oggetto e questo deve essere possibile anche con l&#39;ereditarietà.</p>
<p>In particolare il costruttore della sotto classe <strong>deve</strong> chiamare il costruttore della super classe, altrimenti viene inserita dal compilatore la chiamata al costruttore senza parametri.</p>
<p>Se questo costruttore non è presente si verifica un errore di compilazione.</p>
<p>C&#39;è un&#39;eccezione nel caso un costruttore invochi un altro costruttore della stessa classe.</p>
<p>Da notare che la convezione adotta è diversa da quella per <code>finalize</code>.</p>
<h3 id="final">Final</h3>
<p>Keyword che permette di limitare l&#39;ereditarietà. Le classi o metodi marcati come <code>final</code> non possono essere ridefiniti (es: <code>java.lang.String</code>).</p>
<p>Questo è importante per la sicurezza, dal momento che il programmatore può limitare il comportamento delle sotto-classi.</p>
<p>Ogni metodo di una classe risulta &quot;<em>virutale</em>&quot; finché non viene marcato come <code>final</code>.</p>
<h3 id="ereditariet-mutlipla-con-inferfacce">Ereditarietà mutlipla con inferfacce</h3>
<p>Il subtyping per le classi è simile al C++: staticamente tipato, sottoclasse collegata al sottotipo e ereditarità singola.</p>
<p>Le interfacce permettono di definire delle classi astratte che non hanno implementazione, anche se esiste comunque la possibilità di definire le classi astratte che hanno un&#39;implementazione parziale.</p>
<p>Per ottenere il <em>multiple subtyping</em> le inferfacce permettono l&#39;ereditarietà multipla.</p>
<p>In questo modo a compilazione si riesce a distinguere il caso in cui viene usato come tipo statico la classe base o un&#39;interfaccia, ottenendo una maggiore efficenza nel caso venga utilizzata la classe base, dal momento che in questo caso il dynamic lookup può essere basato sulla conformità.</p>
<p>Nel caso dell&#39;utilizzo di un&#39;interfaccia non viene più garantita la conformità, pertanto il codice prodotto risulta diverso dal momento che deve effettuare la ricerca dinamica del metodo da invocare (ci sono dei barbatrucchi per ottimizzare la ricerca).</p>
<p>L&#39;utilizzo delle interfacce permette di avere l&#39;ereditarietà multipla evitando il diamante della morte che si può verificare nel C++.
C&#39;è però un costo maggiore dovuto al fatto che la ricerca dei metodi da invocare deve essere fatta a runtime.</p>
<h3 id="eccezioni">Eccezioni</h3>
<p>Il funzionamento è standard con il <code>throw</code>/<code>catch</code> utilizzando il dynamic scope per la selezione dell&#39;handler (primo trovato).</p>
<p>Ci sono alcune differenze legate al fatto che le eccezioni sono un oggetto e pertanto è permesso il subtyping delle eccezioni.</p>
<p>Inoltre, la firma dei metodi deve dichiarare queli eccezioni possono essere sollevate e che non sono <code>Exception</code>, questo perché c&#39;è una gerarchia delle eccezioni.</p>
<p><img src="./notes/immagini/l26-exc.png" alt=""></p>
<p>Se un metodo può sollevare delle eccezioni, queste devono essere sotto-tipo di <code>Exception</code> e devono essere dichiarate nella firma/prototipo.</p>
<p>Le <code>RuntimeExcpetion</code> rappresentano tutte le eccezioni legate agli errori runtime, come l&#39;out of bound di un&#39;array o un class cast fallito.</p>
<p>Le cose fighe sono:</p>
<ul>
<li>Le eccezioni di un thread rimangono dentro il thread</li>
<li>È possibile utilizzare un sopratipo per catturare più sotto-tipi di eccezioni.</li>
</ul>
<h3 id="overloading">Overloading</h3>
<p>Si basa sulla firma del metodo, utilizzando il nome e il tipo degli argomenti.</p>
<p>I metodi con lo stesso nome ma con parametri diversi sono in concorrenza, la decisione del metodo da invocare viene presa durante la compilazione da sorgente a Bytecode, senza tenere conto delle conversioni automatiche.</p>
<p>Quindi o c&#39;è un metodo che ha la firma che coincide con i tipi di invocazione o viene sollevato un errore (vedi esempio precedente).</p>
<p>Non è possibile effettuare l&#39;overload degli operatori.</p>
<h3 id="overriding">Overriding</h3>
<p>In Java tutti i metodi sono virtuali, quindi per effettuare l&#39;overriding basta utilizzare la stessa firma del metodo.</p>
<p>La firma del metodo rispetto ad un metodo della super classe può variare in tre modi:</p>
<ul>
<li>Tipi degli argomenti</li>
<li>Tipo del valore di ritorno</li>
<li>Eccezioni sollevate</li>
</ul>
<p>Per fare l&#39;override gli argomenti devono avere lo stesso tipo, il valore di ritorno può essere un sotto tipo, il metodo può sollevare meno eccezioni e la visibilità può essere solamente ampliata.</p>
<p>Le ridefinizioni di un metodo non sono bloccanti come con il C++: un metodo della classe derivata può overriddare un metodo conforme della classe base, ma non oscura altri metodi della classe base che hanno lo stesso nome ma parametri diversi. Questi altri metodi vengono ereditati normalmente e rimangono visibili nella classe derivata.</p>
<h3 id="array-covariance-problem">Array covariance problem</h3>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {</span>};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">A</span> {</span>};

<span class="hljs-type">B</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>[<span class="hljs-number">10</span>];
<span class="hljs-type">A</span>[] a = b; <span class="hljs-comment">//Ok, perché B[] &lt;: A[]</span>
a[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>(); <span class="hljs-comment">//Eccezione a runtime perché B &lt;: A</span>
</code></pre>
<p>Tuttavia il compilatore non segnala errori, ma a runtime viene sollevato in quanto si prova ad eseguire un assegnamento del tipo <code>B x = new A();</code>.</p>
<p>Questo problema deriva dalla versione originale di Java e ormai non può essere più modificata per una questione di retrocompatibilità con i programma già esistenti.</p>
<h3 id="conversioni-automatiche-int-double">Conversioni automatiche int-&gt;double</h3>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> A1{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span>
    </span>{
        System.out.println(<span class="hljs-string">"f di A1 "</span>);}
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> B1 extends A1{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
    </span>{   
        System.out.println(<span class="hljs-string">"f di B"</span>);}
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Main1{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
        A1 a=<span class="hljs-keyword">new</span> A1();
        B1 b=<span class="hljs-keyword">new</span> B1();
        a.f(<span class="hljs-number">2</span>); <span class="hljs-comment">//Ok con conversione automatica, A1::f</span>
        b.f(<span class="hljs-number">2</span>); <span class="hljs-comment">//Ok, B1::f</span>
        a.f(<span class="hljs-number">2.1</span>); <span class="hljs-comment">//Ok, A1::f</span>
        b.f(<span class="hljs-number">2.1</span>); <span class="hljs-comment">//Ok, A1::f dato che B1::f(int) non copre il metodo ereditato</span>
        a=b;
        a.f(<span class="hljs-number">2.1</span>); <span class="hljs-comment">//Ok, A1::f</span>
        a.f(<span class="hljs-number">2</span>);   <span class="hljs-comment">//OK, ma stampa A1::f per via del tipo statico</span>
    }
}
</code></pre>
<p>Nell&#39;ultimo caso con <code>a.f(2)</code> l&#39;overloading resolution sceglie <code>f(double)</code> perché è l&#39;unico che risce a vedere. A runtime non vengono trovati override del metodo e di conseguenza viene invocato il metodo di <code>A1</code>.</p>
<h1 id="lezione-27-jvm">Lezione 27 - JVM</h1>
<p><img src="./notes/immagini/l27-jvm.png" alt=""></p>
<p>Il compilatore Java produce un file <code>.class</code> che contiene il bytecode prodotto, spetta poi alla JVM eseguire il contenuto del file.</p>
<p>La JVM è divisa in due parti, la prima dedicata al caricamento delle classi e la seconda dedicata all&#39;interpretazione del codice.</p>
<p>La prima parte è poi divisa in 3 moduli:</p>
<ul>
<li>Loader</li>
<li>Verifier</li>
<li>Linker</li>
</ul>
<h2 id="loader-subsystem">Loader subsystem</h2>
<p>La prima parte si occupa di caricare le classi da i vari file quando queste sono richieste.</p>
<p>Il meccanismo di caricamento di default delle classi può essere modificato creando delle sotto classi di <code>ClassLoader</code> e che ridefiniscono il metodo <code>loadClass</code>.
Lo scopo delle ridefinzione di <code>ClassLoader</code> è quello di aggiungere nuovi percorsi possibili per andare a cercare il file <code>.class</code>, ad esempio per caricare la classi a partire da un indirizzo di rete.</p>
<p>Durante l&#39;esecuzione del loader vengono eseguiti i blocchi di inizializzazione statica delle classi.</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> ... </span>{
 <span class="hljs-comment">/* static variable with initial value */</span>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = initial_value
 <span class="hljs-comment">/* ---- static initialization block --- */</span>
 <span class="hljs-keyword">static</span> { <span class="hljs-comment">/* code executed once, when loaded */</span> }
}
</code></pre>
<p>Questi blocchi statici vengono eseguiti una sola volta, quando la classe viene caricata dal loader e non possono sollevare eccezioni, perché potrebbero non esserci degli handler che le gestiscono.</p>
<p>Il <strong>linker</strong> si occupa di aggiungere al sistema le classi caricate dal loader e di creare i campi statici e inizializzarli.</p>
<p>Il linker si occupa inoltre di risolvere i nomi dei campi dati, ovvero sostituisce il nome dei campi dati di un oggetto con l&#39;indirizzo del record dell&#39;oggetto e il displacement del relativo campo dati dell&#39;oggetto. Es: <code>this.pippo --&gt; o + disp[pippo]</code>.</p>
<p>Il <strong>verifier</strong> si occupa poi di controlalre il bytecode prima che questo venga linkato e nel caso si verifichino dei problemi, solleva delle eccezioni di tipo <code>VerifyException</code>.</p>
<p><strong>N.B.</strong>: loader, verifier e linker vengono eseguiti &quot;in contemporanea&quot;, ovvero non è proprio una sequenza di fasi ma una cooperazioni tra componenti.</p>
<p>Il controllo fatto dal verifier è necessario perché il bytecode potrebbe essere stato scritto a mano da dei malintenzionati.
Pertanto il verifier controlla:</p>
<ul>
<li>La correttezza del operation code delle istruzioni;</li>
<li>Che i branch delle operazioni confizionali inzino all&#39;inzio di un&#39;istruzione e non a metà;</li>
<li>Ogni metodo abbia una firma corretta;</li>
<li>I tipi delle espressioni siano corretti.</li>
</ul>
<h2 id="bytecode-interpreter">Bytecode interpreter</h2>
<p>Si occupa di eseguire il bytecode dell&#39;applicazione.</p>
<p>Durante l&#39;esecuzione, l&#39;interprete si occupa di effettuare i controlli run-time come il bound check degli array.</p>
<p>È inoltre possibile compilare il bytecode in codice nativo.</p>
<p>L&#39;interprete è anche in grado di invocare i metodi nativi, parti di programma scritte in C.</p>
<p>C&#39;è poi da eseguire il dynamic lookup dei metodi, e questo può essere fatto in modi diversi:</p>
<ul>
<li><strong>invokevirtual</strong>: invocazione di un metodo per il quale è noto il tipo statico ed è una classe</li>
<li><strong>invokeinterface</strong>: invocazione di un metodo per il quale è noto il tipo statico ed è un&#39;interfaccia</li>
<li><strong>invokestatic</strong>: invocazione di un metodo statico di una classe</li>
<li><strong>invokespecial</strong>: invocazione di un costruttore</li>
</ul>
<p>C&#39;è una differeza tra invokevirtual e invokeinterface, perché nel caso di una classe è garantita la conformità e pertanto il dynamic lookup può essere fatto alla C++, mentre per le interfacce è necessario utilizzare del codice diverso.</p>
<p>Per quanto riguarda i controlli di tipo a run-time, questi riguardano anche i cast e il null-dereferencing.
C&#39;è anche la garbage collection automatica, dal momento che non è presente l&#39;aritmetica dei puntatori.</p>
<h2 id="jvm-data-areas">JVM data areas</h2>
<p>Ovvero le strutture dati a supporto dell&#39;interpretazione del codice, un po&#39; come per la macchina SECD del progetto.</p>
<p><img src="./notes/immagini/l27-jvm-areas.png" alt=""></p>
<ul>
<li><strong>method area</strong>: area di memoria che contiene le informazioni delle classi (il nome è un po&#39; sviante).</li>
<li><strong>heap</strong>: contiene gli oggetti.</li>
<li><strong>Java stacks</strong>: area di memoria contenente le istruzioni da eseguire, <em>stacks</em> perché ce ne è uno per ogni thread.</li>
<li><strong>PC registers</strong>: un program counter per ogni stack.</li>
<li><strong>native method stacks</strong>: zona per l&#39;esecuzione dei metodi nativi.</li>
</ul>
<p><img src="./notes/immagini/l27-jvm-object.png" alt=""></p>
<p>In uno stack della stack area ci sarà un puntatore ad un oggetto allocato nello heap. L&#39;oggetto conterrà poi un puntatore alla sua classe, che si troverà nella method area.</p>
<p>Nella method area si troverà anche la <strong>method table</strong> della classe, un po&#39; come la vtable del C++, con la differenza che in questa tabella c&#39;è anche un puntatore ai <strong>class data</strong>, ovvero i campi dati statici della classe.</p>
<p><img src="./notes/immagini/l27-jvm-ra.png" alt=""></p>
<p>Uno stack della stacks area è composto da una pila di record di attivazione e il relativo program counter conterrà l&#39;indizzo di un&#39;istruzione di un metodo che si trova nella method area.</p>
<p><img src="./notes/immagini/l27-jvm-frame.png" alt=""></p>
<p>Ogni record di attivazione è composto da 3 parti:</p>
<ul>
<li><strong>local variables</strong>: area contenti le variabili locali, ovvero i valori dei parametri che vengono passati al metodo al quale è associato il record di attivazione.</li>
<li><strong>operand stack</strong>: stack contenente gli operandi per le operazioni che devono essere eseguite o per il valore di ritorno.</li>
<li><strong>data area</strong>: area contenente le informazioni riguardo l&#39;indirizzo di ritorno, le eccezioni che possono essere sollevate, i risultati parziali delle operazioni, il <strong>costant pool resolution</strong>.</li>
</ul>
<p>C&#39;è un po&#39; di black magic per determinare la dimensione massima richesta dall&#39;operand stack.</p>
<h2 id="class-file">Class file</h2>
<pre><code><span class="hljs-title">ClassFile</span> { <span class="hljs-title">u4</span> magic; <span class="hljs-title">u2</span> minor_version; <span class="hljs-title">u2</span> major version;
 <span class="hljs-title">u2</span> constant_pool_count;
 <span class="hljs-title">cp_info</span> constant_pool[constant_pool_count-<span class="hljs-number">1</span>];
 <span class="hljs-title">u2</span> access_flags; <span class="hljs-title">u2</span> this_class; <span class="hljs-title">u2</span> super_class;
 <span class="hljs-title">u2</span> interfaces_count; <span class="hljs-title">u2</span> interfaces[interfaces_count];
 <span class="hljs-title">u2</span> fields_count; <span class="hljs-title">field_info</span> fields[fields_count];
 <span class="hljs-title">u2</span> methods_count; <span class="hljs-title">method_info</span> methods[methods_count];
 <span class="hljs-title">u2</span> attributes_count;
 <span class="hljs-title">attribute_info</span> attributes[attributes_count]; 
}
</code></pre><ul>
<li><code>u4</code> e simili indicano quanto spazio richiede il campo dati che segue.</li>
<li><code>minor_version</code> e <code>major_version</code> specificano un intervallo di versioni per la classe</li>
<li><code>constant_pool</code> contiene una lista con tutti i nomi simbolici (classi, metodi, campi dati, costanti, stringhe, ecc.) che compaiono nel ClassFile, il formato di ogni elemento della costant_pool è indicato con un tag di un byte.</li>
<li><code>access_flag</code> rappresenta le specifiche della classe descritta dal file: accessibilità e se è astratta</li>
<li><code>field_info</code> è la tabella che contiene i campi dati della classe e contiene solo i campi dati della classe descritta dal ClassFile e non quelli ereditati dalla superclasse.</li>
<li><code>method_info</code> è una lista che cointene i metodi della classe e, in modo analogo a <code>field_info</code> contiene solo i dati della classe e non della superclasse.</li>
</ul>
<blockquote>
<p>I tag della costant pool non saranno chiesti all&#39;esame</p>
</blockquote>
<p>All&#39;interno delle varie liste ci sono delle strutture dati che contengono le informazioni riguardo a quello che rappresentano.
Ad esempio dentro la <code>constant_pool</code> potrebbe esserci</p>
<pre><code><span class="hljs-title">CONTANT_Class_info</span> { <span class="hljs-title">u1</span> tag; <span class="hljs-title">u2</span> name_index; }
</code></pre><p>con il tag che ha come valore <code>7</code> e <code>name_index</code> che è un indice per la <code>constant_pool</code> che contiene le informazioni riguardanti il nome completo della classe (un oggetto di tipo <code>CONSTANT_Utf8_info</code>).</p>
<pre><code>CONSTANT_Utf8_info {
    u1 tag;<span class="hljs-comment"> // =1</span>
    u2 <span class="hljs-built_in">length</span>;<span class="hljs-comment"> //Numero di caratteri</span>
    u1 <span class="hljs-keyword">bytes</span>[<span class="hljs-built_in">length</span>]<span class="hljs-comment"> //Array di byte contenente la stringa</span>
}
</code></pre><p><code>CONSTANT_Utf8_info</code> rappresenta una stringa, il significato della quale varia in base agli elementi della <code>constant_pool</code> che sono stati &quot;visitati&quot; prima di raggiungere l&#39;oggetto.</p>
<p>La <code>constant_pool</code> è quindi un&#39;oggetto che contiene tutte le informazioni in modo spezzettato, ognuna con un riferimento al pezzo successivo.</p>
<p>Tra le possibili strutture dati della <code>constant_table</code> possono esserci anche <code>CONSTANT_Methodref_info</code> e <code>CONSTANT_InterfaceMethodref_info</code> che distinguono i metodi di una classe da quelli di un&#39;interfaccia. Queste strutture hanno poi un campo dati <code>class_index</code> che referenzia il nome della classe o interfaccia di appartenenza.</p>
<p>Nella lista <code>field_info</code> le strutture dati contenute hanno la forma</p>
<pre><code><span class="hljs-title">field_info</span> { 
    <span class="hljs-title">u2</span> access_flags;
    <span class="hljs-title">u2</span> name_index;
    <span class="hljs-title">u2</span> descriptor_index;
    <span class="hljs-title">u2</span> attributes_count;
    <span class="hljs-title">attribute_info</span> attributes[attributes_count];
}
</code></pre><p>che è diversa rispetto alle strutture della <code>constan_pool</code>.
Per <code>method_list</code> la struttara è simile:</p>
<pre><code><span class="hljs-title">method_info</span> {
    <span class="hljs-title">u2</span> access_flags;
    <span class="hljs-title">u2</span> name_index;
    <span class="hljs-title">u2</span> descriptor_index;
    <span class="hljs-title">u2</span> attributes_count;
    <span class="hljs-title">attribute_info</span> attributes[attributes_count];
}
</code></pre><p>Tra gli attributi del metodo, c&#39;è sicuramente il puntatore al codice.</p>
<p>Grazie a queste strutture dati, l&#39;interprete riesce ad accedere direttamente ai campi dati senza utilizzare il riferimento simbolico. Tuttavia, la ricerca delle informazioni a runtime risulta onerosa in termini di tempo. Anche perché un singolo ClassFile non contiene le informazioni delle superclassi e delle interfacce che implementa.</p>
<p>Perciò viene usata un&#39;ottimizzazione: alla prima esecuzione del codice viene effettuata la ricerca completa per trovare il simbolo corretto nella costant pool, una volta trovato viene modificato il codice sostituendo il riferimento con un offset in modo che per le successive esecuzioni sia possibile accedere direttamente al valore, senza effetturare la ricerca.</p>
<p>L&#39;interprete non si limita quindi ad interpretare il codice, ma lo trasforma in modo da ottimizzare le presetazioni.</p>
<p>Un possibile esempio di bytecode è:</p>
<pre><code>aload i <span class="hljs-comment">//Inserisce in cima al operand_stack il contenuto della i-esima variabile locale </span>
getfield <span class="hljs-preprocessor">#<span class="hljs-number">18</span></span>
</code></pre><p>Prima di poter eseguire la <code>getfield</code>, l&#39;oggetto del quale si vuole accedere al campo dati deve essere in cima al operand stack.
Da notare che prima di eseguire <code>getfield</code> l&#39;inteprete sa già la classe dell&#39;oggetto che potrebbe non essere ancora stata caricata.</p>
<p>Viene quindi acceduta l&#39;entrata 18 della constant pool, la quale deve contenere un <code>filedref_info</code> che specifica la classe, il nome e il tipo del campo che si vuole mettere nello stack.
Queste informazioni devono essere in accordo con la classe dell&#39;oggetto in questione.</p>
<p>Assumendo che il campo dati dell&#39;oggetto si trovi a distanza 10 dall&#39;inzio, l&#39;istruzione <code>getfield #18</code> viene sostituita con <code>getfield_quick 10</code> in modo da velocizzare le successive esecuzioni.</p>
<h1 id="lezione-28-jvm-2-metodi-e-polimorfismo">Lezione 28 - JVM 2 (metodi) e polimorfismo</h1>
<p>Le istruzioni da eseguire per invocare un metodo cambiano in base al tipo statico.</p>
<p>Se il tipo statico è una classe, l&#39;invocazione viene convertita con <code>invokevirtual</code>, altrimenti se è un&#39;interfaccia viene utilizzato <code>invokeinterface</code>.</p>
<h2 id="invokevirtual">Invokevirtual</h2>
<pre><code class="lang-java"><span class="hljs-built_in">Object</span> x;
x.<span class="hljs-keyword">equals</span>(<span class="hljs-string">"test"</span>);
</code></pre>
<p>In bytecode viene convertita con:</p>
<pre><code>aload <span class="hljs-number">1</span> <span class="hljs-comment">//push x assumendo che sia la prima variabile locale</span>
invokevirtual <span class="hljs-preprocessor">#<span class="hljs-number">23</span></span>
</code></pre><p>dove <code>#23</code> riferisce l&#39;entrata della constant pool e deve essere una struttura di tipo <code>methodref_info</code> e che contiene il nome della classe dell&#39;oggetto e il nome e i tipo del metodo invocato.</p>
<p>L&#39;esecuzione di invokevirtual si basa sull&#39;oggeto d&#39;invocazione <code>x</code> e accede alla tabella dei metodi della classi di <code>x</code> cercando un metodo con specifica uguale a quella trovata nell&#39;entrata <code>#23</code> della constant pool.
Se questo viene trovato, il compilatore riesce a trovare l&#39;indirizzo della method area con il codice da invocare per il metodo.</p>
<p>Se non viene trovato, la ricerca continua tra i metodi delle superclass e nel caso peggiore solleva un&#39;eccezione.</p>
<p>Per aumentare l&#39;efficenza, una volta trovato il metodo da invocare, l&#39;istruzione <code>invokevirtual #23</code> viene sostituita con <code>invokevirtual_quick d</code>, dove <code>d</code> è la posizione del metodo nella tabella dei metodi della classe.
Questo codice rende possibile il dynamic lookup perché in Java le classi in gerarchia hanno le tabelle dei metodi conformi.</p>
<h2 id="invokeinterface">Invokeinterface</h2>
<p>Se il tipo statico è un&#39;interfaccia, per invocare il metodo viene utilizzato <code>invokeinterface</code> perché non si può più sfruttare la conformità tra le tabelle dei metodi.
Ad esempio <code>invokeinterface #24</code>.</p>
<p>All&#39;esecuzione dell&#39;istruzione, viene cercata nell&#39;entrata <code>24</code> della constant pool una struttura <code>interfaceMethod_ref</code> che specifica il metodo che si vuole invocare.</p>
<p>La classe dell&#39;oggetto in cima alla pila deve implementare quell&#39;interfaccia ed avere il metodo trovato.</p>
<p>La differenza principale sta nel fatto che <strong>non</strong> si può sostituire l&#39;istruzione con la versione quick, perché non è detto che tutte le classi che implementano l&#39;interfaccia abbiano il metodo sempre nella stessa poszione delle tabella dei metodi.</p>
<p>Si può comunque ottimizzare la cosa tenendo una cache. 
Infatti, una volta risolto il metodo, è nota sia la classe dell&#39;oggetto dinamico, sia l&#39;offeset nella tabella dei metodi. 
In questo modo, la prima volta che viene eseguita l&#39;invocazione del metodo con un oggetto di una determinata classe viene fatta la ricerca e salvato il risultato nella cache. 
Così facendo, se l&#39;esecuzione successiva ha lo stesso tipo dinamico è possibile recuperare il valore dalla cache, evitando la ricerca. Se invece il tipo dinamico non compare in cache è necessario fare una nuova ricerca.</p>
<h2 id="polimorfismo">Polimorfismo</h2>
<p>(Sezione 6.4 e 6.5 nel libro)</p>
<p>Esistono più tipi di polimorfismo:</p>
<ul>
<li><strong>Polimorfismo parametrico</strong>: riguarda il tipo delle funzioni, ovvero funzioni che possono prendere parametri di tipi diversi, ad esempio <code>sort: (‘a * ‘a -&gt; bool)*’a list -&gt; ‘a list</code>. In ML e Haskell il polimorfismo di tipo è implicito e viene inferito automaticamente, mentre in C++ è necessario utilizzare i template.</li>
<li><strong>Polimorfismo ad hoc</strong>: riguarda l&#39;overloading delle funzioni, lo stesso nome di funzione può essere usato con parametri di tipo diverso.</li>
<li><strong>Polimorfismo di sotto tipo</strong>: legato al dynamic lookup e dynamic binding, deriva dal fatto che quando ci si aspetta un oggetto di un determinato tipo, questo può essere di un altro sotto tipo.</li>
</ul>
<p>Rimane da affrontare quello parametrico.</p>
<h3 id="polimoformismo-parametrico-in-c-">Polimoformismo parametrico in C++</h3>
<p>In C++ è possibile utilizzare i template per definire delle variabili di tipo in modo da scrivere del codice generico. Prende il nome di polimorfismo esplicito perché deve essere presente una keyword.</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span>
</span>{
    <span class="hljs-keyword">int</span> tmp=x; x=y; y=tmp; 
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp; x, T &amp; y)</span>
</span>{
    T tmp=x; x=y; y=tmp;
}
<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">int</span> i, j; swap(i,j); <span class="hljs-comment">// T = int</span>
<span class="hljs-built_in">string</span> x,y; swap(x,y); <span class="hljs-comment">// T = string</span>
</code></pre>
<p>Il polimorfismo parametrico è utile quando si vuole che un algoritmo generico funzioni utilizzando variabili di tipo diverso.</p>
<p>Per quanto riguarda ML e Haskell, il polimorfismo è implicito, ci pensa l&#39;algortimo di inferenza automatica a rilevare se la funzione è polimorfa o meno. E anche in questo caso le variabili di tipo vengono istanziate all&#39;invocazione della funzione. Questo avviene anche in C++.</p>
<p>L&#39;implementazione del polimorfismo è diversa tra Haskell e C++, questo perché in C++ l&#39;implementazione dei valori dei diversi tipi è diversa, pertando il codice che manipola questi valori è specifico per ciascun tipo.
Mentre in ML/Haskell l&#39;impementazione dei valori di tipi diversi è <strong>uniforme</strong> e quinti la manipolazione dei valori è uniforme per tutti i tipi.</p>
<p>Long story short: in C++ serve del codice ad hoc per ogni instanziazione del template, in Haskell/ML no (lo stesso codice va bene per tutti i tipi).</p>
<p>In C++, quando e da chi vengono prodotte le diverse istanze di una funzione template <code>F(T x)</code>? Considerando il caso in cui un programma è costruito da più unità di compilazioni (programma diviso su più moduli).</p>
<p>Ci sono due modelli di risuluzione:</p>
<ul>
<li><strong>inlcusione</strong>: le istenze vengono realizzate durante la compilazione di ciascun pezzo del programma. Ad esempio se il programma è diviso in 3 pezzi, la compilazione di uno di questi, produce anche il codice per le varie <code>F(T x)</code>, istanziata per i vari tipi con i quali viene invocata. È necessario però che ogni parte del programma abbia tutto il codice della funzione template in modo che riesca a compilare il template, non basta la firma del metodo, pertanto è necessario che il template sia ripetuto in ogni parte del programma con il rischio che questi siano diversi.</li>
<li><strong>separazione</strong>: le istanze dei template vengono generate quando i diversi componenti del programma vengono linkati tra di loro. In questo modo la compilazione di una singola parte non produce nessuna istanza dei template, ma vengono prodotti solamente quando tutto il codice è disponibile.</li>
</ul>
<p>La prima soluzione richiede che ogni utinità abbia a disposizione il codice di template. 
La stessa istanza può essere prodotta da più parti distinte, pertanto durante il link devono essere rimosse le copie multiple dello stesso template.</p>
<p>Inoltre il template può richiedere altre definzioni gloabali, ad esempio:</p>
<pre><code class="lang-c++"><span class="hljs-comment">//file3.h</span>
<span class="hljs-preprocessor"># <span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;
<span class="hljs-preprocessor"># <span class="hljs-keyword">include</span> <span class="hljs-string">"file3.C"</span></span>

<span class="hljs-comment">//file3.C</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"di file3.C "</span>&lt;&lt;x&lt;&lt;endl;}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T t)</span> </span>{ g(<span class="hljs-number">0</span>); }

<span class="hljs-comment">//caller3.C</span>
<span class="hljs-preprocessor"># <span class="hljs-keyword">include</span> <span class="hljs-string">"file3.h"</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>{<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"di caller "</span>&lt;&lt;x&lt;&lt;endl;}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{ f(<span class="hljs-number">3.14</span>); g(<span class="hljs-number">2</span>);}
main(){ h();} <span class="hljs-comment">// "di file3.C 0" "di file3.C 2"</span>
</code></pre>
<p>In questo caso l&#39;inclusione del template porta con se anche la definzione di <code>g(int)</code>, che viene resa disponibile anche dentro il file <code>caller3.C</code>. Questo fenomeno prende il nome di <strong>name hijack</strong> o cattura dei nomi globali.</p>
<p>Il vantaggio dell&#39;<strong>inclusione</strong> è che è semplice da implementare, ma ci sono dei problemi con i nomi globali e nella gestione dei duplicati durante la fase di link.</p>
<p>Utilizzando l&#39;approccio di <strong>separazione</strong>, esiste una sola definizione del template e tutte le unità hanno solo il prototipo.
Quindi la compilazione delle singole unità non genera istanze del templalte.</p>
<p>Solo in fase di link la definzione del templeate e tutte le sue possibili istanzazioni vengono &quot;accoppiate&quot; e pertanto diventa possibile compilare le istanze necessarie.</p>
<p>Il problema in questo caso è che la fase di link è una fase avanzata della compilazione, pertanto certi errori possono essere rilevati solo quando si è arrivati a questa fase.
Inoltre, si deve aggiungere la responsabilità di compilare i template al linker.</p>
<h3 id="polimorfismo-di-tipo-in-ml">Polimorfismo di tipo in ML</h3>
<p>In ML il discorso è più semplice, dal momento che viene prodotta una sola versione del codice della funzione polimorfa, questo perché i tipi sono implementati in modo uniforme.</p>
<p>Il che significa che il passaggio dei parametnri avviene attraverso dei puntatori e generlamente tutto il calcolo della funzione avviene tramite assegnamenti tra puntatori.</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swap</span></span> (x,y) = (y,x);
swap :: (t1, t) -&gt; (t, t1)
</code></pre><pre><code><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">K</span></span> <span class="hljs-literal">nil</span> <span class="hljs-constant">L</span> = <span class="hljs-literal">true</span> |
    <span class="hljs-constant">K</span> <span class="hljs-constant">L</span> <span class="hljs-literal">nil</span> = <span class="hljs-literal">false</span> |
    <span class="hljs-constant">K</span> (<span class="hljs-symbol">a:</span>:<span class="hljs-constant">L</span>) (<span class="hljs-symbol">b:</span>:<span class="hljs-constant">N</span>) = <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">then</span> <span class="hljs-literal">false</span>
                      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; b <span class="hljs-keyword">then</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-constant">K</span> <span class="hljs-constant">L</span> <span class="hljs-constant">N</span>;
</code></pre><p>Il tipo calcolato dall&#39;inferenza è <code>K:: int list -&gt; int list -&gt; boolean</code>, questo perché non è possibile eseguire in modo generico il confronto <code>&gt;</code>, pertanto deve essere specificato.
Se si vogliono utilizzare altri tipi, questi devono essere specificati, perdendo comunque il polimorfismo.</p>
<p>Per risolvere questo problema si può &quot;nascondere&quot; il confronto dei parametri:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">K</span></span> <span class="hljs-literal">nil</span> <span class="hljs-constant">L</span> confg =<span class="hljs-literal">false</span>|
    <span class="hljs-constant">K</span> <span class="hljs-constant">L</span> <span class="hljs-literal">nil</span> confg =<span class="hljs-literal">true</span>|
    <span class="hljs-constant">K</span> (<span class="hljs-symbol">a:</span>:<span class="hljs-constant">L</span>) (<span class="hljs-symbol">b:</span>:<span class="hljs-constant">N</span>) confg = <span class="hljs-keyword">if</span> confg(a, b) <span class="hljs-keyword">then</span> <span class="hljs-literal">false</span> 
                            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> confg(b,a) <span class="hljs-keyword">then</span> <span class="hljs-literal">true</span> 
                            <span class="hljs-keyword">else</span> <span class="hljs-constant">K</span> <span class="hljs-constant">L</span> <span class="hljs-constant">N</span> confg ;
</code></pre><p>così facendo viene inferito il tipo <code>K ::&#39;a list -&gt; &#39;b list -&gt; (&#39;a * &#39;b -&gt; bool) -&gt; bool</code> e viene mantenuto il polimorfismo, è però necessario passare come parametro anche l&#39;operatore di confronto.</p>
<p>Il core business della situazione è che la maggior parte degli algortimi hanno una parte naturalmente polimorfa e delle parti più specifiche, pertanto per mantenere il polimorfismo implicito è necessario astrarre le operazioni specifiche.</p>
<p>In ML la maggior parte delle operazioni sono uniformi rispetto ai tipi, quindi si riesce ad avere un codice uniforme, in C++ invece la maggior parte di codice è specifico per il tipo e pertanto è necessario produrre più versioni dello stesso codice.</p>
<h3 id="polimorfismo-parametrico-in-haskell">Polimorfismo parametrico in Haskell</h3>
<p>In Haskell è ancora più semplice dal momento che ci sono le classi di tipo che permettono di definire un&#39;insieme di tipi sui quali è possibile utilizzare delle funzioni.
Il codice dell&#39;esempio precedente diventa:</p>
<pre><code class="lang-haskell">k l [] = False
k [] l= True
k (<span class="hljs-tag">a</span>:b) (c:d) = <span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(a&lt;c)</span></span> then True
                <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(c&lt;a)</span></span> then False
                <span class="hljs-keyword">else</span> (k <span class="hljs-tag">b</span> d)
</code></pre>
<p>e il tipo inferito automaticamente è <code>k::(Ord a)=&gt; [a]-&gt;[a]-&gt;Bool</code>, dove <code>Ord</code> è la classe di tipo che raggruppa i tipi sui quali sono definite le operazioni di ordinamento.
Così facendo le istruzioni che <em>mettono in pericolo</em> il polimorfismo, vengono astratte dalle classi di tipo.
Si può osservare che c&#39;è una certa similarità tra le classi di tipo Haskell e le inferfacce del Java.</p>
<h3 id="tirando-le-somme">Tirando le somme</h3>
<ul>
<li>La rappresentazione non uniforme porta ad avere un codice più lungo (molte istanze) ma il codice prodotto è ottimizzato e pertanto più efficente. Gli errori però vengono rilevati a link-time.</li>
<li>La rappresentazione uniforme produce meno codice ma meno ottimizzato a causa della dereferenziazione dei puntatori, sia in tempo che in spazio. Gli errori vengono rilevati a compile-time. C&#39;è da dire che i problemi di efficienza sono tipici dei linguaggi funzionali.</li>
<li>In C++ l&#39;utilizzo dei template viene favorito dalla possibilità di estendere gli operatori standard <code>==</code>, <code>&gt;=</code>, ecc.</li>
<li>In ML l&#39;overloading esistente è limitato dagli operatori per i tipi predefiniti che non sono estendibili. È possibile con un barbatrucco raggirare questa limitazione ma questo approccio non scala con la dimensione del programma, perché è necessario andare a definire tante funzioni polimorfe da passare come parametri.</li>
<li>In Haskell esiste l&#39;overloading degli operatori ed è possibile utilizzare le classi di tipo, rendendo più semplice utilizzare il polimorfismo parametrico.</li>
</ul>
<h3 id="java-generics">Java Generics</h3>
<p>Prima dell&#39;introduzione dei Generics in Java c&#39;era il <strong>generic idiom</strong>:</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList(); <span class="hljs-comment">//raw type</span>
<span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>add(<span class="hljs-string">"hello"</span>);
<span class="hljs-built_in">String</span> s = (<span class="hljs-built_in">String</span>) <span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>get(<span class="hljs-number">0</span>);
<span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>add(<span class="hljs-number">1</span>); <span class="hljs-comment">//Nessun errore</span>
</code></pre>
<p>con l&#39;introduzione dei generics (Java 5) il codice diventa:</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;(); <span class="hljs-comment">//Aggiunge l'informazione riguardo al tipo degli oggetti contenuti nella lista</span>
<span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>add(<span class="hljs-string">"hello"</span>);
<span class="hljs-built_in">String</span> s = <span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>get(<span class="hljs-number">0</span>); <span class="hljs-comment">//Non serve il cast</span>
<span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>add(<span class="hljs-number">1</span>); <span class="hljs-comment">//Errore segnalato dal compilatore</span>
</code></pre>
<p>Per mantenere la retro compatibilità con le versioni precedenti, il compilatore produce lo stesso bytecode omettendo il check sui parametri di tipo. Questo ha permesso di non modificare la JVM e non porta problemi perché i tipi vengono controllati staticamente prima di produrre il bytecode, quindi gli errori di tipo vengono comunque rivelati.</p>
<p>Entrambi i frammenti sopra producono lo stesso codice:</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList();
<span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>add(<span class="hljs-string">"hello"</span>);
<span class="hljs-built_in">String</span> s = <span class="hljs-built_in">list</span><span class="hljs-built_in">.</span>get(<span class="hljs-number">0</span>);
</code></pre>
<p>Questo è vero fino ad un certo punto, perché se vengono mescolate versioni diverse di Java &lt; 5 con Java &gt; 5, i controlli vengono mantenuti.</p>
<h1 id="lezione-29-java-generics">Lezione 29 - Java generics</h1>
<p><strong>raw type</strong>: tipi normali non parametrici.</p>
<p>In Java <code>List&lt;String&gt;</code> non è una nuova classe creata dal template <code>List&lt;T&gt;</code>, ma è una notazione per specificare al compliatore che si intende utilizzare la lista come una lista di stringhe, permettendo così al compilatore di controllare il tipi.</p>
<pre><code class="lang-java"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">String</span>&gt;();
<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; lo = ls; <span class="hljs-comment">// Il compilatore segnala un errore (no covarianza)</span>

<span class="hljs-comment">// Se l'assegnazione fosse andata a buon fine sarebbe stato possibile</span>
<span class="hljs-comment">// eseguire le seguenti operazioni</span>
lo.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>());
<span class="hljs-built_in">String</span> s = ls.<span class="hljs-literal">get</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Errore: prova ad assegnare un Object ad una String</span>
</code></pre>
<p>Con i generics si <strong>perde la covarianza</strong> dei riferimenti e <code>List&lt;Object&gt;</code> non viene considerato come sopra tipo di <code>List&lt;String&gt;</code>.</p>
<h2 id="metodi-generici">Metodi generici</h2>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,E&gt; <span class="hljs-typename">void</span> fromArrayToCollection (T[] a, Collection&lt;E&gt; c)
    <span class="hljs-keyword">for</span> (T <span class="hljs-string">o :</span> a) {
        c.add(o);
    }
}
</code></pre>
<p>Il codice sopra riportato non compila, perché il tipo dell&#39;array e il tipo della collezione non sono in relazione tra loro.</p>
<p>Un&#39;alternativa è quella di utilizzare una collezione di <code>Object</code>.</p>
<pre><code class="lang-java">public <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">void</span> fromArrayToCollection (T[] a, <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Object</span>&gt; c) <span class="hljs-decorator">{...}</span>
</code></pre>
<p>questa definizione però non funziona bene:</p>
<pre><code class="lang-java">fromArrayToCollection<span class="hljs-list">(<span class="hljs-keyword">intArray</span>, objectCollection)</span><span class="hljs-comment">; //Ok</span>
fromArrayToCollection<span class="hljs-list">(<span class="hljs-keyword">intArray</span>, intCollection)</span><span class="hljs-comment">; //Errore di compilazione</span>
</code></pre>
<p>Viene sollevato un errore perché <code>Collection&lt;Int&gt;</code> non è sotto tipo di <code>Collection&lt;Object&gt;</code>.</p>
<p>Un&#39;altra idea può essere quella di utilizzare il raw type:</p>
<pre><code class="lang-java">public <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">void</span> fromArrayToCollection (T[] a, <span class="hljs-type">Collection</span> c) <span class="hljs-decorator">{...}</span>
</code></pre>
<p>In questo modo viene mescolato il codice pre-generics con il codice generics. Il compilatore solleva un warning per la chiamata della funzione <code>add()</code> perché non riesce a fare il controllo di tipo a compile time e deve inserire un controllo di tipo a runtime.
Questo perché la collection nella quale andiamo ad aggiungere l&#39;elemento potrebbe contenere oggetti di un tipo diverso e l&#39;<code>add()</code> riuscirebbe ad aggiungere comunque l&#39;oggetto di tipo <code>T</code>, introducendo la possibilità di un errore runtime durante il resto dell&#39;esecuzione del programma, ovvero quando verrà estratto dalla lista l&#39;elemento aggiunto.</p>
<p>Questo è un problema generico che si verifica quando si mescola il codice con i generics con il codice senza i generics.
Segue inoltre che <code>Collection&lt;Object&gt;</code> non ha lo stesso tipo di <code>Collection</code>.</p>
<p>Un&#39;altra possibile soluzione è:</p>
<pre><code class="lang-java">public <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">void</span> fromArrayToCollection (T[] a, <span class="hljs-type">Collection</span>&lt;?&gt; c) <span class="hljs-decorator">{...}</span>
</code></pre>
<p>ovvero utilizzando la wild card <code>&lt;?&gt;</code>. In particolare <code>Collection&lt;?&gt;</code> è un sopratipo per tutte le altre collection.</p>
<p>In questo caso il compilatore solleva un errore di compilazione, perché non ha sufficenti informazioni per effettuare il controllo del tipo, ovvero le informazioni fornite sono troppo generiche.</p>
<p>Viene sollevato un errore anziché un warning perché utilizzando la wild card si dice al compilatore <em>&quot;Voglio che controlli il tipo&quot;</em> e lui non ne è in grado. Utilizzando il raw type si dice al compilatore <em>&quot;Me ne frego del tipo&quot;</em>, quindi il compilatore solleva un warning per dire <em>&quot;Occhio che potrebbe esserci un errore&quot;</em>.</p>
<p>Morale della favola, la firma corretta per il metodo è:</p>
<pre><code class="lang-java">public <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-type">void</span> fromArrayToCollection (T[] a, <span class="hljs-type">Collection</span>&lt;T&gt; c) <span class="hljs-decorator">{...}</span>
</code></pre>
<p>e questo dice al compilatore <em>&quot;Guarda che l&#39;array e la collezione devono contenere oggetti dello stesso tipo&quot;</em>.</p>
<p>Con questo sistema viene introdotta la contro varianza a causa della covarianza degli array. Ovvero se <code>T</code> viene istanziato con <code>X</code> e come secondo parametro viene fornito un <code>Collection&lt;Y&gt;</code>, se <code>X &lt;: Y</code> non vengono sollevati errori, anche se dalla firma del metodo sembra che i tipi debbano coincidere per forza.</p>
<pre><code class="lang-java">Object[] oa = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">100</span>];
Collection&lt;Object&gt; <span class="hljs-keyword">co</span> = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();
fromArrayToCollection(oa, <span class="hljs-keyword">co</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Object

String[] <span class="hljs-keyword">sa</span> = <span class="hljs-keyword">new</span> String[<span class="hljs-number">100</span>];
Collection&lt;String&gt; <span class="hljs-keyword">cs</span> = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
fromArrayToCollection(<span class="hljs-keyword">sa</span>, <span class="hljs-keyword">cs</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> String

fromArrayToCollection(<span class="hljs-keyword">sa</span>, <span class="hljs-keyword">co</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Object

Integer[] <span class="hljs-keyword">ia</span> = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">100</span>];
Float[] fa = <span class="hljs-keyword">new</span> Float[<span class="hljs-number">100</span>];
Number[] na = <span class="hljs-keyword">new</span> Number[<span class="hljs-number">100</span>];
Collection&lt;Number&gt; <span class="hljs-keyword">cn</span> = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();

fromArrayToCollection(<span class="hljs-keyword">ia</span>, <span class="hljs-keyword">cn</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Number
fromArrayToCollection(fa, <span class="hljs-keyword">cn</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Number
fromArrayToCollection(na, <span class="hljs-keyword">cn</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Number
fromArrayToCollection(na, <span class="hljs-keyword">co</span>); // T inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> Object
fromArrayToCollection(na, <span class="hljs-keyword">cs</span>); // compile-time error
</code></pre>
<p>C&#39;è un&#39;altra definzione che risulta essere ancora più corretta ed esplicativa:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> fromArrayToCollection (T[] a, Collection&lt;? <span class="hljs-keyword">extends</span> T&gt; c)
</code></pre>
<p><img src="./notes/immagini/l29-subtype.png" alt=""></p>
<p>Il caso d&#39;uso principale della wild card è quando si vogliono leggere dei dati generici di una collezione d&#39;oggetti generica. Tutte le operazioni di scrittura su <code>Collection&lt;?&gt;</code> falliscono perché non è possibile fare il controllo di tipo.</p>
<p>Un&#39;esempio è dato da</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printCollection</span>(<span class="hljs-params">Collection&lt;?&gt; c</span>)</span>{ 
    <span class="hljs-keyword">for</span> (Object e : c) {
        System.<span class="hljs-keyword">out</span>.println(e);
    }
}
</code></pre>
<p>Esercizio:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span></span>; 
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{ 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y, radius; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span> </span>{ ... } 
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{ 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y, width, height; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span> </span>{ ... } 
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Canvas</span> </span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Shape s)</span> </span>{ s.draw(<span class="hljs-keyword">this</span>); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawAll</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> </span>{ 
        <span class="hljs-keyword">for</span> (Shape s: shapes) { 
            s.draw(<span class="hljs-keyword">this</span>); 
        }
    }
}
</code></pre>
<p>Il metodo <code>drawAll</code> funziona solo se riceve una <code>List&lt;Shape&gt;</code>, se riceve una <code>List&lt;Circle&gt;</code> viene sollevato un errore. Per rendere più elastica il metodo si può utilizzare la firma <code>public void drawAll(List&lt;? extends Shape&gt; shapes)</code>.</p>
<p>Non sempre conviene utilizzare la versione flessibile:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addRectangle</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">extends</span> Shape&gt; shapes)</span> </span>{ 
    <span class="hljs-comment">// Compile-time error! shapes.add(0, new Rectangle());</span>
}
</code></pre>
<h2 id="generics-e-codice-vecchio">Generics e codice vecchio</h2>
<pre><code class="lang-java"><span class="hljs-comment">// Codice legacy</span>
package com.Example.widgets;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Part</span> </span>{...}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inventory</span> </span>{ 
    <span class="hljs-comment">/* Adds a new Assembly to the inventory database. 
    The assembly name consists of a set parts specified by parts. 
    All elements of the collection parts must support the Part
    interface. */</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void addAssembly(String name, Collection parts) {...}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Assembly getAssembly(String name) {...} 
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Assembly</span> </span>{
    <span class="hljs-comment">// Returns a collection of Parts Collection</span>
    Collection getParts(); 
}

<span class="hljs-comment">// Parte Generics</span>
package com.mycompany.inventory;
import com.Example.widgets.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blade</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Part</span> </span>{ ... }
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guillotine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Part</span> </span>{ ... } 

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(String[] args) {
        Collection&lt;Part&gt; c = <span class="hljs-keyword">new</span> ArrayList&lt;Part&gt;();
        c.add(<span class="hljs-keyword">new</span> Guillotine()) ;
        c.add(<span class="hljs-keyword">new</span> Blade());
        Inventory.addAssembly(“pippo<span class="hljs-string">", c); // addAssembly si aspetta il raw type, ma il codice compila
        Collection&lt;Part&gt; k = Inventory.getAssembly(“pippo"</span>).getParts();
        <span class="hljs-comment">// L'assegnamento produce un "Unchecked warning" perché</span>
        <span class="hljs-comment">// si sta assegnando una collezione raw ad una collezione</span>
        <span class="hljs-comment">// generica e il compilatore non riesce a stabilire</span>
        <span class="hljs-comment">// la correttezza dei tipi </span>
    }
}
</code></pre>
<p>Questo funziona perché il compilatore Java considera <code>Collection</code> (versione raw type) come <code>Collection&lt;?&gt;</code>, questa scelta è stata forzata per permettere di combinare del codice scritto prima dei generics con il codice che li utilizza.</p>
<p>Per assicurare la correttezza rispetto ai tipi il compilatore introduce dei controlli a runtime per verificare che la <code>Collection</code> ritornata sia effettivamente una <code>Collection&lt;Part&gt;</code>.</p>
<pre><code class="lang-java"><span class="hljs-built_in">Box</span>&lt;<span class="hljs-built_in">String</span>&gt; stringBox = new <span class="hljs-built_in">Box</span>&lt;&gt;();
<span class="hljs-built_in">Box</span> rawBox = stringBox;
rawBox.set(<span class="hljs-number">8</span>);  <span class="hljs-comment">// Compile time warning: unchecked invocation to set(T)</span>
                <span class="hljs-comment">// A runtime viene sollevata un'eccezione</span>
</code></pre>
<h1 id="lezione-30-generics-2-e-laziness">Lezione 30 - Generics 2 e Laziness</h1>
<h2 id="limitazioni-dei-generics">Limitazioni dei Generics</h2>
<p>I parametri di tipo di una classe non possono venire utilizzati nei campi e nei metodi statici della classe.</p>
<pre><code class="lang-java">SingleLinkQueue.<span class="hljs-function"><span class="hljs-title">merge</span><span class="hljs-params">()</span></span>
SingleLinkQueue.merge&lt;String&gt;() <span class="hljs-comment">//Non compila</span>
</code></pre>
<p>All&#39;interno di un metodo non si possono scrivere istruzioni tipo <code>new T()</code> o <code>new T[10]</code>.</p>
<p>Non è possibile definire array di generics, <code>new List&lt;String&gt;[10]</code> non funziona, l&#39;unico caso in cui si può fare è utilizzando la wild card.</p>
<p>Inoltre non si possono usare:</p>
<ul>
<li><code>instanceof</code></li>
<li>cast</li>
<li>eccezioni</li>
<li><code>List&lt;String&gt;.class</code>, perché non esiste la classe <code>List&lt;String&gt;</code>.</li>
</ul>
<h2 id="ereasure">Ereasure</h2>
<p>Il Java Generics, quando viene tradotto in Bytecode, perde i parametri di tipo. In particolare:</p>
<ul>
<li><code>List&lt;A&gt;</code> --&gt; <code>List</code></li>
<li><code>A</code> --&gt; <code>Object</code></li>
<li><code>&lt;? extends Number&gt;</code> --&gt; <code>Number</code></li>
</ul>
<p>In questo modo si garantisce anche la retro compatibilità con il codice Java normale e la JVM.</p>
<p>È possibile rimuovere i parametri di tipo perché quando viene prodotto il Bytecode è già stato type checked.</p>
<p>Ci sono però dei problemi:</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">A</span>&gt;</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(A x, A y)</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteComp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Byte</span>&gt;</span>{ <span class="hljs-comment">//Il parametro Byte viene scartato</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Byte x, Byte y)</span></span>{ <span class="hljs-comment">// ma nella firma del metodo rimane</span>
        <span class="hljs-keyword">return</span> x.byteValue()-y.byteValue();
    }
}
</code></pre>
<p>per gestire questi casi particolari il compliatore genera in modo automatico il codice per gestire questa situazione:</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object x, Object y)</span></span>;
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteComp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Byte x, Byte y)</span></span>{ <span class="hljs-comment">//non è overriding</span>
        <span class="hljs-keyword">return</span> x.byteValue()-y.byteValue();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object x, Object y)</span></span>{ <span class="hljs-comment">//metodo bridge</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compare((Byte) x, (Byte) y);
    }
}
</code></pre>
<h2 id="lazyness-in-haskell">Lazyness in Haskell</h2>
<p>La valutazione lazy implica che non viene calcolato nulla finché non è strettamente necessario.</p>
<p>Data un&#39;espressione questa può essere valutata in modo <strong>inner most</strong> o <strong>outer most</strong>.</p>
<p>Supponendo di avere la funzione <code>square x = x*x</code>. </p>
<p>Per valutare <code>square (3+4)</code> in modo inner most, vengono valutate prima le espressioni più interne, a partire dalla espressioni che sono già risolte (valori in forma normale). Con l&#39;apporccio innermost, viene prima calcolato <code>3+4</code> e poi viene valutato <code>square 7</code>, in questo caso <code>7</code> è già risolto, e viene valutato <code>7*7</code> ottenendo <code>49</code> che è la forma normale dell&#39;espressione.</p>
<p>Per raggiungere la forma normale sono state necessarie 3 operazioni.</p>
<p>Con l&#39;approccio outer most, viene calcolata come prima espressione quella che non è contenuta in altre espressioni più grandi.
Ovvero, partendo da <code>square (3+4)</code>, viene prima valutato <code>square</code>, ottenendo <code>(3+4)*(3+4)</code>. L&#39;espressione più esterna adesso è <code>3+4</code>, ottenendo <code>7*(3+4)</code>, viene poi valutata ancora <code>3+4</code>, ottenendo <code>7*7</code>. Infine si calcola il risultato <code>7</code> in 4 passi.</p>
<p>Indipendentemente dall&#39;approccio, ad ogni passo si riduce un espressione che prende il nome di <strong>redex</strong>.</p>
<p>Quindi, con l&#39;approccio inner most viene ridotto il redex che non contiene altri redex e con l&#39;approccio outermost viene ridotto il redex che non è contenuto da altri redex.</p>
<p>L&#39;approccio lazy valuta le espressioni in modo outer most, pertanto anche se ha delle proprietà interessanti, è inefficiente.</p>
<p>Ci sono però dei casi in cui outermost richiede meno operazioni.</p>
<p>Ad esempio, consideriamo la funzione <code>fst</code> che ritorna il primo elemento di una tupla.</p>
<p>Per calcolare l&#39;espressione <code>fst(square 4, square 2)</code> con l&#39;approccio inner most è necessario calcolare prima <code>square 4</code> e poi <code>square 2</code> ed infine ritornare il valore di <code>square 4</code>, scartando il valore di <code>square 2</code> che è stato calcolato inutilmente.</p>
<p>Utilizzando l&#39;approccio outer most, il valore di <code>square 2</code> non viene calcolato richedendo così meno operazioni.
Questo perché <code>fst</code> è una funzione lazy.</p>
<p>Un&#39;espressione potrebbe non essere riducibile alla forma normale, però se questa è raggiungibile, è sicuramente raggiungibile con l&#39;approccio outer most, cosa che non è sempre vera per inner most.</p>
<p><code>fst(square 4, undefined)</code> raggiunge la forma normale solo se calcolata con l&#39;approccio outermost.</p>
<p>Indipendentemente dall&#39;ordine con cui si valutano le espressioni, la forma normale che si raggiunge è sempre quella.</p>
<p>In alcuni casi l&#39;approccio outer most può essere reso più efficiente per evitare di eseguire calcoli ripetuti, effettuando delle ottimizzazioni con dei grafi.</p>
<p>Outer most però ha altri svantaggi legati all&#39;efficienza:</p>
<pre><code class="lang-haskell">sum [<span class="hljs-number">0.</span><span class="hljs-number">.1000</span>] = foldl (+) <span class="hljs-number">0</span> [<span class="hljs-number">1.</span><span class="hljs-number">.10000</span>]
              = foldl (+) <span class="hljs-number">0</span>+<span class="hljs-number">1</span> [<span class="hljs-number">2.</span><span class="hljs-number">.10000</span>]
              = foldl (+) <span class="hljs-number">0</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span> [<span class="hljs-number">3.</span><span class="hljs-number">.10000</span>]
              = ...
</code></pre>
<p>ovvero prima estrae i valori dalla lista e poi quando a finito li somma.
In questo caso sarebbe conveniente avere delle riduzioni inner most ed è quello che viene fatto da <code>foldl&#39;</code>.</p>
<p>I valori in Haskell sono estremamente stratificati, ovvero sono dei data type discriminati da dei costruttori, ognungo dei quali può essere rappresentato come un albero e non sempre è interessante calcolare tutto l&#39;albero, perché potrebbe essere interessante solo una porzione dell&#39;albero.</p>
<pre><code class="lang-haskell">let
    z = (length [1..5], reverse <span class="hljs-string">"olleh"</span>) <span class="hljs-comment">// z=thunk</span>
    (<span class="hljs-keyword">n</span>, s) = z <span class="hljs-comment">// z=(thunk, thunk) n=thunk, s=thunk</span>
    '<span class="hljs-keyword">h</span>':ss = <span class="hljs-literal">s</span>
<span class="hljs-keyword">in</span> 
    ...
</code></pre>
<p><code>thunk</code> indica un espressione che deve essere calcolata e che contiene anche le informazioni legate all&#39;ambiente che deve essere usato per valutarla, in un modo simile alle chiusure delle funzioni.</p>
<p>Per effettuare il pattern matching e proseguire con l&#39;esecuzione del programma, viene calcolato il minimo indispensabile, ovvero fino a che non si arriva al fatto che il valore di <code>z</code> è una coppia.</p>
<p>Per calcolare <code>&#39;h&#39;:ss = s</code> viene valutato il valore di <code>s</code> per verificare che sia una lista del tipo <code>thunk:thunk</code>, la cosa importante è che <code>s</code> sia una lista non vuota, altrimenti viene sollevato un errore riguardo il pattern matching.
Poi deve essere matchato il carattere <code>h</code>, quindi viene valutato il primo <code>thunk</code>, ottenendo <code>s = &#39;h&#39;:thunk</code> e <code>ss = thunk</code>, da notare che il thunk di <code>ss</code> corrisponde all&#39;espressione <code>reverse &quot;olle&quot;</code>.</p>
<p>Tutte le espressioni intermedie che contendono dei thunk prendono il nome di <strong>weak head normale form</strong>.</p>
<p><img src="./notes/immagini/l30-1.png" alt=""></p>
<p>Una funzione può essere <strong>strict</strong> o <strong>lazy</strong>:</p>
<ul>
<li>una funzione strict è una funzione che utilizza i suoi parametri, quindi è necessario che questi vengono valutati</li>
<li>una funzione lazy non usa tutti i suoi parametri, quindi può essere che alcuni non vengano valutati.</li>
</ul>
<p>Nel caso di funzioni lazy conviene quindi utilizzare la valutazione outer most per limitare il numero di calcoli.</p>
<p><img src="./notes/immagini/l30-2.png" alt=""></p>
<p>Non è facile valutare se una funzione è lazy o meno, sempre per il discorso della non decidibilità, dei linguaggi di Turing ecc.</p>
<p>Perché una funzione sia strict, questa deve forzare il valore di un parametro. Ovvero quando <code>f x</code> forza la valutazione del parametro <code>x</code>.</p>
<p>Ad esempio verrebbe da pensare che la funzione <code>id</code> non sia strict perché ritorna semplicemente il valore ricevuto come parametro. Tuttavia, questa funzione stampa sull&#39;ambiente di esecuzione il valore del parametro e di conseguenza viene forzata la valutazione.</p>
<pre><code class="lang-haskell">-- We evaluate the right-hand <span class="hljs-keyword">of</span> the <span class="hljs-keyword">let</span>-binding <span class="hljs-keyword">to</span>
WHNF <span class="hljs-keyword">by</span> pattern-matching
-- against <span class="hljs-literal">it</span>.
<span class="hljs-keyword">let</span> (x, y) = <span class="hljs-literal">undefined</span> <span class="hljs-keyword">in</span> x
-- Error, because we force <span class="hljs-literal">undefined</span>.
<span class="hljs-keyword">let</span> (x, y) = id <span class="hljs-literal">undefined</span> <span class="hljs-keyword">in</span> x
-- Error, because we force <span class="hljs-literal">undefined</span>.

<span class="hljs-keyword">const</span> a b = a -- lazy sul secondo parametro
<span class="hljs-keyword">let</span> (x, y) = <span class="hljs-keyword">const</span> (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-literal">undefined</span>
-- No error, because <span class="hljs-keyword">const</span> (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-literal">undefined</span> = (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), thus
-- <span class="hljs-literal">undefined</span> <span class="hljs-keyword">is</span> ignored
</code></pre>
</body></html>